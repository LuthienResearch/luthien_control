{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":""},{"location":"#luthien_control.admin","title":"<code>admin</code>","text":"<p>Admin module for Luthien Control.</p>"},{"location":"#luthien_control.admin.auth","title":"<code>auth</code>","text":"<p>Authentication logic for admin users.</p>"},{"location":"#luthien_control.admin.auth.AdminAuthService","title":"<code>AdminAuthService</code>","text":"Source code in <code>luthien_control/admin/auth.py</code> <pre><code>class AdminAuthService:\n    \"\"\"Service for admin authentication operations.\"\"\"\n\n    async def ensure_default_admin(self, db: AsyncSession) -&gt; None:\n        \"\"\"Ensure a default admin user exists.\"\"\"\n        # Check if any admin users exist\n        admins = await admin_user_crud.list_all(db)\n        if admins:\n            return\n\n        # Create default admin from environment variables\n        default_username = os.getenv(\"ADMIN_USERNAME\", \"admin\")\n        default_password = os.getenv(\"ADMIN_PASSWORD\", \"changeme\")\n\n        logger.warning(f\"Creating default admin user '{default_username}'. Please change the password immediately!\")\n\n        await admin_user_crud.create(\n            db,\n            username=default_username,\n            password=default_password,\n            is_superuser=True,\n        )\n\n    async def authenticate(self, db: AsyncSession, username: str, password: str) -&gt; Optional[AdminUser]:\n        \"\"\"Authenticate admin user.\"\"\"\n        # Clean up expired sessions\n        await admin_session_crud.cleanup_expired_sessions(db)\n\n        # Verify credentials\n        return await admin_user_crud.verify_password(db, username, password)\n\n    async def create_session(self, db: AsyncSession, admin_user: AdminUser) -&gt; AdminSession:\n        \"\"\"Create a new session for authenticated user.\"\"\"\n        session_hours = int(os.getenv(\"ADMIN_SESSION_HOURS\", \"24\"))\n        if admin_user.id is None:\n            raise ValueError(\"Admin user ID is None\")\n        return await admin_session_crud.create_session(db, admin_user.id, hours=session_hours)\n\n    async def get_user_from_session(self, db: AsyncSession, session_token: str) -&gt; Optional[AdminUser]:\n        \"\"\"Get admin user from session token.\"\"\"\n        session = await admin_session_crud.get_valid_session(db, session_token)\n        if not session:\n            return None\n\n        user = await admin_user_crud.get_by_id(db, session.admin_user_id)\n        if not user or not user.is_active:\n            return None\n\n        return user\n\n    async def logout(self, db: AsyncSession, session_token: str) -&gt; bool:\n        \"\"\"Logout by deleting session.\"\"\"\n        return await admin_session_crud.delete_session(db, session_token)\n</code></pre> <p>Service for admin authentication operations.</p>"},{"location":"#luthien_control.admin.auth.AdminAuthService.authenticate","title":"<code>authenticate(db, username, password)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/auth.py</code> <pre><code>async def authenticate(self, db: AsyncSession, username: str, password: str) -&gt; Optional[AdminUser]:\n    \"\"\"Authenticate admin user.\"\"\"\n    # Clean up expired sessions\n    await admin_session_crud.cleanup_expired_sessions(db)\n\n    # Verify credentials\n    return await admin_user_crud.verify_password(db, username, password)\n</code></pre> <p>Authenticate admin user.</p>"},{"location":"#luthien_control.admin.auth.AdminAuthService.create_session","title":"<code>create_session(db, admin_user)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/auth.py</code> <pre><code>async def create_session(self, db: AsyncSession, admin_user: AdminUser) -&gt; AdminSession:\n    \"\"\"Create a new session for authenticated user.\"\"\"\n    session_hours = int(os.getenv(\"ADMIN_SESSION_HOURS\", \"24\"))\n    if admin_user.id is None:\n        raise ValueError(\"Admin user ID is None\")\n    return await admin_session_crud.create_session(db, admin_user.id, hours=session_hours)\n</code></pre> <p>Create a new session for authenticated user.</p>"},{"location":"#luthien_control.admin.auth.AdminAuthService.ensure_default_admin","title":"<code>ensure_default_admin(db)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/auth.py</code> <pre><code>async def ensure_default_admin(self, db: AsyncSession) -&gt; None:\n    \"\"\"Ensure a default admin user exists.\"\"\"\n    # Check if any admin users exist\n    admins = await admin_user_crud.list_all(db)\n    if admins:\n        return\n\n    # Create default admin from environment variables\n    default_username = os.getenv(\"ADMIN_USERNAME\", \"admin\")\n    default_password = os.getenv(\"ADMIN_PASSWORD\", \"changeme\")\n\n    logger.warning(f\"Creating default admin user '{default_username}'. Please change the password immediately!\")\n\n    await admin_user_crud.create(\n        db,\n        username=default_username,\n        password=default_password,\n        is_superuser=True,\n    )\n</code></pre> <p>Ensure a default admin user exists.</p>"},{"location":"#luthien_control.admin.auth.AdminAuthService.get_user_from_session","title":"<code>get_user_from_session(db, session_token)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/auth.py</code> <pre><code>async def get_user_from_session(self, db: AsyncSession, session_token: str) -&gt; Optional[AdminUser]:\n    \"\"\"Get admin user from session token.\"\"\"\n    session = await admin_session_crud.get_valid_session(db, session_token)\n    if not session:\n        return None\n\n    user = await admin_user_crud.get_by_id(db, session.admin_user_id)\n    if not user or not user.is_active:\n        return None\n\n    return user\n</code></pre> <p>Get admin user from session token.</p>"},{"location":"#luthien_control.admin.auth.AdminAuthService.logout","title":"<code>logout(db, session_token)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/auth.py</code> <pre><code>async def logout(self, db: AsyncSession, session_token: str) -&gt; bool:\n    \"\"\"Logout by deleting session.\"\"\"\n    return await admin_session_crud.delete_session(db, session_token)\n</code></pre> <p>Logout by deleting session.</p>"},{"location":"#luthien_control.admin.crud","title":"<code>crud</code>","text":"<p>Admin CRUD operations.</p>"},{"location":"#luthien_control.admin.crud.admin_user","title":"<code>admin_user</code>","text":"<p>CRUD operations for admin users.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminSessionCRUD","title":"<code>AdminSessionCRUD</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>class AdminSessionCRUD:\n    \"\"\"CRUD operations for admin sessions.\"\"\"\n\n    async def create_session(self, db: AsyncSession, admin_user_id: int, hours: int = 24) -&gt; AdminSession:\n        \"\"\"Create a new admin session.\"\"\"\n        session_token = secrets.token_urlsafe(32)\n        expires_at = datetime.now(timezone.utc).replace(tzinfo=None) + timedelta(hours=hours)\n\n        session = AdminSession(\n            session_token=session_token,\n            admin_user_id=admin_user_id,\n            expires_at=expires_at,\n        )\n\n        db.add(session)\n        await db.commit()\n        await db.refresh(session)\n        return session\n\n    async def get_valid_session(self, db: AsyncSession, session_token: str) -&gt; Optional[AdminSession]:\n        \"\"\"Get a valid (non-expired) session by token.\"\"\"\n        result = await db.execute(\n            select(AdminSession).where(\n                and_(\n                    AdminSession.session_token == session_token,  # type: ignore\n                    AdminSession.expires_at &gt; datetime.now(timezone.utc).replace(tzinfo=None),  # type: ignore\n                )\n            )\n        )\n        return result.scalar_one_or_none()\n\n    async def delete_session(self, db: AsyncSession, session_token: str) -&gt; bool:\n        \"\"\"Delete a session (logout).\"\"\"\n        result = await db.execute(select(AdminSession).where(AdminSession.session_token == session_token))  # type: ignore\n        session = result.scalar_one_or_none()\n\n        if session:\n            await db.delete(session)\n            await db.commit()\n            return True\n\n        return False\n\n    async def cleanup_expired_sessions(self, db: AsyncSession) -&gt; int:\n        \"\"\"Clean up expired sessions.\"\"\"\n        result = await db.execute(\n            select(AdminSession).where(AdminSession.expires_at &lt;= datetime.now(timezone.utc).replace(tzinfo=None))  # type: ignore\n        )\n        expired_sessions = list(result.scalars().all())\n\n        count = len(expired_sessions)\n        for session in expired_sessions:\n            await db.delete(session)\n\n        if count &gt; 0:\n            await db.commit()\n\n        return count\n</code></pre> <p>CRUD operations for admin sessions.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminSessionCRUD.cleanup_expired_sessions","title":"<code>cleanup_expired_sessions(db)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def cleanup_expired_sessions(self, db: AsyncSession) -&gt; int:\n    \"\"\"Clean up expired sessions.\"\"\"\n    result = await db.execute(\n        select(AdminSession).where(AdminSession.expires_at &lt;= datetime.now(timezone.utc).replace(tzinfo=None))  # type: ignore\n    )\n    expired_sessions = list(result.scalars().all())\n\n    count = len(expired_sessions)\n    for session in expired_sessions:\n        await db.delete(session)\n\n    if count &gt; 0:\n        await db.commit()\n\n    return count\n</code></pre> <p>Clean up expired sessions.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminSessionCRUD.create_session","title":"<code>create_session(db, admin_user_id, hours=24)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def create_session(self, db: AsyncSession, admin_user_id: int, hours: int = 24) -&gt; AdminSession:\n    \"\"\"Create a new admin session.\"\"\"\n    session_token = secrets.token_urlsafe(32)\n    expires_at = datetime.now(timezone.utc).replace(tzinfo=None) + timedelta(hours=hours)\n\n    session = AdminSession(\n        session_token=session_token,\n        admin_user_id=admin_user_id,\n        expires_at=expires_at,\n    )\n\n    db.add(session)\n    await db.commit()\n    await db.refresh(session)\n    return session\n</code></pre> <p>Create a new admin session.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminSessionCRUD.delete_session","title":"<code>delete_session(db, session_token)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def delete_session(self, db: AsyncSession, session_token: str) -&gt; bool:\n    \"\"\"Delete a session (logout).\"\"\"\n    result = await db.execute(select(AdminSession).where(AdminSession.session_token == session_token))  # type: ignore\n    session = result.scalar_one_or_none()\n\n    if session:\n        await db.delete(session)\n        await db.commit()\n        return True\n\n    return False\n</code></pre> <p>Delete a session (logout).</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminSessionCRUD.get_valid_session","title":"<code>get_valid_session(db, session_token)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def get_valid_session(self, db: AsyncSession, session_token: str) -&gt; Optional[AdminSession]:\n    \"\"\"Get a valid (non-expired) session by token.\"\"\"\n    result = await db.execute(\n        select(AdminSession).where(\n            and_(\n                AdminSession.session_token == session_token,  # type: ignore\n                AdminSession.expires_at &gt; datetime.now(timezone.utc).replace(tzinfo=None),  # type: ignore\n            )\n        )\n    )\n    return result.scalar_one_or_none()\n</code></pre> <p>Get a valid (non-expired) session by token.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminUserCRUD","title":"<code>AdminUserCRUD</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>class AdminUserCRUD:\n    \"\"\"CRUD operations for admin users.\"\"\"\n\n    async def get_by_username(self, db: AsyncSession, username: str) -&gt; Optional[AdminUser]:\n        \"\"\"Get admin user by username.\"\"\"\n        result = await db.execute(select(AdminUser).where(AdminUser.username == username))  # type: ignore\n        return result.scalar_one_or_none()\n\n    async def get_by_id(self, db: AsyncSession, user_id: int) -&gt; Optional[AdminUser]:\n        \"\"\"Get admin user by ID.\"\"\"\n        result = await db.execute(select(AdminUser).where(AdminUser.id == user_id))  # type: ignore\n        return result.scalar_one_or_none()\n\n    async def create(\n        self,\n        db: AsyncSession,\n        username: str,\n        password: str,\n        is_superuser: bool = False,\n    ) -&gt; AdminUser:\n        \"\"\"Create a new admin user.\"\"\"\n        password_hash = bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt())\n\n        admin_user = AdminUser(\n            username=username,\n            password_hash=password_hash.decode(\"utf-8\"),\n            is_superuser=is_superuser,\n        )\n\n        db.add(admin_user)\n        await db.commit()\n        await db.refresh(admin_user)\n        return admin_user\n\n    async def verify_password(self, db: AsyncSession, username: str, password: str) -&gt; Optional[AdminUser]:\n        \"\"\"Verify username and password.\"\"\"\n        user = await self.get_by_username(db, username)\n        if not user or not user.is_active:\n            return None\n\n        if bcrypt.checkpw(password.encode(\"utf-8\"), user.password_hash.encode(\"utf-8\")):\n            # Update last login\n            user.last_login = datetime.now(timezone.utc).replace(tzinfo=None)\n            await db.commit()\n            return user\n\n        return None\n\n    async def list_all(self, db: AsyncSession) -&gt; List[AdminUser]:\n        \"\"\"List all admin users.\"\"\"\n        result = await db.execute(select(AdminUser).order_by(AdminUser.created_at))  # type: ignore\n        return list(result.scalars().all())\n</code></pre> <p>CRUD operations for admin users.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminUserCRUD.create","title":"<code>create(db, username, password, is_superuser=False)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def create(\n    self,\n    db: AsyncSession,\n    username: str,\n    password: str,\n    is_superuser: bool = False,\n) -&gt; AdminUser:\n    \"\"\"Create a new admin user.\"\"\"\n    password_hash = bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt())\n\n    admin_user = AdminUser(\n        username=username,\n        password_hash=password_hash.decode(\"utf-8\"),\n        is_superuser=is_superuser,\n    )\n\n    db.add(admin_user)\n    await db.commit()\n    await db.refresh(admin_user)\n    return admin_user\n</code></pre> <p>Create a new admin user.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminUserCRUD.get_by_id","title":"<code>get_by_id(db, user_id)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def get_by_id(self, db: AsyncSession, user_id: int) -&gt; Optional[AdminUser]:\n    \"\"\"Get admin user by ID.\"\"\"\n    result = await db.execute(select(AdminUser).where(AdminUser.id == user_id))  # type: ignore\n    return result.scalar_one_or_none()\n</code></pre> <p>Get admin user by ID.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminUserCRUD.get_by_username","title":"<code>get_by_username(db, username)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def get_by_username(self, db: AsyncSession, username: str) -&gt; Optional[AdminUser]:\n    \"\"\"Get admin user by username.\"\"\"\n    result = await db.execute(select(AdminUser).where(AdminUser.username == username))  # type: ignore\n    return result.scalar_one_or_none()\n</code></pre> <p>Get admin user by username.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminUserCRUD.list_all","title":"<code>list_all(db)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def list_all(self, db: AsyncSession) -&gt; List[AdminUser]:\n    \"\"\"List all admin users.\"\"\"\n    result = await db.execute(select(AdminUser).order_by(AdminUser.created_at))  # type: ignore\n    return list(result.scalars().all())\n</code></pre> <p>List all admin users.</p>"},{"location":"#luthien_control.admin.crud.admin_user.AdminUserCRUD.verify_password","title":"<code>verify_password(db, username, password)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/crud/admin_user.py</code> <pre><code>async def verify_password(self, db: AsyncSession, username: str, password: str) -&gt; Optional[AdminUser]:\n    \"\"\"Verify username and password.\"\"\"\n    user = await self.get_by_username(db, username)\n    if not user or not user.is_active:\n        return None\n\n    if bcrypt.checkpw(password.encode(\"utf-8\"), user.password_hash.encode(\"utf-8\")):\n        # Update last login\n        user.last_login = datetime.now(timezone.utc).replace(tzinfo=None)\n        await db.commit()\n        return user\n\n    return None\n</code></pre> <p>Verify username and password.</p>"},{"location":"#luthien_control.admin.dependencies","title":"<code>dependencies</code>","text":"<p>Dependencies for admin authentication.</p>"},{"location":"#luthien_control.admin.dependencies.CSRFProtection","title":"<code>CSRFProtection</code>","text":"Source code in <code>luthien_control/admin/dependencies.py</code> <pre><code>class CSRFProtection:\n    \"\"\"CSRF protection for forms.\"\"\"\n\n    def __init__(self):\n        self.token_name = \"csrf_token\"\n\n    async def generate_token(self) -&gt; str:\n        \"\"\"Generate CSRF token.\"\"\"\n        import secrets\n\n        return secrets.token_urlsafe(32)\n</code></pre> <p>CSRF protection for forms.</p>"},{"location":"#luthien_control.admin.dependencies.CSRFProtection.generate_token","title":"<code>generate_token()</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/dependencies.py</code> <pre><code>async def generate_token(self) -&gt; str:\n    \"\"\"Generate CSRF token.\"\"\"\n    import secrets\n\n    return secrets.token_urlsafe(32)\n</code></pre> <p>Generate CSRF token.</p>"},{"location":"#luthien_control.admin.dependencies.get_current_admin","title":"<code>get_current_admin(session_token=None, db=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/dependencies.py</code> <pre><code>async def get_current_admin(\n    session_token: Annotated[Optional[str], Cookie()] = None,\n    db: AsyncSession = Depends(get_db_session),\n) -&gt; AdminUser:\n    \"\"\"Get current authenticated admin user from session cookie.\"\"\"\n    if not session_token:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Not authenticated\",\n        )\n\n    user = await admin_auth_service.get_user_from_session(db, session_token)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired session\",\n        )\n\n    return user\n</code></pre> <p>Get current authenticated admin user from session cookie.</p>"},{"location":"#luthien_control.admin.router","title":"<code>router</code>","text":"<p>Admin router for authentication and policy management.</p>"},{"location":"#luthien_control.admin.router.admin_home","title":"<code>admin_home(request, current_admin, db=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.get(\"/\", response_class=HTMLResponse)\nasync def admin_home(\n    request: Request,\n    current_admin: Annotated[AdminUser, Depends(get_current_admin)],\n    db: AsyncSession = Depends(get_db_session),\n) -&gt; HTMLResponse:\n    \"\"\"Admin dashboard hub.\"\"\"\n    # Get some basic stats for the dashboard\n    policies = await list_policies(db, active_only=False)\n    active_policies = [p for p in policies if p.is_active]\n\n    return templates.TemplateResponse(\n        request,\n        \"dashboard.html\",\n        {\n            \"current_admin\": current_admin,\n            \"total_policies\": len(policies),\n            \"active_policies\": len(active_policies),\n        },\n    )\n</code></pre> <p>Admin dashboard hub.</p>"},{"location":"#luthien_control.admin.router.create_policy_handler","title":"<code>create_policy_handler(request, name, type, config, current_admin, db=Depends(get_db_session), description=None, is_active=False, csrf_token='')</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.post(\"/policies/new\", response_model=None)\nasync def create_policy_handler(\n    request: Request,\n    name: Annotated[str, Form()],\n    type: Annotated[str, Form()],\n    config: Annotated[str, Form()],\n    current_admin: Annotated[AdminUser, Depends(get_current_admin)],\n    db: AsyncSession = Depends(get_db_session),\n    description: Annotated[Optional[str], Form()] = None,\n    is_active: Annotated[bool, Form()] = False,\n    csrf_token: Annotated[str, Form(alias=\"csrf_token\")] = \"\",\n):\n    \"\"\"Handle new policy creation.\"\"\"\n    # Validate CSRF token\n    cookie_csrf = request.cookies.get(\"csrf_token\")\n    if not cookie_csrf or cookie_csrf != csrf_token:\n        raise HTTPException(status_code=400, detail=\"Invalid request\")\n\n    # Parse and validate JSON config\n    try:\n        config_dict = json.loads(config)\n    except json.JSONDecodeError as e:\n        new_csrf = await csrf_protection.generate_token()\n        response = templates.TemplateResponse(\n            request,\n            \"policy_new.html\",\n            {\n                \"current_admin\": current_admin,\n                \"csrf_token\": new_csrf,\n                \"error\": f\"Invalid JSON: {str(e)}\",\n                \"form_data\": {\n                    \"name\": name,\n                    \"type\": type,\n                    \"config\": config,\n                    \"description\": description,\n                    \"is_active\": is_active,\n                },\n            },\n            status_code=400,\n        )\n        response.set_cookie(\n            key=\"csrf_token\",\n            value=new_csrf,\n            httponly=True,\n            secure=request.url.scheme == \"https\",\n            samesite=\"strict\",\n        )\n        return response  # type: ignore\n\n    # Create new policy\n    try:\n        policy = ControlPolicy(\n            name=name,\n            type=type,\n            config=config_dict,\n            description=description,\n            is_active=is_active,\n        )\n        await save_policy_to_db(db, policy)\n    except Exception as e:\n        new_csrf = await csrf_protection.generate_token()\n        response = templates.TemplateResponse(\n            request,\n            \"policy_new.html\",\n            {\n                \"current_admin\": current_admin,\n                \"csrf_token\": new_csrf,\n                \"error\": f\"Creation failed: {str(e)}\",\n                \"form_data\": {\n                    \"name\": name,\n                    \"type\": type,\n                    \"config\": config,\n                    \"description\": description,\n                    \"is_active\": is_active,\n                },\n            },\n            status_code=400,\n        )\n        response.set_cookie(\n            key=\"csrf_token\",\n            value=new_csrf,\n            httponly=True,\n            secure=request.url.scheme == \"https\",\n            samesite=\"strict\",\n        )\n        return response  # type: ignore\n\n    redirect = RedirectResponse(url=\"/admin/policies\", status_code=303)\n    redirect.delete_cookie(key=\"csrf_token\")\n    return redirect\n</code></pre> <p>Handle new policy creation.</p>"},{"location":"#luthien_control.admin.router.edit_policy_page","title":"<code>edit_policy_page(request, policy_name, current_admin, db=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.get(\"/policies/{policy_name}/edit\", response_class=HTMLResponse)\nasync def edit_policy_page(\n    request: Request,\n    policy_name: str,\n    current_admin: Annotated[AdminUser, Depends(get_current_admin)],\n    db: AsyncSession = Depends(get_db_session),\n) -&gt; HTMLResponse:\n    \"\"\"Display policy edit page.\"\"\"\n    policy = await get_policy_by_name(db, policy_name)\n    if not policy:\n        raise HTTPException(status_code=404, detail=\"Policy not found\")\n\n    csrf_token = await csrf_protection.generate_token()\n    response = templates.TemplateResponse(\n        request,\n        \"policy_edit.html\",\n        {\n            \"current_admin\": current_admin,\n            \"policy\": policy,\n            \"csrf_token\": csrf_token,\n            \"config_json\": json.dumps(policy.config, indent=2),\n            \"error\": None,\n        },\n    )\n    response.set_cookie(\n        key=\"csrf_token\",\n        value=csrf_token,\n        httponly=True,\n        secure=request.url.scheme == \"https\",\n        samesite=\"strict\",\n    )\n    return response\n</code></pre> <p>Display policy edit page.</p>"},{"location":"#luthien_control.admin.router.login","title":"<code>login(request, response, username, password, csrf_token, db=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.post(\"/login\", response_model=None)\nasync def login(\n    request: Request,\n    response: Response,\n    username: Annotated[str, Form()],\n    password: Annotated[str, Form()],\n    csrf_token: Annotated[str, Form(alias=\"csrf_token\")],\n    db: AsyncSession = Depends(get_db_session),\n):\n    \"\"\"Handle login form submission.\"\"\"\n    # Validate CSRF token\n    cookie_csrf = request.cookies.get(\"csrf_token\")\n    if not cookie_csrf or cookie_csrf != csrf_token:\n        return templates.TemplateResponse(\n            request,\n            \"login.html\",\n            {\n                \"csrf_token\": await csrf_protection.generate_token(),\n                \"error\": \"Invalid request. Please try again.\",\n            },\n            status_code=400,\n        )\n\n    # Authenticate user\n    user = await admin_auth_service.authenticate(db, username, password)\n    if not user:\n        new_csrf = await csrf_protection.generate_token()\n        response = templates.TemplateResponse(\n            request,\n            \"login.html\",\n            {\n                \"csrf_token\": new_csrf,\n                \"error\": \"Invalid username or password\",\n            },\n            status_code=401,\n        )\n        response.set_cookie(\n            key=\"csrf_token\",\n            value=new_csrf,\n            httponly=True,\n            secure=request.url.scheme == \"https\",\n            samesite=\"strict\",\n        )\n        return response  # type: ignore\n\n    # Create session\n    session = await admin_auth_service.create_session(db, user)\n\n    redirect = RedirectResponse(url=\"/admin/policies\", status_code=303)\n    redirect.set_cookie(\n        key=\"session_token\",\n        value=session.session_token,\n        httponly=True,\n        secure=request.url.scheme == \"https\",\n        samesite=\"strict\",\n        max_age=86400,  # 24 hours\n    )\n    redirect.delete_cookie(key=\"csrf_token\")\n\n    return redirect\n</code></pre> <p>Handle login form submission.</p>"},{"location":"#luthien_control.admin.router.login_page","title":"<code>login_page(request)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.get(\"/login\", response_class=HTMLResponse)\nasync def login_page(request: Request) -&gt; HTMLResponse:\n    \"\"\"Display login page.\"\"\"\n    csrf_token = await csrf_protection.generate_token()\n    response = templates.TemplateResponse(\n        request,\n        \"login.html\",\n        {\n            \"csrf_token\": csrf_token,\n            \"error\": None,\n        },\n    )\n    response.set_cookie(\n        key=\"csrf_token\",\n        value=csrf_token,\n        httponly=True,\n        secure=request.url.scheme == \"https\",\n        samesite=\"strict\",\n    )\n    return response\n</code></pre> <p>Display login page.</p>"},{"location":"#luthien_control.admin.router.logout","title":"<code>logout(request, db=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.get(\"/logout\")\nasync def logout(\n    request: Request,\n    db: AsyncSession = Depends(get_db_session),\n):\n    \"\"\"Logout and redirect to login page.\"\"\"\n    session_token = request.cookies.get(\"session_token\")\n    if session_token:\n        await admin_auth_service.logout(db, session_token)\n\n    redirect = RedirectResponse(url=\"/admin/login\", status_code=303)\n    redirect.delete_cookie(key=\"session_token\")\n    return redirect\n</code></pre> <p>Logout and redirect to login page.</p>"},{"location":"#luthien_control.admin.router.new_policy_page","title":"<code>new_policy_page(request, current_admin)</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.get(\"/policies/new\", response_class=HTMLResponse)\nasync def new_policy_page(\n    request: Request,\n    current_admin: Annotated[AdminUser, Depends(get_current_admin)],\n) -&gt; HTMLResponse:\n    \"\"\"Display new policy creation page.\"\"\"\n    csrf_token = await csrf_protection.generate_token()\n    response = templates.TemplateResponse(\n        request,\n        \"policy_new.html\",\n        {\n            \"current_admin\": current_admin,\n            \"csrf_token\": csrf_token,\n            \"error\": None,\n        },\n    )\n    response.set_cookie(\n        key=\"csrf_token\",\n        value=csrf_token,\n        httponly=True,\n        secure=request.url.scheme == \"https\",\n        samesite=\"strict\",\n    )\n    return response\n</code></pre> <p>Display new policy creation page.</p>"},{"location":"#luthien_control.admin.router.policies_list","title":"<code>policies_list(request, current_admin, db=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.get(\"/policies\", response_class=HTMLResponse)\nasync def policies_list(\n    request: Request,\n    current_admin: Annotated[AdminUser, Depends(get_current_admin)],\n    db: AsyncSession = Depends(get_db_session),\n) -&gt; HTMLResponse:\n    \"\"\"List all control policies.\"\"\"\n    policies = await list_policies(db, active_only=False)\n\n    return templates.TemplateResponse(\n        request,\n        \"policies.html\",\n        {\n            \"current_admin\": current_admin,\n            \"policies\": policies,\n        },\n    )\n</code></pre> <p>List all control policies.</p>"},{"location":"#luthien_control.admin.router.update_policy_handler","title":"<code>update_policy_handler(request, policy_name, config, current_admin, db=Depends(get_db_session), description=None, is_active=False, csrf_token='')</code>  <code>async</code>","text":"Source code in <code>luthien_control/admin/router.py</code> <pre><code>@router.post(\"/policies/{policy_name}/edit\", response_model=None)\nasync def update_policy_handler(\n    request: Request,\n    policy_name: str,\n    config: Annotated[str, Form()],\n    current_admin: Annotated[AdminUser, Depends(get_current_admin)],\n    db: AsyncSession = Depends(get_db_session),\n    description: Annotated[Optional[str], Form()] = None,\n    is_active: Annotated[bool, Form()] = False,\n    csrf_token: Annotated[str, Form(alias=\"csrf_token\")] = \"\",\n):\n    \"\"\"Handle policy update form submission.\"\"\"\n    # Validate CSRF token\n    cookie_csrf = request.cookies.get(\"csrf_token\")\n    if not cookie_csrf or cookie_csrf != csrf_token:\n        raise HTTPException(status_code=400, detail=\"Invalid request\")\n\n    # Get the policy first\n    policy = await get_policy_by_name(db, policy_name)\n    if not policy:\n        raise HTTPException(status_code=404, detail=\"Policy not found\")\n\n    # Parse and validate JSON config\n    try:\n        config_dict = json.loads(config)\n    except json.JSONDecodeError as e:\n        new_csrf = await csrf_protection.generate_token()\n        response = templates.TemplateResponse(\n            request,\n            \"policy_edit.html\",\n            {\n                \"current_admin\": current_admin,\n                \"policy\": policy,\n                \"csrf_token\": new_csrf,\n                \"config_json\": config,\n                \"error\": f\"Invalid JSON: {str(e)}\",\n            },\n            status_code=400,\n        )\n        response.set_cookie(\n            key=\"csrf_token\",\n            value=new_csrf,\n            httponly=True,\n            secure=request.url.scheme == \"https\",\n            samesite=\"strict\",\n        )\n        return response  # type: ignore\n\n    # Update policy\n    try:\n        policy.config = config_dict\n        if description is not None:\n            policy.description = description\n        policy.is_active = is_active\n\n        db.add(policy)\n        await db.commit()\n        await db.refresh(policy)\n    except Exception as e:\n        new_csrf = await csrf_protection.generate_token()\n        response = templates.TemplateResponse(\n            request,\n            \"policy_edit.html\",\n            {\n                \"current_admin\": current_admin,\n                \"policy\": policy,\n                \"csrf_token\": new_csrf,\n                \"config_json\": config,\n                \"error\": f\"Update failed: {str(e)}\",\n            },\n            status_code=400,\n        )\n        response.set_cookie(\n            key=\"csrf_token\",\n            value=new_csrf,\n            httponly=True,\n            secure=request.url.scheme == \"https\",\n            samesite=\"strict\",\n        )\n        return response  # type: ignore\n\n    redirect = RedirectResponse(url=\"/admin/policies\", status_code=303)\n    redirect.delete_cookie(key=\"csrf_token\")\n    return redirect\n</code></pre> <p>Handle policy update form submission.</p>"},{"location":"#luthien_control.api","title":"<code>api</code>","text":""},{"location":"#luthien_control.api.openai_chat_completions","title":"<code>openai_chat_completions</code>","text":""},{"location":"#luthien_control.api.openai_chat_completions.Choice","title":"<code>Choice</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class Choice(DeepEventedModel):\n    \"\"\"A single choice in a chat completion response.\"\"\"\n\n    index: int = Field(default=0)\n    message: Message = Field(default_factory=Message)\n    finish_reason: Optional[str] = Field(default=None)\n    logprobs: Optional[LogProbs] = Field(default=None)\n</code></pre> <p>A single choice in a chat completion response.</p>"},{"location":"#luthien_control.api.openai_chat_completions.CompletionTokensDetails","title":"<code>CompletionTokensDetails</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class CompletionTokensDetails(DeepEventedModel):\n    \"\"\"Details about completion token usage.\"\"\"\n\n    reasoning_tokens: int = Field(default=0)\n    audio_tokens: int = Field(default=0)\n    accepted_prediction_tokens: int = Field(default=0)\n    rejected_prediction_tokens: int = Field(default=0)\n</code></pre> <p>Details about completion token usage.</p>"},{"location":"#luthien_control.api.openai_chat_completions.ContentPartImage","title":"<code>ContentPartImage</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ContentPartImage(DeepEventedModel):\n    \"\"\"An image content part.\"\"\"\n\n    type: str = Field(default=\"image_url\", frozen=True)\n    image_url: ImageUrl = Field()\n</code></pre> <p>An image content part.</p>"},{"location":"#luthien_control.api.openai_chat_completions.ContentPartText","title":"<code>ContentPartText</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ContentPartText(DeepEventedModel):\n    \"\"\"A text content part.\"\"\"\n\n    type: str = Field(default=\"text\", frozen=True)\n    text: str = Field()\n</code></pre> <p>A text content part.</p>"},{"location":"#luthien_control.api.openai_chat_completions.FunctionDefinition","title":"<code>FunctionDefinition</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class FunctionDefinition(DeepEventedModel):\n    \"\"\"The definition of a function that can be called by the model.\"\"\"\n\n    name: str = Field()\n    description: Optional[str] = Field(default=None)\n    parameters: Optional[EDict[str, Any]] = Field(default_factory=EDict)\n</code></pre> <p>The definition of a function that can be called by the model.</p>"},{"location":"#luthien_control.api.openai_chat_completions.ImageUrl","title":"<code>ImageUrl</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ImageUrl(DeepEventedModel):\n    \"\"\"The image URL details.\"\"\"\n\n    url: str\n    detail: Literal[\"auto\", \"low\", \"high\"] = \"auto\"\n</code></pre> <p>The image URL details.</p>"},{"location":"#luthien_control.api.openai_chat_completions.LogProbs","title":"<code>LogProbs</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class LogProbs(DeepEventedModel):\n    \"\"\"Log probability information for the choice.\"\"\"\n\n    content: Optional[EList[EDict]] = Field(default_factory=lambda: EList[EDict]())\n    refusal: Optional[EList[EDict]] = Field(default_factory=lambda: EList[EDict]())\n</code></pre> <p>Log probability information for the choice.</p>"},{"location":"#luthien_control.api.openai_chat_completions.Message","title":"<code>Message</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class Message(DeepEventedModel):\n    \"\"\"A message in a chat completion.\"\"\"\n\n    content: Optional[str] = Field(default=None)\n    refusal: Optional[str] = Field(default=None)\n    role: str = Field(default_factory=str)\n    annotations: EList[Annotation] = Field(default_factory=lambda: EList[Annotation]())\n    audio: Optional[Audio] = Field(default=None)\n    function_call: Optional[FunctionCall] = Field(default=None)\n    tool_calls: Optional[EList[ToolCall]] = Field(default_factory=lambda: EList[ToolCall]())\n</code></pre> <p>A message in a chat completion.</p>"},{"location":"#luthien_control.api.openai_chat_completions.OpenAIChatCompletionsRequest","title":"<code>OpenAIChatCompletionsRequest</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/request.py</code> <pre><code>class OpenAIChatCompletionsRequest(DeepEventedModel):\n    \"\"\"Request context for OpenAI chat completions.\n\n    Based on the OpenAI API reference:\n    https://platform.openai.com/docs/api-reference/chat/create?lang=python\n    (retrieved 2025-06-16)\n\n    This model is evented and will emit a `changed` signal on any modification.\n    \"\"\"\n\n    messages: EList[Message] = Field()\n    model: str = Field()\n    audio: Optional[Audio] = Field(default=None)\n    frequency_penalty: Optional[float] = Field(default=None)\n    function_call: Optional[RequestFunctionCallSpec] = Field(default=None)  # deprecated\n    functions: Optional[EList[FunctionDefinition]] = Field(default=None)  # deprecated\n    logit_bias: Optional[EDict[str, float]] = Field(default=None)\n    logprobs: Optional[bool] = Field(default=None)\n    max_completion_tokens: Optional[int] = Field(default=None)\n    max_tokens: Optional[int] = Field(default=None)  # deprecated\n    metadata: Optional[EDict[str, str]] = Field(default=None)\n    modalities: Optional[EList[str]] = Field(default=None)\n    n: Optional[int] = Field(default=None)\n    parallel_tool_calls: Optional[bool] = Field(default=None)\n    prediction: Optional[Prediction] = Field(default=None)\n    presence_penalty: Optional[float] = Field(default=None)\n    reasoning_effort: Optional[str] = Field(default=None)  # \"low\", \"medium\", \"high\"\n    response_format: Optional[ResponseFormat] = Field(default=None)\n    seed: Optional[int] = Field(default=None)\n    service_tier: Optional[str] = Field(default=None)\n    stop: Optional[str | EList[str]] = Field(default=None)\n    store: Optional[bool] = Field(default=None)\n    stream: Optional[bool] = Field(default=None)\n    stream_options: Optional[StreamOptions] = Field(default=None)\n    temperature: Optional[float] = Field(default=None)\n    tool_choice: Optional[ToolChoice] = Field(default=None)\n    tools: Optional[EList[ToolDefinition]] = Field(default=None)\n    top_logprobs: Optional[int] = Field(default=None)\n    top_p: Optional[float] = Field(default=None)\n    user: Optional[str] = Field(default=None)\n    web_search_options: Optional[WebSearchOptions] = Field(default=None)\n</code></pre> <p>Request context for OpenAI chat completions.</p> <p>Based on the OpenAI API reference: https://platform.openai.com/docs/api-reference/chat/create?lang=python (retrieved 2025-06-16)</p> <p>This model is evented and will emit a <code>changed</code> signal on any modification.</p>"},{"location":"#luthien_control.api.openai_chat_completions.OpenAIChatCompletionsResponse","title":"<code>OpenAIChatCompletionsResponse</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/response.py</code> <pre><code>class OpenAIChatCompletionsResponse(DeepEventedModel):\n    \"\"\"The request for a chat completion.\"\"\"\n\n    choices: EList[Choice] = Field(default_factory=lambda: EList[Choice]())\n    created: int = Field()\n    id: str = Field()\n    model: str = Field()\n    object: str = Field(default=\"chat.completion\")\n    service_tier: Optional[str] = Field(default=None)\n    system_fingerprint: Optional[str] = Field(default=None)\n    usage: Usage = Field(default_factory=Usage)\n</code></pre> <p>The request for a chat completion.</p>"},{"location":"#luthien_control.api.openai_chat_completions.PromptTokensDetails","title":"<code>PromptTokensDetails</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class PromptTokensDetails(DeepEventedModel):\n    \"\"\"Details about prompt token usage.\"\"\"\n\n    cached_tokens: int = Field(default=0)\n    audio_tokens: int = Field(default=0)\n</code></pre> <p>Details about prompt token usage.</p>"},{"location":"#luthien_control.api.openai_chat_completions.ResponseFormat","title":"<code>ResponseFormat</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ResponseFormat(DeepEventedModel):\n    \"\"\"An object specifying the format that the model must output.\n\n    See https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses\n    \"\"\"\n\n    type: Literal[\"text\", \"json_object\", \"json_schema\"] = Field(default=\"text\")\n    json_schema: Optional[EDict[str, Type]] = Field(default=None)\n</code></pre> <p>An object specifying the format that the model must output.</p> <p>See https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses</p>"},{"location":"#luthien_control.api.openai_chat_completions.ToolChoice","title":"<code>ToolChoice</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ToolChoice(DeepEventedModel):\n    \"\"\"A specific tool choice.\"\"\"\n\n    type: str = Field(default=\"function\", frozen=True)\n    function: ToolChoiceFunction = Field()\n</code></pre> <p>A specific tool choice.</p>"},{"location":"#luthien_control.api.openai_chat_completions.ToolChoiceFunction","title":"<code>ToolChoiceFunction</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ToolChoiceFunction(DeepEventedModel):\n    \"\"\"The function to call in a tool choice.\"\"\"\n\n    name: str = Field()\n</code></pre> <p>The function to call in a tool choice.</p>"},{"location":"#luthien_control.api.openai_chat_completions.ToolDefinition","title":"<code>ToolDefinition</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ToolDefinition(DeepEventedModel):\n    \"\"\"A tool that can be used by the model.\"\"\"\n\n    type: str = Field(default=\"function\", frozen=True)\n    function: FunctionDefinition = Field()\n</code></pre> <p>A tool that can be used by the model.</p>"},{"location":"#luthien_control.api.openai_chat_completions.Usage","title":"<code>Usage</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class Usage(DeepEventedModel):\n    \"\"\"Token usage statistics for the chat completion request.\"\"\"\n\n    prompt_tokens: int = Field(default=0)\n    completion_tokens: int = Field(default=0)\n    total_tokens: int = Field(default=0)\n    prompt_tokens_details: Optional[PromptTokensDetails] = Field(default_factory=PromptTokensDetails)\n    completion_tokens_details: Optional[CompletionTokensDetails] = Field(default_factory=CompletionTokensDetails)\n</code></pre> <p>Token usage statistics for the chat completion request.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes","title":"<code>datatypes</code>","text":""},{"location":"#luthien_control.api.openai_chat_completions.datatypes.Choice","title":"<code>Choice</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class Choice(DeepEventedModel):\n    \"\"\"A single choice in a chat completion response.\"\"\"\n\n    index: int = Field(default=0)\n    message: Message = Field(default_factory=Message)\n    finish_reason: Optional[str] = Field(default=None)\n    logprobs: Optional[LogProbs] = Field(default=None)\n</code></pre> <p>A single choice in a chat completion response.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.CompletionTokensDetails","title":"<code>CompletionTokensDetails</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class CompletionTokensDetails(DeepEventedModel):\n    \"\"\"Details about completion token usage.\"\"\"\n\n    reasoning_tokens: int = Field(default=0)\n    audio_tokens: int = Field(default=0)\n    accepted_prediction_tokens: int = Field(default=0)\n    rejected_prediction_tokens: int = Field(default=0)\n</code></pre> <p>Details about completion token usage.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ContentPartImage","title":"<code>ContentPartImage</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ContentPartImage(DeepEventedModel):\n    \"\"\"An image content part.\"\"\"\n\n    type: str = Field(default=\"image_url\", frozen=True)\n    image_url: ImageUrl = Field()\n</code></pre> <p>An image content part.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ContentPartText","title":"<code>ContentPartText</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ContentPartText(DeepEventedModel):\n    \"\"\"A text content part.\"\"\"\n\n    type: str = Field(default=\"text\", frozen=True)\n    text: str = Field()\n</code></pre> <p>A text content part.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.FunctionDefinition","title":"<code>FunctionDefinition</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class FunctionDefinition(DeepEventedModel):\n    \"\"\"The definition of a function that can be called by the model.\"\"\"\n\n    name: str = Field()\n    description: Optional[str] = Field(default=None)\n    parameters: Optional[EDict[str, Any]] = Field(default_factory=EDict)\n</code></pre> <p>The definition of a function that can be called by the model.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ImageUrl","title":"<code>ImageUrl</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ImageUrl(DeepEventedModel):\n    \"\"\"The image URL details.\"\"\"\n\n    url: str\n    detail: Literal[\"auto\", \"low\", \"high\"] = \"auto\"\n</code></pre> <p>The image URL details.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.LogProbs","title":"<code>LogProbs</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class LogProbs(DeepEventedModel):\n    \"\"\"Log probability information for the choice.\"\"\"\n\n    content: Optional[EList[EDict]] = Field(default_factory=lambda: EList[EDict]())\n    refusal: Optional[EList[EDict]] = Field(default_factory=lambda: EList[EDict]())\n</code></pre> <p>Log probability information for the choice.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.Message","title":"<code>Message</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class Message(DeepEventedModel):\n    \"\"\"A message in a chat completion.\"\"\"\n\n    content: Optional[str] = Field(default=None)\n    refusal: Optional[str] = Field(default=None)\n    role: str = Field(default_factory=str)\n    annotations: EList[Annotation] = Field(default_factory=lambda: EList[Annotation]())\n    audio: Optional[Audio] = Field(default=None)\n    function_call: Optional[FunctionCall] = Field(default=None)\n    tool_calls: Optional[EList[ToolCall]] = Field(default_factory=lambda: EList[ToolCall]())\n</code></pre> <p>A message in a chat completion.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.PromptTokensDetails","title":"<code>PromptTokensDetails</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class PromptTokensDetails(DeepEventedModel):\n    \"\"\"Details about prompt token usage.\"\"\"\n\n    cached_tokens: int = Field(default=0)\n    audio_tokens: int = Field(default=0)\n</code></pre> <p>Details about prompt token usage.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.RequestFunctionCall","title":"<code>RequestFunctionCall</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class RequestFunctionCall(DeepEventedModel):\n    \"\"\"A function call in a request.\"\"\"\n\n    name: str = Field()\n</code></pre> <p>A function call in a request.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ResponseFormat","title":"<code>ResponseFormat</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ResponseFormat(DeepEventedModel):\n    \"\"\"An object specifying the format that the model must output.\n\n    See https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses\n    \"\"\"\n\n    type: Literal[\"text\", \"json_object\", \"json_schema\"] = Field(default=\"text\")\n    json_schema: Optional[EDict[str, Type]] = Field(default=None)\n</code></pre> <p>An object specifying the format that the model must output.</p> <p>See https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ToolChoice","title":"<code>ToolChoice</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ToolChoice(DeepEventedModel):\n    \"\"\"A specific tool choice.\"\"\"\n\n    type: str = Field(default=\"function\", frozen=True)\n    function: ToolChoiceFunction = Field()\n</code></pre> <p>A specific tool choice.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ToolChoiceFunction","title":"<code>ToolChoiceFunction</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ToolChoiceFunction(DeepEventedModel):\n    \"\"\"The function to call in a tool choice.\"\"\"\n\n    name: str = Field()\n</code></pre> <p>The function to call in a tool choice.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.ToolDefinition","title":"<code>ToolDefinition</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class ToolDefinition(DeepEventedModel):\n    \"\"\"A tool that can be used by the model.\"\"\"\n\n    type: str = Field(default=\"function\", frozen=True)\n    function: FunctionDefinition = Field()\n</code></pre> <p>A tool that can be used by the model.</p>"},{"location":"#luthien_control.api.openai_chat_completions.datatypes.Usage","title":"<code>Usage</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/datatypes.py</code> <pre><code>class Usage(DeepEventedModel):\n    \"\"\"Token usage statistics for the chat completion request.\"\"\"\n\n    prompt_tokens: int = Field(default=0)\n    completion_tokens: int = Field(default=0)\n    total_tokens: int = Field(default=0)\n    prompt_tokens_details: Optional[PromptTokensDetails] = Field(default_factory=PromptTokensDetails)\n    completion_tokens_details: Optional[CompletionTokensDetails] = Field(default_factory=CompletionTokensDetails)\n</code></pre> <p>Token usage statistics for the chat completion request.</p>"},{"location":"#luthien_control.api.openai_chat_completions.request","title":"<code>request</code>","text":""},{"location":"#luthien_control.api.openai_chat_completions.request.OpenAIChatCompletionsRequest","title":"<code>OpenAIChatCompletionsRequest</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/request.py</code> <pre><code>class OpenAIChatCompletionsRequest(DeepEventedModel):\n    \"\"\"Request context for OpenAI chat completions.\n\n    Based on the OpenAI API reference:\n    https://platform.openai.com/docs/api-reference/chat/create?lang=python\n    (retrieved 2025-06-16)\n\n    This model is evented and will emit a `changed` signal on any modification.\n    \"\"\"\n\n    messages: EList[Message] = Field()\n    model: str = Field()\n    audio: Optional[Audio] = Field(default=None)\n    frequency_penalty: Optional[float] = Field(default=None)\n    function_call: Optional[RequestFunctionCallSpec] = Field(default=None)  # deprecated\n    functions: Optional[EList[FunctionDefinition]] = Field(default=None)  # deprecated\n    logit_bias: Optional[EDict[str, float]] = Field(default=None)\n    logprobs: Optional[bool] = Field(default=None)\n    max_completion_tokens: Optional[int] = Field(default=None)\n    max_tokens: Optional[int] = Field(default=None)  # deprecated\n    metadata: Optional[EDict[str, str]] = Field(default=None)\n    modalities: Optional[EList[str]] = Field(default=None)\n    n: Optional[int] = Field(default=None)\n    parallel_tool_calls: Optional[bool] = Field(default=None)\n    prediction: Optional[Prediction] = Field(default=None)\n    presence_penalty: Optional[float] = Field(default=None)\n    reasoning_effort: Optional[str] = Field(default=None)  # \"low\", \"medium\", \"high\"\n    response_format: Optional[ResponseFormat] = Field(default=None)\n    seed: Optional[int] = Field(default=None)\n    service_tier: Optional[str] = Field(default=None)\n    stop: Optional[str | EList[str]] = Field(default=None)\n    store: Optional[bool] = Field(default=None)\n    stream: Optional[bool] = Field(default=None)\n    stream_options: Optional[StreamOptions] = Field(default=None)\n    temperature: Optional[float] = Field(default=None)\n    tool_choice: Optional[ToolChoice] = Field(default=None)\n    tools: Optional[EList[ToolDefinition]] = Field(default=None)\n    top_logprobs: Optional[int] = Field(default=None)\n    top_p: Optional[float] = Field(default=None)\n    user: Optional[str] = Field(default=None)\n    web_search_options: Optional[WebSearchOptions] = Field(default=None)\n</code></pre> <p>Request context for OpenAI chat completions.</p> <p>Based on the OpenAI API reference: https://platform.openai.com/docs/api-reference/chat/create?lang=python (retrieved 2025-06-16)</p> <p>This model is evented and will emit a <code>changed</code> signal on any modification.</p>"},{"location":"#luthien_control.api.openai_chat_completions.response","title":"<code>response</code>","text":""},{"location":"#luthien_control.api.openai_chat_completions.response.OpenAIChatCompletionsResponse","title":"<code>OpenAIChatCompletionsResponse</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/api/openai_chat_completions/response.py</code> <pre><code>class OpenAIChatCompletionsResponse(DeepEventedModel):\n    \"\"\"The request for a chat completion.\"\"\"\n\n    choices: EList[Choice] = Field(default_factory=lambda: EList[Choice]())\n    created: int = Field()\n    id: str = Field()\n    model: str = Field()\n    object: str = Field(default=\"chat.completion\")\n    service_tier: Optional[str] = Field(default=None)\n    system_fingerprint: Optional[str] = Field(default=None)\n    usage: Usage = Field(default_factory=Usage)\n</code></pre> <p>The request for a chat completion.</p>"},{"location":"#luthien_control.control_policy","title":"<code>control_policy</code>","text":""},{"location":"#luthien_control.control_policy.add_api_key_header","title":"<code>add_api_key_header</code>","text":""},{"location":"#luthien_control.control_policy.add_api_key_header.AddApiKeyHeaderPolicy","title":"<code>AddApiKeyHeaderPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/add_api_key_header.py</code> <pre><code>class AddApiKeyHeaderPolicy(ControlPolicy):\n    \"\"\"Adds the configured OpenAI API key to the request Authorization header.\n\n    This policy reads the API key from the application settings and adds it\n    to the request. It has no policy-specific configuration beyond its name.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"AddApiKeyHeaderPolicy\")\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Sets the API key on the transaction's request.\n\n        Reads OpenAI API key from settings via the container.\n        Requires the DependencyContainer and AsyncSession in signature for interface compliance,\n        but session is not directly used in this policy's logic.\n\n        Raises:\n            NoRequestError if the request is not found in the transaction.\n            ApiKeyNotFoundError if the OpenAI API key is not configured.\n\n        Args:\n            transaction: The current transaction.\n            container: The application dependency container.\n            session: An active SQLAlchemy AsyncSession (unused).\n\n        Returns:\n            The potentially modified transaction.\n        \"\"\"\n        if transaction.request is None:\n            raise NoRequestError(\"No request in transaction.\")\n        api_key = container.settings.get_openai_api_key()\n        if not api_key:\n            raise ApiKeyNotFoundError(f\"OpenAI API key not configured ({self.name}).\")\n        self.logger.info(f\"Setting API key from settings ({self.name}).\")\n        transaction.request.api_key = api_key\n\n        return transaction\n</code></pre> <p>Adds the configured OpenAI API key to the request Authorization header.</p> <p>This policy reads the API key from the application settings and adds it to the request. It has no policy-specific configuration beyond its name.</p>"},{"location":"#luthien_control.control_policy.add_api_key_header.AddApiKeyHeaderPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/add_api_key_header.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Sets the API key on the transaction's request.\n\n    Reads OpenAI API key from settings via the container.\n    Requires the DependencyContainer and AsyncSession in signature for interface compliance,\n    but session is not directly used in this policy's logic.\n\n    Raises:\n        NoRequestError if the request is not found in the transaction.\n        ApiKeyNotFoundError if the OpenAI API key is not configured.\n\n    Args:\n        transaction: The current transaction.\n        container: The application dependency container.\n        session: An active SQLAlchemy AsyncSession (unused).\n\n    Returns:\n        The potentially modified transaction.\n    \"\"\"\n    if transaction.request is None:\n        raise NoRequestError(\"No request in transaction.\")\n    api_key = container.settings.get_openai_api_key()\n    if not api_key:\n        raise ApiKeyNotFoundError(f\"OpenAI API key not configured ({self.name}).\")\n    self.logger.info(f\"Setting API key from settings ({self.name}).\")\n    transaction.request.api_key = api_key\n\n    return transaction\n</code></pre> <p>Sets the API key on the transaction's request.</p> <p>Reads OpenAI API key from settings via the container. Requires the DependencyContainer and AsyncSession in signature for interface compliance, but session is not directly used in this policy's logic.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession (unused).</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The potentially modified transaction.</p>"},{"location":"#luthien_control.control_policy.add_api_key_header_from_env","title":"<code>add_api_key_header_from_env</code>","text":"<p>Add an API key header, where the key is sourced from a configured environment variable.</p> <p>This policy is used to add an API key to the request Authorization header. The API key is read from an environment variable whose name is configured when the policy is instantiated.</p>"},{"location":"#luthien_control.control_policy.add_api_key_header_from_env.AddApiKeyHeaderFromEnvPolicy","title":"<code>AddApiKeyHeaderFromEnvPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/add_api_key_header_from_env.py</code> <pre><code>class AddApiKeyHeaderFromEnvPolicy(ControlPolicy):\n    \"\"\"Adds an API key to the request Authorization header from an environment variable.\n\n    The API key is read from an environment variable whose name is configured\n    when the policy is instantiated. This allows different API keys to be used\n    based on deployment environment.\n    \"\"\"\n\n    api_key_env_var_name: str = Field(...)\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Sets the API key on the transaction's request.\n\n        The API key is read from the environment variable specified by self.api_key_env_var_name.\n        Requires DependencyContainer and AsyncSession for interface compliance, but they are not\n        directly used in this policy's primary logic beyond what ControlPolicy might require.\n\n        Raises:\n            NoRequestError if the request is not found in the transaction.\n            ApiKeyNotFoundError if the configured environment variable is not set or is empty.\n\n        Args:\n            transaction: The current transaction.\n            container: The application dependency container (unused).\n            session: An active SQLAlchemy AsyncSession (unused).\n\n        Returns:\n            The potentially modified transaction.\n        \"\"\"\n        if transaction.request is None:\n            raise NoRequestError(\"No request in transaction.\")\n\n        api_key = os.environ.get(self.api_key_env_var_name)\n\n        if not api_key:\n            error_message = (\n                f\"API key not found. Environment variable '{self.api_key_env_var_name}' is not set or is empty.\"\n            )\n            self.logger.error(f\"{error_message} ({self.name})\")\n            raise ApiKeyNotFoundError(f\"{error_message} ({self.name})\")\n\n        self.logger.info(f\"Setting API key from env var '{self.api_key_env_var_name}' ({self.name}).\")\n        transaction.request.api_key = api_key\n\n        return transaction\n</code></pre> <p>Adds an API key to the request Authorization header from an environment variable.</p> <p>The API key is read from an environment variable whose name is configured when the policy is instantiated. This allows different API keys to be used based on deployment environment.</p>"},{"location":"#luthien_control.control_policy.add_api_key_header_from_env.AddApiKeyHeaderFromEnvPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/add_api_key_header_from_env.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Sets the API key on the transaction's request.\n\n    The API key is read from the environment variable specified by self.api_key_env_var_name.\n    Requires DependencyContainer and AsyncSession for interface compliance, but they are not\n    directly used in this policy's primary logic beyond what ControlPolicy might require.\n\n    Raises:\n        NoRequestError if the request is not found in the transaction.\n        ApiKeyNotFoundError if the configured environment variable is not set or is empty.\n\n    Args:\n        transaction: The current transaction.\n        container: The application dependency container (unused).\n        session: An active SQLAlchemy AsyncSession (unused).\n\n    Returns:\n        The potentially modified transaction.\n    \"\"\"\n    if transaction.request is None:\n        raise NoRequestError(\"No request in transaction.\")\n\n    api_key = os.environ.get(self.api_key_env_var_name)\n\n    if not api_key:\n        error_message = (\n            f\"API key not found. Environment variable '{self.api_key_env_var_name}' is not set or is empty.\"\n        )\n        self.logger.error(f\"{error_message} ({self.name})\")\n        raise ApiKeyNotFoundError(f\"{error_message} ({self.name})\")\n\n    self.logger.info(f\"Setting API key from env var '{self.api_key_env_var_name}' ({self.name}).\")\n    transaction.request.api_key = api_key\n\n    return transaction\n</code></pre> <p>Sets the API key on the transaction's request.</p> <p>The API key is read from the environment variable specified by self.api_key_env_var_name. Requires DependencyContainer and AsyncSession for interface compliance, but they are not directly used in this policy's primary logic beyond what ControlPolicy might require.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container (unused).</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession (unused).</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The potentially modified transaction.</p>"},{"location":"#luthien_control.control_policy.backend_call_policy","title":"<code>backend_call_policy</code>","text":""},{"location":"#luthien_control.control_policy.backend_call_policy.BackendCallPolicy","title":"<code>BackendCallPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/backend_call_policy.py</code> <pre><code>class BackendCallPolicy(ControlPolicy):\n    \"\"\"\n    This policy makes a backend LLM call.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"BackendCallPolicy\")\n    backend_call_spec: BackendCallSpec = Field(...)\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        api_key = os.environ.get(self.backend_call_spec.api_key_env_var)\n        if api_key:\n            transaction.request.api_key = api_key\n        transaction.request.api_endpoint = self.backend_call_spec.api_endpoint\n\n        # Update the request payload with all arguments from backend_call_spec.request_args\n        # Use model_validate to properly handle nested pydantic models and EventedList/EventedDict\n        if self.backend_call_spec.request_args:\n            current_data = transaction.request.payload.model_dump()\n            current_data.update(self.backend_call_spec.request_args)\n            transaction.request.payload = transaction.request.payload.__class__.model_validate(current_data)\n\n        # Set the model if specified\n        if self.backend_call_spec.model:\n            transaction.request.payload.model = self.backend_call_spec.model\n\n        openai_client = container.create_openai_client(\n            transaction.request.api_endpoint, api_key or transaction.request.api_key\n        )\n        try:\n            response_payload = await openai_client.chat.completions.create(**transaction.request.payload.model_dump())\n            transaction.response.payload = response_payload\n            transaction.response.api_endpoint = transaction.request.api_endpoint\n        except openai.APITimeoutError as e:\n            self.logger.error(f\"Timeout error during backend request: {e} ({self.name})\")\n            raise\n        except openai.APIConnectionError as e:\n            self.logger.error(f\"Connection error during backend request: {e} ({self.name})\")\n            raise\n        except openai.APIError as e:\n            self.logger.error(f\"OpenAI API error during backend request: {e} ({self.name})\")\n            raise\n        except Exception as e:\n            self.logger.exception(f\"Unexpected error during backend request: {e} ({self.name})\")\n            raise\n        return transaction\n</code></pre> <p>This policy makes a backend LLM call.</p>"},{"location":"#luthien_control.control_policy.branching_policy","title":"<code>branching_policy</code>","text":""},{"location":"#luthien_control.control_policy.branching_policy.BranchingPolicy","title":"<code>BranchingPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/branching_policy.py</code> <pre><code>class BranchingPolicy(ControlPolicy):\n    \"\"\"\n    A Control Policy that conditionally applies different policies based on transaction evaluation.\n\n    This policy evaluates conditions in order and applies the policy associated with the first\n    matching condition. If no conditions match, it applies the default policy (if configured).\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"BranchingPolicy\")\n    cond_to_policy_map: OrderedDict[Condition, ControlPolicy] = Field(default_factory=OrderedDict, exclude=True)\n    default_policy: Optional[ControlPolicy] = Field(default=None)\n\n    @field_validator(\"cond_to_policy_map\", mode=\"before\")\n    @classmethod\n    def validate_cond_to_policy_map(cls, value):\n        \"\"\"Validate and convert condition-to-policy mapping.\"\"\"\n        if isinstance(value, OrderedDict):\n            return value\n        if isinstance(value, dict):\n            return OrderedDict(value)\n        raise ValueError(\"cond_to_policy_map must be a dict or OrderedDict\")\n\n    @field_validator(\"default_policy\", mode=\"before\")\n    @classmethod\n    def validate_default_policy(cls, value):\n        \"\"\"Validate default policy field.\"\"\"\n        return value\n\n    async def apply(\n        self, transaction: Transaction, container: DependencyContainer, session: AsyncSession\n    ) -&gt; Transaction:\n        \"\"\"\n        Apply the first policy that matches the condition. If no condition matches, apply the default policy (if set).\n\n        Args:\n            transaction: The transaction to apply the policy to.\n            container: The dependency container.\n            session: The database session.\n\n        Returns:\n            The potentially modified transaction.\n        \"\"\"\n        for cond, policy in self.cond_to_policy_map.items():\n            if cond.evaluate(transaction):\n                return await policy.apply(transaction, container, session)\n        if self.default_policy:\n            return await self.default_policy.apply(transaction, container, session)\n        return transaction\n\n    def serialize(self) -&gt; SerializableDict:\n        \"\"\"Override serialize to handle complex condition-to-policy mapping.\"\"\"\n        data = super().serialize()\n        data[\"cond_to_policy_map\"] = {\n            json.dumps(cond.serialize()): policy.serialize() for cond, policy in self.cond_to_policy_map.items()\n        }\n        if self.default_policy:\n            data[\"default_policy\"] = self.default_policy.serialize()\n        else:\n            data[\"default_policy\"] = None\n        return data\n\n    @classmethod\n    def from_serialized(cls, config: SerializableDict) -&gt; \"BranchingPolicy\":\n        \"\"\"Custom from_serialized to handle JSON-serialized condition keys.\"\"\"\n        config_copy = dict(config)\n\n        cond_to_policy_map = OrderedDict()\n        serialized_cond_map = config_copy.pop(\"cond_to_policy_map\", None)\n        if serialized_cond_map is not None:\n            if not isinstance(serialized_cond_map, dict):\n                raise TypeError(\n                    f\"Expected 'cond_to_policy_map' to be a dict in BranchingPolicy config, \"\n                    f\"got {type(serialized_cond_map)}\"\n                )\n\n            for cond_json_str, policy_config in serialized_cond_map.items():\n                if not isinstance(cond_json_str, str):\n                    raise TypeError(\n                        f\"Condition key in 'cond_to_policy_map' must be a JSON string, got {type(cond_json_str)}\"\n                    )\n\n                if not isinstance(policy_config, dict):\n                    raise TypeError(\n                        f\"Policy config for condition '{cond_json_str}' must be a dict, got {type(policy_config)}\"\n                    )\n\n                try:\n                    condition_serializable_dict = json.loads(cond_json_str)\n                except json.JSONDecodeError as e:\n                    raise ValueError(f\"Failed to parse condition JSON string '{cond_json_str}': {e}\")\n\n                if not isinstance(condition_serializable_dict, dict):\n                    raise TypeError(\n                        f\"Deserialized condition config for '{cond_json_str}' must be a dict, \"\n                        f\"got {type(condition_serializable_dict)}\"\n                    )\n\n                condition = Condition.from_serialized(condition_serializable_dict)\n                policy = ControlPolicy.from_serialized(policy_config)\n                cond_to_policy_map[condition] = policy\n\n        default_policy = None\n        default_policy_serializable = config_copy.pop(\"default_policy\", None)\n        if default_policy_serializable is not None:\n            if not isinstance(default_policy_serializable, dict):\n                raise TypeError(\n                    f\"Expected 'default_policy' config to be a dict, got {type(default_policy_serializable)}\"\n                )\n            default_policy = ControlPolicy.from_serialized(default_policy_serializable)\n\n        instance = super().from_serialized(config_copy)\n\n        instance.cond_to_policy_map = cond_to_policy_map\n        instance.default_policy = default_policy\n\n        return instance\n</code></pre> <p>A Control Policy that conditionally applies different policies based on transaction evaluation.</p> <p>This policy evaluates conditions in order and applies the policy associated with the first matching condition. If no conditions match, it applies the default policy (if configured).</p>"},{"location":"#luthien_control.control_policy.branching_policy.BranchingPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/branching_policy.py</code> <pre><code>async def apply(\n    self, transaction: Transaction, container: DependencyContainer, session: AsyncSession\n) -&gt; Transaction:\n    \"\"\"\n    Apply the first policy that matches the condition. If no condition matches, apply the default policy (if set).\n\n    Args:\n        transaction: The transaction to apply the policy to.\n        container: The dependency container.\n        session: The database session.\n\n    Returns:\n        The potentially modified transaction.\n    \"\"\"\n    for cond, policy in self.cond_to_policy_map.items():\n        if cond.evaluate(transaction):\n            return await policy.apply(transaction, container, session)\n    if self.default_policy:\n        return await self.default_policy.apply(transaction, container, session)\n    return transaction\n</code></pre> <p>Apply the first policy that matches the condition. If no condition matches, apply the default policy (if set).</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The transaction to apply the policy to.</p> required <code>container</code> <code>DependencyContainer</code> <p>The dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>The database session.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The potentially modified transaction.</p>"},{"location":"#luthien_control.control_policy.branching_policy.BranchingPolicy.from_serialized","title":"<code>from_serialized(config)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/branching_policy.py</code> <pre><code>@classmethod\ndef from_serialized(cls, config: SerializableDict) -&gt; \"BranchingPolicy\":\n    \"\"\"Custom from_serialized to handle JSON-serialized condition keys.\"\"\"\n    config_copy = dict(config)\n\n    cond_to_policy_map = OrderedDict()\n    serialized_cond_map = config_copy.pop(\"cond_to_policy_map\", None)\n    if serialized_cond_map is not None:\n        if not isinstance(serialized_cond_map, dict):\n            raise TypeError(\n                f\"Expected 'cond_to_policy_map' to be a dict in BranchingPolicy config, \"\n                f\"got {type(serialized_cond_map)}\"\n            )\n\n        for cond_json_str, policy_config in serialized_cond_map.items():\n            if not isinstance(cond_json_str, str):\n                raise TypeError(\n                    f\"Condition key in 'cond_to_policy_map' must be a JSON string, got {type(cond_json_str)}\"\n                )\n\n            if not isinstance(policy_config, dict):\n                raise TypeError(\n                    f\"Policy config for condition '{cond_json_str}' must be a dict, got {type(policy_config)}\"\n                )\n\n            try:\n                condition_serializable_dict = json.loads(cond_json_str)\n            except json.JSONDecodeError as e:\n                raise ValueError(f\"Failed to parse condition JSON string '{cond_json_str}': {e}\")\n\n            if not isinstance(condition_serializable_dict, dict):\n                raise TypeError(\n                    f\"Deserialized condition config for '{cond_json_str}' must be a dict, \"\n                    f\"got {type(condition_serializable_dict)}\"\n                )\n\n            condition = Condition.from_serialized(condition_serializable_dict)\n            policy = ControlPolicy.from_serialized(policy_config)\n            cond_to_policy_map[condition] = policy\n\n    default_policy = None\n    default_policy_serializable = config_copy.pop(\"default_policy\", None)\n    if default_policy_serializable is not None:\n        if not isinstance(default_policy_serializable, dict):\n            raise TypeError(\n                f\"Expected 'default_policy' config to be a dict, got {type(default_policy_serializable)}\"\n            )\n        default_policy = ControlPolicy.from_serialized(default_policy_serializable)\n\n    instance = super().from_serialized(config_copy)\n\n    instance.cond_to_policy_map = cond_to_policy_map\n    instance.default_policy = default_policy\n\n    return instance\n</code></pre> <p>Custom from_serialized to handle JSON-serialized condition keys.</p>"},{"location":"#luthien_control.control_policy.branching_policy.BranchingPolicy.serialize","title":"<code>serialize()</code>","text":"Source code in <code>luthien_control/control_policy/branching_policy.py</code> <pre><code>def serialize(self) -&gt; SerializableDict:\n    \"\"\"Override serialize to handle complex condition-to-policy mapping.\"\"\"\n    data = super().serialize()\n    data[\"cond_to_policy_map\"] = {\n        json.dumps(cond.serialize()): policy.serialize() for cond, policy in self.cond_to_policy_map.items()\n    }\n    if self.default_policy:\n        data[\"default_policy\"] = self.default_policy.serialize()\n    else:\n        data[\"default_policy\"] = None\n    return data\n</code></pre> <p>Override serialize to handle complex condition-to-policy mapping.</p>"},{"location":"#luthien_control.control_policy.branching_policy.BranchingPolicy.validate_cond_to_policy_map","title":"<code>validate_cond_to_policy_map(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/branching_policy.py</code> <pre><code>@field_validator(\"cond_to_policy_map\", mode=\"before\")\n@classmethod\ndef validate_cond_to_policy_map(cls, value):\n    \"\"\"Validate and convert condition-to-policy mapping.\"\"\"\n    if isinstance(value, OrderedDict):\n        return value\n    if isinstance(value, dict):\n        return OrderedDict(value)\n    raise ValueError(\"cond_to_policy_map must be a dict or OrderedDict\")\n</code></pre> <p>Validate and convert condition-to-policy mapping.</p>"},{"location":"#luthien_control.control_policy.branching_policy.BranchingPolicy.validate_default_policy","title":"<code>validate_default_policy(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/branching_policy.py</code> <pre><code>@field_validator(\"default_policy\", mode=\"before\")\n@classmethod\ndef validate_default_policy(cls, value):\n    \"\"\"Validate default policy field.\"\"\"\n    return value\n</code></pre> <p>Validate default policy field.</p>"},{"location":"#luthien_control.control_policy.client_api_key_auth","title":"<code>client_api_key_auth</code>","text":""},{"location":"#luthien_control.control_policy.client_api_key_auth.ClientApiKeyAuthPolicy","title":"<code>ClientApiKeyAuthPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/client_api_key_auth.py</code> <pre><code>class ClientApiKeyAuthPolicy(ControlPolicy):\n    \"\"\"Verifies the client API key from the transaction's request.\n\n    This policy authenticates clients by checking their API key against\n    the database. It ensures the key exists and is active.\n\n    Attributes:\n        name (str): The name of this policy instance.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"ClientApiKeyAuthPolicy\")\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Verifies the API key from the transaction's request.\n        Requires the DependencyContainer and an active SQLAlchemy AsyncSession.\n\n        Raises:\n            NoRequestError: If transaction.request is None.\n            ClientAuthenticationError: If the key is missing, invalid, or inactive.\n\n        Args:\n            transaction: The current transaction.\n            container: The application dependency container.\n            session: An active SQLAlchemy AsyncSession.\n\n        Returns:\n            The unmodified transaction if authentication is successful.\n        \"\"\"\n        if transaction.request is None:\n            raise NoRequestError(\"No request in transaction for API key auth.\")\n\n        api_key_value = transaction.request.api_key\n\n        if not api_key_value:\n            self.logger.warning(\"Missing API key in transaction request.\")\n            raise ClientAuthenticationNotFoundError(detail=\"Not authenticated: Missing API key.\")\n\n        try:\n            db_key = await get_api_key_by_value(session, api_key_value)\n        except LuthienDBQueryError:\n            self.logger.warning(\n                f\"Invalid API key provided (key starts with: {api_key_value[:4]}...) ({self.__class__.__name__}).\"\n            )\n            raise ClientAuthenticationError(detail=\"Invalid API Key\")\n\n        if not db_key.is_active:\n            self.logger.warning(\n                f\"Inactive API key provided (Name: {db_key.name}, ID: {db_key.id}). ({self.__class__.__name__}).\"\n            )\n            raise ClientAuthenticationError(detail=\"Inactive API Key\")\n\n        self.logger.info(\n            f\"Client API key authenticated successfully \"\n            f\"(Name: {db_key.name}, ID: {db_key.id}). ({self.__class__.__name__}).\"\n        )\n\n        return transaction\n</code></pre> <p>Verifies the client API key from the transaction's request.</p> <p>This policy authenticates clients by checking their API key against the database. It ensures the key exists and is active.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of this policy instance.</p>"},{"location":"#luthien_control.control_policy.client_api_key_auth.ClientApiKeyAuthPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/client_api_key_auth.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Verifies the API key from the transaction's request.\n    Requires the DependencyContainer and an active SQLAlchemy AsyncSession.\n\n    Raises:\n        NoRequestError: If transaction.request is None.\n        ClientAuthenticationError: If the key is missing, invalid, or inactive.\n\n    Args:\n        transaction: The current transaction.\n        container: The application dependency container.\n        session: An active SQLAlchemy AsyncSession.\n\n    Returns:\n        The unmodified transaction if authentication is successful.\n    \"\"\"\n    if transaction.request is None:\n        raise NoRequestError(\"No request in transaction for API key auth.\")\n\n    api_key_value = transaction.request.api_key\n\n    if not api_key_value:\n        self.logger.warning(\"Missing API key in transaction request.\")\n        raise ClientAuthenticationNotFoundError(detail=\"Not authenticated: Missing API key.\")\n\n    try:\n        db_key = await get_api_key_by_value(session, api_key_value)\n    except LuthienDBQueryError:\n        self.logger.warning(\n            f\"Invalid API key provided (key starts with: {api_key_value[:4]}...) ({self.__class__.__name__}).\"\n        )\n        raise ClientAuthenticationError(detail=\"Invalid API Key\")\n\n    if not db_key.is_active:\n        self.logger.warning(\n            f\"Inactive API key provided (Name: {db_key.name}, ID: {db_key.id}). ({self.__class__.__name__}).\"\n        )\n        raise ClientAuthenticationError(detail=\"Inactive API Key\")\n\n    self.logger.info(\n        f\"Client API key authenticated successfully \"\n        f\"(Name: {db_key.name}, ID: {db_key.id}). ({self.__class__.__name__}).\"\n    )\n\n    return transaction\n</code></pre> <p>Verifies the API key from the transaction's request. Requires the DependencyContainer and an active SQLAlchemy AsyncSession.</p> <p>Raises:</p> Type Description <code>NoRequestError</code> <p>If transaction.request is None.</p> <code>ClientAuthenticationError</code> <p>If the key is missing, invalid, or inactive.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The unmodified transaction if authentication is successful.</p>"},{"location":"#luthien_control.control_policy.conditions","title":"<code>conditions</code>","text":""},{"location":"#luthien_control.control_policy.conditions.AllCondition","title":"<code>AllCondition</code>","text":"<p>           Bases: <code>Condition</code></p> Source code in <code>luthien_control/control_policy/conditions/all_cond.py</code> <pre><code>class AllCondition(Condition):\n    type: Literal[\"all\"] = \"all\"\n    conditions: List[Condition] = Field(...)\n\n    @field_serializer(\"conditions\")\n    def serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n        \"\"\"Custom serializer for conditions field.\"\"\"\n        return [condition.serialize() for condition in value]\n\n    @field_validator(\"conditions\", mode=\"before\")\n    @classmethod\n    def validate_conditions(cls, value):\n        \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n        if isinstance(value, list):\n            result = []\n            for item in value:\n                if isinstance(item, dict):\n                    result.append(Condition.from_serialized(item))\n                elif isinstance(item, Condition):\n                    result.append(item)\n            return result\n        return value\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        return all(condition.evaluate(transaction) for condition in self.conditions)\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.AllCondition.serialize_conditions","title":"<code>serialize_conditions(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/all_cond.py</code> <pre><code>@field_serializer(\"conditions\")\ndef serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n    \"\"\"Custom serializer for conditions field.\"\"\"\n    return [condition.serialize() for condition in value]\n</code></pre> <p>Custom serializer for conditions field.</p>"},{"location":"#luthien_control.control_policy.conditions.AllCondition.validate_conditions","title":"<code>validate_conditions(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/all_cond.py</code> <pre><code>@field_validator(\"conditions\", mode=\"before\")\n@classmethod\ndef validate_conditions(cls, value):\n    \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n    if isinstance(value, list):\n        result = []\n        for item in value:\n            if isinstance(item, dict):\n                result.append(Condition.from_serialized(item))\n            elif isinstance(item, Condition):\n                result.append(item)\n        return result\n    return value\n</code></pre> <p>Custom validator to deserialize conditions from dicts.</p>"},{"location":"#luthien_control.control_policy.conditions.AnyCondition","title":"<code>AnyCondition</code>","text":"<p>           Bases: <code>Condition</code></p> Source code in <code>luthien_control/control_policy/conditions/any_cond.py</code> <pre><code>class AnyCondition(Condition):\n    type: Literal[\"any\"] = \"any\"\n    conditions: List[Condition] = Field(...)\n\n    @field_serializer(\"conditions\")\n    def serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n        \"\"\"Custom serializer for conditions field.\"\"\"\n        return [condition.serialize() for condition in value]\n\n    @field_validator(\"conditions\", mode=\"before\")\n    @classmethod\n    def validate_conditions(cls, value):\n        \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n        if isinstance(value, list):\n            result = []\n            for item in value:\n                if isinstance(item, dict):\n                    result.append(Condition.from_serialized(item))\n                elif isinstance(item, Condition):\n                    result.append(item)\n            return result\n        return value\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        if not self.conditions:\n            return False\n        return any(condition.evaluate(transaction) for condition in self.conditions)\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.AnyCondition.serialize_conditions","title":"<code>serialize_conditions(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/any_cond.py</code> <pre><code>@field_serializer(\"conditions\")\ndef serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n    \"\"\"Custom serializer for conditions field.\"\"\"\n    return [condition.serialize() for condition in value]\n</code></pre> <p>Custom serializer for conditions field.</p>"},{"location":"#luthien_control.control_policy.conditions.AnyCondition.validate_conditions","title":"<code>validate_conditions(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/any_cond.py</code> <pre><code>@field_validator(\"conditions\", mode=\"before\")\n@classmethod\ndef validate_conditions(cls, value):\n    \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n    if isinstance(value, list):\n        result = []\n        for item in value:\n            if isinstance(item, dict):\n                result.append(Condition.from_serialized(item))\n            elif isinstance(item, Condition):\n                result.append(item)\n        return result\n    return value\n</code></pre> <p>Custom validator to deserialize conditions from dicts.</p>"},{"location":"#luthien_control.control_policy.conditions.Condition","title":"<code>Condition</code>","text":"<p>           Bases: <code>BaseModel</code>, <code>ABC</code></p> Source code in <code>luthien_control/control_policy/conditions/condition.py</code> <pre><code>class Condition(BaseModel, abc.ABC):\n    \"\"\"\n    Abstract base class for conditions in control policies.\n\n    Conditions are used to evaluate whether a policy should be applied based on\n    the current transaction.\n    \"\"\"\n\n    type: Any  # Allow any string type including Literal types\n\n    @abc.abstractmethod\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        pass\n\n    def serialize(self) -&gt; SerializableDict:\n        \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n        data = safe_model_dump(self)\n        data[\"type\"] = self.type\n        return data\n\n    @classmethod\n    def from_serialized(cls, serialized: SerializableDict) -&gt; \"Condition\":\n        \"\"\"Construct a condition from a serialized configuration.\n\n        This method acts as a dispatcher. It looks up the concrete condition class\n        based on the 'type' field in the config and delegates to its from_serialized method.\n\n        Args:\n            serialized: The condition-specific configuration dictionary. It must contain\n                        a 'type' key that maps to a registered condition type.\n\n        Returns:\n            An instance of the concrete condition class.\n\n        Raises:\n            ValueError: If the 'type' key is missing in config or the type is not registered.\n        \"\"\"\n        # Moved import inside the method to break circular dependency\n        from luthien_control.control_policy.conditions.registry import NAME_TO_CONDITION_CLASS\n\n        condition_type_name_val = str(serialized.get(\"type\"))\n\n        target_condition_class = NAME_TO_CONDITION_CLASS[condition_type_name_val]\n\n        return safe_model_validate(target_condition_class, serialized)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.serialize()})\"\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return self.serialize() == other.serialize()\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre> <p>Abstract base class for conditions in control policies.</p> <p>Conditions are used to evaluate whether a policy should be applied based on the current transaction.</p>"},{"location":"#luthien_control.control_policy.conditions.Condition.from_serialized","title":"<code>from_serialized(serialized)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/condition.py</code> <pre><code>@classmethod\ndef from_serialized(cls, serialized: SerializableDict) -&gt; \"Condition\":\n    \"\"\"Construct a condition from a serialized configuration.\n\n    This method acts as a dispatcher. It looks up the concrete condition class\n    based on the 'type' field in the config and delegates to its from_serialized method.\n\n    Args:\n        serialized: The condition-specific configuration dictionary. It must contain\n                    a 'type' key that maps to a registered condition type.\n\n    Returns:\n        An instance of the concrete condition class.\n\n    Raises:\n        ValueError: If the 'type' key is missing in config or the type is not registered.\n    \"\"\"\n    # Moved import inside the method to break circular dependency\n    from luthien_control.control_policy.conditions.registry import NAME_TO_CONDITION_CLASS\n\n    condition_type_name_val = str(serialized.get(\"type\"))\n\n    target_condition_class = NAME_TO_CONDITION_CLASS[condition_type_name_val]\n\n    return safe_model_validate(target_condition_class, serialized)\n</code></pre> <p>Construct a condition from a serialized configuration.</p> <p>This method acts as a dispatcher. It looks up the concrete condition class based on the 'type' field in the config and delegates to its from_serialized method.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializableDict</code> <p>The condition-specific configuration dictionary. It must contain         a 'type' key that maps to a registered condition type.</p> required <p>Returns:</p> Type Description <code>Condition</code> <p>An instance of the concrete condition class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'type' key is missing in config or the type is not registered.</p>"},{"location":"#luthien_control.control_policy.conditions.Condition.serialize","title":"<code>serialize()</code>","text":"Source code in <code>luthien_control/control_policy/conditions/condition.py</code> <pre><code>def serialize(self) -&gt; SerializableDict:\n    \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n    data = safe_model_dump(self)\n    data[\"type\"] = self.type\n    return data\n</code></pre> <p>Serialize using Pydantic model_dump through SerializableDict validation.</p>"},{"location":"#luthien_control.control_policy.conditions.ContainsCondition","title":"<code>ContainsCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class ContainsCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value contains the right value.\n    \"\"\"\n\n    type: Literal[\"contains\"] = Field(default=\"contains\")\n    comparator = contains\n</code></pre> <p>Condition to check if the left value contains the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.EqualsCondition","title":"<code>EqualsCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class EqualsCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if two values are equal.\n\n    Examples:\n        # Traditional\n        EqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")\n\n        # Dynamic\n        EqualsCondition(path(\"request.payload.model\"), path(\"data.preferred_model\"))\n\n        # Static vs dynamic\n        EqualsCondition(\"gpt-4o\", path(\"request.payload.model\"))\n    \"\"\"\n\n    type: Literal[\"equals\"] = Field(default=\"equals\")\n    comparator = equals\n</code></pre> <p>Condition to check if two values are equal.</p> <p>Examples:</p>"},{"location":"#luthien_control.control_policy.conditions.EqualsCondition--traditional","title":"Traditional","text":"<p>EqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")</p>"},{"location":"#luthien_control.control_policy.conditions.EqualsCondition--dynamic","title":"Dynamic","text":"<p>EqualsCondition(path(\"request.payload.model\"), path(\"data.preferred_model\"))</p>"},{"location":"#luthien_control.control_policy.conditions.EqualsCondition--static-vs-dynamic","title":"Static vs dynamic","text":"<p>EqualsCondition(\"gpt-4o\", path(\"request.payload.model\"))</p>"},{"location":"#luthien_control.control_policy.conditions.GreaterThanCondition","title":"<code>GreaterThanCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class GreaterThanCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is greater than the right value.\n    \"\"\"\n\n    type: Literal[\"greater_than\"] = Field(default=\"greater_than\")\n    comparator = greater_than\n</code></pre> <p>Condition to check if the left value is greater than the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.GreaterThanOrEqualCondition","title":"<code>GreaterThanOrEqualCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class GreaterThanOrEqualCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is greater than or equal to the right value.\n    \"\"\"\n\n    type: Literal[\"greater_than_or_equal\"] = Field(default=\"greater_than_or_equal\")\n    comparator = greater_than_or_equal\n</code></pre> <p>Condition to check if the left value is greater than or equal to the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.LessThanCondition","title":"<code>LessThanCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class LessThanCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is less than the right value.\n    \"\"\"\n\n    type: Literal[\"less_than\"] = Field(default=\"less_than\")\n    comparator = less_than\n</code></pre> <p>Condition to check if the left value is less than the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.LessThanOrEqualCondition","title":"<code>LessThanOrEqualCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class LessThanOrEqualCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is less than or equal to the right value.\n    \"\"\"\n\n    type: Literal[\"less_than_or_equal\"] = Field(default=\"less_than_or_equal\")\n    comparator = less_than_or_equal\n</code></pre> <p>Condition to check if the left value is less than or equal to the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.NotCondition","title":"<code>NotCondition</code>","text":"<p>           Bases: <code>Condition</code></p> Source code in <code>luthien_control/control_policy/conditions/not_cond.py</code> <pre><code>class NotCondition(Condition):\n    type: Literal[\"not\"] = \"not\"\n    cond: Condition = Field(...)\n\n    @field_serializer(\"cond\")\n    def serialize_cond(self, value: Condition) -&gt; dict:\n        \"\"\"Custom serializer for cond field.\"\"\"\n        return value.serialize()\n\n    @field_validator(\"cond\", mode=\"before\")\n    @classmethod\n    def validate_cond(cls, value):\n        \"\"\"Custom validator to deserialize condition from dict.\"\"\"\n        if isinstance(value, dict):\n            return Condition.from_serialized(value)\n        return value\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        return not self.cond.evaluate(transaction)\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}(value={self.cond!r})\"\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.NotCondition.serialize_cond","title":"<code>serialize_cond(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/not_cond.py</code> <pre><code>@field_serializer(\"cond\")\ndef serialize_cond(self, value: Condition) -&gt; dict:\n    \"\"\"Custom serializer for cond field.\"\"\"\n    return value.serialize()\n</code></pre> <p>Custom serializer for cond field.</p>"},{"location":"#luthien_control.control_policy.conditions.NotCondition.validate_cond","title":"<code>validate_cond(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/not_cond.py</code> <pre><code>@field_validator(\"cond\", mode=\"before\")\n@classmethod\ndef validate_cond(cls, value):\n    \"\"\"Custom validator to deserialize condition from dict.\"\"\"\n    if isinstance(value, dict):\n        return Condition.from_serialized(value)\n    return value\n</code></pre> <p>Custom validator to deserialize condition from dict.</p>"},{"location":"#luthien_control.control_policy.conditions.NotEqualsCondition","title":"<code>NotEqualsCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class NotEqualsCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if two values are NOT equal.\n    \"\"\"\n\n    type: Literal[\"not_equals\"] = Field(default=\"not_equals\")\n    comparator = not_equals\n</code></pre> <p>Condition to check if two values are NOT equal.</p>"},{"location":"#luthien_control.control_policy.conditions.RegexMatchCondition","title":"<code>RegexMatchCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class RegexMatchCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value matches a regex pattern.\n    \"\"\"\n\n    type: Literal[\"regex_match\"] = Field(default=\"regex_match\")\n    comparator = regex_match\n</code></pre> <p>Condition to check if the left value matches a regex pattern.</p>"},{"location":"#luthien_control.control_policy.conditions.path","title":"<code>path(transaction_path)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def path(transaction_path: str) -&gt; TransactionPath:\n    \"\"\"\n    Convenience function to create a TransactionPath.\n\n    Args:\n        transaction_path: The path to the value in the transaction\n\n    Returns:\n        A TransactionPath instance\n\n    Example:\n        path(\"request.payload.model\")\n    \"\"\"\n    return TransactionPath(path=transaction_path)\n</code></pre> <p>Convenience function to create a TransactionPath.</p> <p>Parameters:</p> Name Type Description Default <code>transaction_path</code> <code>str</code> <p>The path to the value in the transaction</p> required <p>Returns:</p> Type Description <code>TransactionPath</code> <p>A TransactionPath instance</p> Example <p>path(\"request.payload.model\")</p>"},{"location":"#luthien_control.control_policy.conditions.all_cond","title":"<code>all_cond</code>","text":""},{"location":"#luthien_control.control_policy.conditions.all_cond.AllCondition","title":"<code>AllCondition</code>","text":"<p>           Bases: <code>Condition</code></p> Source code in <code>luthien_control/control_policy/conditions/all_cond.py</code> <pre><code>class AllCondition(Condition):\n    type: Literal[\"all\"] = \"all\"\n    conditions: List[Condition] = Field(...)\n\n    @field_serializer(\"conditions\")\n    def serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n        \"\"\"Custom serializer for conditions field.\"\"\"\n        return [condition.serialize() for condition in value]\n\n    @field_validator(\"conditions\", mode=\"before\")\n    @classmethod\n    def validate_conditions(cls, value):\n        \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n        if isinstance(value, list):\n            result = []\n            for item in value:\n                if isinstance(item, dict):\n                    result.append(Condition.from_serialized(item))\n                elif isinstance(item, Condition):\n                    result.append(item)\n            return result\n        return value\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        return all(condition.evaluate(transaction) for condition in self.conditions)\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.all_cond.AllCondition.serialize_conditions","title":"<code>serialize_conditions(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/all_cond.py</code> <pre><code>@field_serializer(\"conditions\")\ndef serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n    \"\"\"Custom serializer for conditions field.\"\"\"\n    return [condition.serialize() for condition in value]\n</code></pre> <p>Custom serializer for conditions field.</p>"},{"location":"#luthien_control.control_policy.conditions.all_cond.AllCondition.validate_conditions","title":"<code>validate_conditions(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/all_cond.py</code> <pre><code>@field_validator(\"conditions\", mode=\"before\")\n@classmethod\ndef validate_conditions(cls, value):\n    \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n    if isinstance(value, list):\n        result = []\n        for item in value:\n            if isinstance(item, dict):\n                result.append(Condition.from_serialized(item))\n            elif isinstance(item, Condition):\n                result.append(item)\n        return result\n    return value\n</code></pre> <p>Custom validator to deserialize conditions from dicts.</p>"},{"location":"#luthien_control.control_policy.conditions.any_cond","title":"<code>any_cond</code>","text":""},{"location":"#luthien_control.control_policy.conditions.any_cond.AnyCondition","title":"<code>AnyCondition</code>","text":"<p>           Bases: <code>Condition</code></p> Source code in <code>luthien_control/control_policy/conditions/any_cond.py</code> <pre><code>class AnyCondition(Condition):\n    type: Literal[\"any\"] = \"any\"\n    conditions: List[Condition] = Field(...)\n\n    @field_serializer(\"conditions\")\n    def serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n        \"\"\"Custom serializer for conditions field.\"\"\"\n        return [condition.serialize() for condition in value]\n\n    @field_validator(\"conditions\", mode=\"before\")\n    @classmethod\n    def validate_conditions(cls, value):\n        \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n        if isinstance(value, list):\n            result = []\n            for item in value:\n                if isinstance(item, dict):\n                    result.append(Condition.from_serialized(item))\n                elif isinstance(item, Condition):\n                    result.append(item)\n            return result\n        return value\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        if not self.conditions:\n            return False\n        return any(condition.evaluate(transaction) for condition in self.conditions)\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.any_cond.AnyCondition.serialize_conditions","title":"<code>serialize_conditions(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/any_cond.py</code> <pre><code>@field_serializer(\"conditions\")\ndef serialize_conditions(self, value: List[Condition]) -&gt; List[dict]:\n    \"\"\"Custom serializer for conditions field.\"\"\"\n    return [condition.serialize() for condition in value]\n</code></pre> <p>Custom serializer for conditions field.</p>"},{"location":"#luthien_control.control_policy.conditions.any_cond.AnyCondition.validate_conditions","title":"<code>validate_conditions(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/any_cond.py</code> <pre><code>@field_validator(\"conditions\", mode=\"before\")\n@classmethod\ndef validate_conditions(cls, value):\n    \"\"\"Custom validator to deserialize conditions from dicts.\"\"\"\n    if isinstance(value, list):\n        result = []\n        for item in value:\n            if isinstance(item, dict):\n                result.append(Condition.from_serialized(item))\n            elif isinstance(item, Condition):\n                result.append(item)\n        return result\n    return value\n</code></pre> <p>Custom validator to deserialize conditions from dicts.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions","title":"<code>comparison_conditions</code>","text":"<p>Comparison conditions for control policies.</p> <p>This module implements comparison-based conditions (equals, contains, greater than, etc.) using a clean ValueResolver pattern for flexible value resolution.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions--pyright-type-checker-suppression","title":"Pyright Type Checker Suppression","text":"<p>The <code># pyright: reportCallIssue=false</code> comment at the top of this file suppresses type checker warnings for positional argument usage in comparison condition constructors.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions--why-this-is-necessary","title":"Why This Is Necessary","text":"<p>All comparison conditions inherit from Pydantic's BaseModel, which enforces keyword-only constructors. However, we provide a more natural API with positional arguments:</p> <pre><code># Natural, concise syntax (what we want)\nEqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")\n\n# Verbose but type-safe (what Pydantic expects)\nEqualsCondition(left=path(\"request.payload.model\"), right=\"gpt-4o\")\n</code></pre> <p>Our custom <code>__init__</code> methods handle both patterns correctly at runtime, but static analysis tools like pyright cannot see through the Pydantic inheritance to understand this flexibility.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions--safety-considerations","title":"Safety Considerations","text":"<p>This suppression is safe because: 1. We only suppress <code>reportCallIssue</code> (constructor signature mismatches) 2. Our overload definitions provide proper type hints 3. Runtime behavior is thoroughly tested 4. Other type checking (return types, field access, etc.) remains active</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions--for-users-of-this-module","title":"For Users of This Module","text":"<p>When using these comparison conditions in your code, you may encounter pyright warnings. See the <code>ComparisonCondition</code> class documentation for guidance on suppressing these warnings appropriately in your own files.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition","title":"<code>ComparisonCondition</code>","text":"<p>           Bases: <code>Condition</code>, <code>ABC</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class ComparisonCondition(Condition, ABC):\n    \"\"\"\n    Clean comparison condition that uses ValueResolver objects for flexible value resolution.\n\n    This approach eliminates the need for is_dynamic_* flags by using explicit types.\n\n    ## Constructor Usage\n\n    This class supports both positional and keyword argument patterns:\n\n    ### Positional Arguments (Recommended for brevity)\n    ```python\n    EqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")\n    EqualsCondition(path(\"left_path\"), path(\"right_path\"))  # Dynamic comparison\n    EqualsCondition(\"static_left\", \"static_right\")          # Static comparison\n    ```\n\n    ### Keyword Arguments (Explicit, type-safe)\n    ```python\n    EqualsCondition(left=path(\"request.payload.model\"), right=\"gpt-4o\")\n    EqualsCondition(left=path(\"left_path\"), right=path(\"right_path\"))\n    ```\n\n    ## Pyright Type Checker Warning\n\n    **Important**: When using positional arguments, pyright may show this error:\n    ```\n    Expected 0 positional arguments (reportCallIssue)\n    ```\n\n    This is a known issue due to the underlying Pydantic BaseModel inheritance. The code\n    works correctly at runtime, but pyright's static analysis doesn't recognize our\n    custom `__init__` override.\n\n    ### How to Suppress the Warning\n\n    Add this comment to suppress the specific error on individual calls:\n    ```python\n    condition = EqualsCondition(path(\"test\"), \"value\")  # pyright: ignore[reportCallIssue]\n    ```\n\n    Or add this at the top of your file to suppress all such errors in that file:\n    ```python\n    # pyright: reportCallIssue=false\n    ```\n\n    ### When to Use Each Approach\n\n    - **Use positional**: For concise, readable condition creation in tests and simple cases\n    - **Use keywords**: When you need full type safety or when working in strict typing environments\n    - **Suppress warnings**: When you prefer the positional syntax and understand the trade-off\n    \"\"\"\n\n    comparator: ClassVar[Comparator]\n\n    left: ValueResolver\n    right: ValueResolver\n    comparator_name: str = Field(alias=\"comparator\")\n\n    @overload\n    def __init__(self, left: Union[Any, ValueResolver], right: Union[Any, ValueResolver]) -&gt; None: ...\n\n    @overload\n    def __init__(self, *, left: ValueResolver, right: ValueResolver, comparator: str, **kwargs: Any) -&gt; None: ...\n\n    def __init__(\n        self,\n        left: Union[Any, ValueResolver, None] = None,\n        right: Union[Any, ValueResolver, None] = None,\n        *,\n        # Pydantic keyword-only arguments\n        comparator: Union[str, None] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize with both positional and keyword argument support.\"\"\"\n        # Handle positional arguments\n        if left is not None and right is not None:\n            kwargs[\"left\"] = auto_resolve_value(left)\n            kwargs[\"right\"] = auto_resolve_value(right)\n            if comparator is None:\n                kwargs[\"comparator\"] = COMPARATOR_TO_NAME[type(self).comparator]\n            else:\n                kwargs[\"comparator\"] = comparator\n\n        super().__init__(**kwargs)\n\n    @field_serializer(\"left\", \"right\")\n    def serialize_value_resolver(self, value: ValueResolver) -&gt; dict:\n        \"\"\"Custom serializer for ValueResolver fields.\"\"\"\n        return value.serialize()\n\n    @field_validator(\"left\", \"right\", mode=\"before\")\n    @classmethod\n    def validate_value_resolver(cls, value: StaticValue | ValueResolver):\n        \"\"\"Custom validator to deserialize ValueResolver from dict.\"\"\"\n        if isinstance(value, StaticValue) and isinstance(value.value, dict) and \"type\" in value.value:\n            return create_value_resolver(value.value)\n        else:\n            return auto_resolve_value(value)\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        \"\"\"Evaluate the condition against the transaction.\"\"\"\n        left_value = self.left.resolve(transaction)\n        right_value = self.right.resolve(transaction)\n        return type(self).comparator.evaluate(left_value, right_value)\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}({self.left!r}, {self.right!r})\"\n\n    @classmethod\n    def from_legacy_format(cls, key: str, value: Any) -&gt; \"ComparisonCondition\":\n        \"\"\"\n        Create a condition from legacy ComparisonCondition format.\n\n        Args:\n            key: Transaction path (e.g., \"request.payload.model\")\n            value: Static value to compare against\n\n        Returns:\n            A ComparisonCondition instance\n        \"\"\"\n        return cls(path(key), value)\n</code></pre> <p>Clean comparison condition that uses ValueResolver objects for flexible value resolution.</p> <p>This approach eliminates the need for is_dynamic_* flags by using explicit types.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition--constructor-usage","title":"Constructor Usage","text":"<p>This class supports both positional and keyword argument patterns:</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition--positional-arguments-recommended-for-brevity","title":"Positional Arguments (Recommended for brevity)","text":"<pre><code>EqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")\nEqualsCondition(path(\"left_path\"), path(\"right_path\"))  # Dynamic comparison\nEqualsCondition(\"static_left\", \"static_right\")          # Static comparison\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition--keyword-arguments-explicit-type-safe","title":"Keyword Arguments (Explicit, type-safe)","text":"<pre><code>EqualsCondition(left=path(\"request.payload.model\"), right=\"gpt-4o\")\nEqualsCondition(left=path(\"left_path\"), right=path(\"right_path\"))\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition--pyright-type-checker-warning","title":"Pyright Type Checker Warning","text":"<p>Important: When using positional arguments, pyright may show this error:</p> <pre><code>Expected 0 positional arguments (reportCallIssue)\n</code></pre> <p>This is a known issue due to the underlying Pydantic BaseModel inheritance. The code works correctly at runtime, but pyright's static analysis doesn't recognize our custom <code>__init__</code> override.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition--how-to-suppress-the-warning","title":"How to Suppress the Warning","text":"<p>Add this comment to suppress the specific error on individual calls:</p> <pre><code>condition = EqualsCondition(path(\"test\"), \"value\")  # pyright: ignore[reportCallIssue]\n</code></pre> <p>Or add this at the top of your file to suppress all such errors in that file:</p> <pre><code># pyright: reportCallIssue=false\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition--when-to-use-each-approach","title":"When to Use Each Approach","text":"<ul> <li>Use positional: For concise, readable condition creation in tests and simple cases</li> <li>Use keywords: When you need full type safety or when working in strict typing environments</li> <li>Suppress warnings: When you prefer the positional syntax and understand the trade-off</li> </ul>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition.__init__","title":"<code>__init__(left=None, right=None, *, comparator=None, **kwargs)</code>","text":"<pre><code>__init__(\n    left: Union[Any, ValueResolver],\n    right: Union[Any, ValueResolver],\n) -&gt; None\n</code></pre><pre><code>__init__(\n    *,\n    left: ValueResolver,\n    right: ValueResolver,\n    comparator: str,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>def __init__(\n    self,\n    left: Union[Any, ValueResolver, None] = None,\n    right: Union[Any, ValueResolver, None] = None,\n    *,\n    # Pydantic keyword-only arguments\n    comparator: Union[str, None] = None,\n    **kwargs,\n):\n    \"\"\"Initialize with both positional and keyword argument support.\"\"\"\n    # Handle positional arguments\n    if left is not None and right is not None:\n        kwargs[\"left\"] = auto_resolve_value(left)\n        kwargs[\"right\"] = auto_resolve_value(right)\n        if comparator is None:\n            kwargs[\"comparator\"] = COMPARATOR_TO_NAME[type(self).comparator]\n        else:\n            kwargs[\"comparator\"] = comparator\n\n    super().__init__(**kwargs)\n</code></pre> <p>Initialize with both positional and keyword argument support.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition.evaluate","title":"<code>evaluate(transaction)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>def evaluate(self, transaction: Transaction) -&gt; bool:\n    \"\"\"Evaluate the condition against the transaction.\"\"\"\n    left_value = self.left.resolve(transaction)\n    right_value = self.right.resolve(transaction)\n    return type(self).comparator.evaluate(left_value, right_value)\n</code></pre> <p>Evaluate the condition against the transaction.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition.from_legacy_format","title":"<code>from_legacy_format(key, value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>@classmethod\ndef from_legacy_format(cls, key: str, value: Any) -&gt; \"ComparisonCondition\":\n    \"\"\"\n    Create a condition from legacy ComparisonCondition format.\n\n    Args:\n        key: Transaction path (e.g., \"request.payload.model\")\n        value: Static value to compare against\n\n    Returns:\n        A ComparisonCondition instance\n    \"\"\"\n    return cls(path(key), value)\n</code></pre> <p>Create a condition from legacy ComparisonCondition format.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Transaction path (e.g., \"request.payload.model\")</p> required <code>value</code> <code>Any</code> <p>Static value to compare against</p> required <p>Returns:</p> Type Description <code>ComparisonCondition</code> <p>A ComparisonCondition instance</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition.serialize_value_resolver","title":"<code>serialize_value_resolver(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>@field_serializer(\"left\", \"right\")\ndef serialize_value_resolver(self, value: ValueResolver) -&gt; dict:\n    \"\"\"Custom serializer for ValueResolver fields.\"\"\"\n    return value.serialize()\n</code></pre> <p>Custom serializer for ValueResolver fields.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ComparisonCondition.validate_value_resolver","title":"<code>validate_value_resolver(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>@field_validator(\"left\", \"right\", mode=\"before\")\n@classmethod\ndef validate_value_resolver(cls, value: StaticValue | ValueResolver):\n    \"\"\"Custom validator to deserialize ValueResolver from dict.\"\"\"\n    if isinstance(value, StaticValue) and isinstance(value.value, dict) and \"type\" in value.value:\n        return create_value_resolver(value.value)\n    else:\n        return auto_resolve_value(value)\n</code></pre> <p>Custom validator to deserialize ValueResolver from dict.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.ContainsCondition","title":"<code>ContainsCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class ContainsCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value contains the right value.\n    \"\"\"\n\n    type: Literal[\"contains\"] = Field(default=\"contains\")\n    comparator = contains\n</code></pre> <p>Condition to check if the left value contains the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.EqualsCondition","title":"<code>EqualsCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class EqualsCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if two values are equal.\n\n    Examples:\n        # Traditional\n        EqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")\n\n        # Dynamic\n        EqualsCondition(path(\"request.payload.model\"), path(\"data.preferred_model\"))\n\n        # Static vs dynamic\n        EqualsCondition(\"gpt-4o\", path(\"request.payload.model\"))\n    \"\"\"\n\n    type: Literal[\"equals\"] = Field(default=\"equals\")\n    comparator = equals\n</code></pre> <p>Condition to check if two values are equal.</p> <p>Examples:</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.EqualsCondition--traditional","title":"Traditional","text":"<p>EqualsCondition(path(\"request.payload.model\"), \"gpt-4o\")</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.EqualsCondition--dynamic","title":"Dynamic","text":"<p>EqualsCondition(path(\"request.payload.model\"), path(\"data.preferred_model\"))</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.EqualsCondition--static-vs-dynamic","title":"Static vs dynamic","text":"<p>EqualsCondition(\"gpt-4o\", path(\"request.payload.model\"))</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.GreaterThanCondition","title":"<code>GreaterThanCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class GreaterThanCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is greater than the right value.\n    \"\"\"\n\n    type: Literal[\"greater_than\"] = Field(default=\"greater_than\")\n    comparator = greater_than\n</code></pre> <p>Condition to check if the left value is greater than the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.GreaterThanOrEqualCondition","title":"<code>GreaterThanOrEqualCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class GreaterThanOrEqualCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is greater than or equal to the right value.\n    \"\"\"\n\n    type: Literal[\"greater_than_or_equal\"] = Field(default=\"greater_than_or_equal\")\n    comparator = greater_than_or_equal\n</code></pre> <p>Condition to check if the left value is greater than or equal to the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.LessThanCondition","title":"<code>LessThanCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class LessThanCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is less than the right value.\n    \"\"\"\n\n    type: Literal[\"less_than\"] = Field(default=\"less_than\")\n    comparator = less_than\n</code></pre> <p>Condition to check if the left value is less than the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.LessThanOrEqualCondition","title":"<code>LessThanOrEqualCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class LessThanOrEqualCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value is less than or equal to the right value.\n    \"\"\"\n\n    type: Literal[\"less_than_or_equal\"] = Field(default=\"less_than_or_equal\")\n    comparator = less_than_or_equal\n</code></pre> <p>Condition to check if the left value is less than or equal to the right value.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.NotEqualsCondition","title":"<code>NotEqualsCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class NotEqualsCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if two values are NOT equal.\n    \"\"\"\n\n    type: Literal[\"not_equals\"] = Field(default=\"not_equals\")\n    comparator = not_equals\n</code></pre> <p>Condition to check if two values are NOT equal.</p>"},{"location":"#luthien_control.control_policy.conditions.comparison_conditions.RegexMatchCondition","title":"<code>RegexMatchCondition</code>","text":"<p>           Bases: <code>ComparisonCondition</code></p> Source code in <code>luthien_control/control_policy/conditions/comparison_conditions.py</code> <pre><code>class RegexMatchCondition(ComparisonCondition):\n    \"\"\"\n    Condition to check if the left value matches a regex pattern.\n    \"\"\"\n\n    type: Literal[\"regex_match\"] = Field(default=\"regex_match\")\n    comparator = regex_match\n</code></pre> <p>Condition to check if the left value matches a regex pattern.</p>"},{"location":"#luthien_control.control_policy.conditions.condition","title":"<code>condition</code>","text":""},{"location":"#luthien_control.control_policy.conditions.condition.Condition","title":"<code>Condition</code>","text":"<p>           Bases: <code>BaseModel</code>, <code>ABC</code></p> Source code in <code>luthien_control/control_policy/conditions/condition.py</code> <pre><code>class Condition(BaseModel, abc.ABC):\n    \"\"\"\n    Abstract base class for conditions in control policies.\n\n    Conditions are used to evaluate whether a policy should be applied based on\n    the current transaction.\n    \"\"\"\n\n    type: Any  # Allow any string type including Literal types\n\n    @abc.abstractmethod\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        pass\n\n    def serialize(self) -&gt; SerializableDict:\n        \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n        data = safe_model_dump(self)\n        data[\"type\"] = self.type\n        return data\n\n    @classmethod\n    def from_serialized(cls, serialized: SerializableDict) -&gt; \"Condition\":\n        \"\"\"Construct a condition from a serialized configuration.\n\n        This method acts as a dispatcher. It looks up the concrete condition class\n        based on the 'type' field in the config and delegates to its from_serialized method.\n\n        Args:\n            serialized: The condition-specific configuration dictionary. It must contain\n                        a 'type' key that maps to a registered condition type.\n\n        Returns:\n            An instance of the concrete condition class.\n\n        Raises:\n            ValueError: If the 'type' key is missing in config or the type is not registered.\n        \"\"\"\n        # Moved import inside the method to break circular dependency\n        from luthien_control.control_policy.conditions.registry import NAME_TO_CONDITION_CLASS\n\n        condition_type_name_val = str(serialized.get(\"type\"))\n\n        target_condition_class = NAME_TO_CONDITION_CLASS[condition_type_name_val]\n\n        return safe_model_validate(target_condition_class, serialized)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.serialize()})\"\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self))\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, self.__class__):\n            return False\n        return self.serialize() == other.serialize()\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre> <p>Abstract base class for conditions in control policies.</p> <p>Conditions are used to evaluate whether a policy should be applied based on the current transaction.</p>"},{"location":"#luthien_control.control_policy.conditions.condition.Condition.from_serialized","title":"<code>from_serialized(serialized)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/condition.py</code> <pre><code>@classmethod\ndef from_serialized(cls, serialized: SerializableDict) -&gt; \"Condition\":\n    \"\"\"Construct a condition from a serialized configuration.\n\n    This method acts as a dispatcher. It looks up the concrete condition class\n    based on the 'type' field in the config and delegates to its from_serialized method.\n\n    Args:\n        serialized: The condition-specific configuration dictionary. It must contain\n                    a 'type' key that maps to a registered condition type.\n\n    Returns:\n        An instance of the concrete condition class.\n\n    Raises:\n        ValueError: If the 'type' key is missing in config or the type is not registered.\n    \"\"\"\n    # Moved import inside the method to break circular dependency\n    from luthien_control.control_policy.conditions.registry import NAME_TO_CONDITION_CLASS\n\n    condition_type_name_val = str(serialized.get(\"type\"))\n\n    target_condition_class = NAME_TO_CONDITION_CLASS[condition_type_name_val]\n\n    return safe_model_validate(target_condition_class, serialized)\n</code></pre> <p>Construct a condition from a serialized configuration.</p> <p>This method acts as a dispatcher. It looks up the concrete condition class based on the 'type' field in the config and delegates to its from_serialized method.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializableDict</code> <p>The condition-specific configuration dictionary. It must contain         a 'type' key that maps to a registered condition type.</p> required <p>Returns:</p> Type Description <code>Condition</code> <p>An instance of the concrete condition class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'type' key is missing in config or the type is not registered.</p>"},{"location":"#luthien_control.control_policy.conditions.condition.Condition.serialize","title":"<code>serialize()</code>","text":"Source code in <code>luthien_control/control_policy/conditions/condition.py</code> <pre><code>def serialize(self) -&gt; SerializableDict:\n    \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n    data = safe_model_dump(self)\n    data[\"type\"] = self.type\n    return data\n</code></pre> <p>Serialize using Pydantic model_dump through SerializableDict validation.</p>"},{"location":"#luthien_control.control_policy.conditions.not_cond","title":"<code>not_cond</code>","text":""},{"location":"#luthien_control.control_policy.conditions.not_cond.NotCondition","title":"<code>NotCondition</code>","text":"<p>           Bases: <code>Condition</code></p> Source code in <code>luthien_control/control_policy/conditions/not_cond.py</code> <pre><code>class NotCondition(Condition):\n    type: Literal[\"not\"] = \"not\"\n    cond: Condition = Field(...)\n\n    @field_serializer(\"cond\")\n    def serialize_cond(self, value: Condition) -&gt; dict:\n        \"\"\"Custom serializer for cond field.\"\"\"\n        return value.serialize()\n\n    @field_validator(\"cond\", mode=\"before\")\n    @classmethod\n    def validate_cond(cls, value):\n        \"\"\"Custom validator to deserialize condition from dict.\"\"\"\n        if isinstance(value, dict):\n            return Condition.from_serialized(value)\n        return value\n\n    def evaluate(self, transaction: Transaction) -&gt; bool:\n        return not self.cond.evaluate(transaction)\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}(value={self.cond!r})\"\n</code></pre>"},{"location":"#luthien_control.control_policy.conditions.not_cond.NotCondition.serialize_cond","title":"<code>serialize_cond(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/not_cond.py</code> <pre><code>@field_serializer(\"cond\")\ndef serialize_cond(self, value: Condition) -&gt; dict:\n    \"\"\"Custom serializer for cond field.\"\"\"\n    return value.serialize()\n</code></pre> <p>Custom serializer for cond field.</p>"},{"location":"#luthien_control.control_policy.conditions.not_cond.NotCondition.validate_cond","title":"<code>validate_cond(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/not_cond.py</code> <pre><code>@field_validator(\"cond\", mode=\"before\")\n@classmethod\ndef validate_cond(cls, value):\n    \"\"\"Custom validator to deserialize condition from dict.\"\"\"\n    if isinstance(value, dict):\n        return Condition.from_serialized(value)\n    return value\n</code></pre> <p>Custom validator to deserialize condition from dict.</p>"},{"location":"#luthien_control.control_policy.conditions.util","title":"<code>util</code>","text":""},{"location":"#luthien_control.control_policy.conditions.util.get_transaction_value","title":"<code>get_transaction_value(transaction, path)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/util.py</code> <pre><code>def get_transaction_value(transaction: Transaction, path: str) -&gt; Any:\n    \"\"\"Get a value from the transaction using a path.\n\n    Args:\n        transaction: The transaction.\n        path: The path to the value e.g. \"request.payload.model\", \"response.payload.choices\", \"data.user_id\".\n\n    Returns:\n        The value at the path.\n\n    Raises:\n        ValueError: If the path is invalid or the value cannot be accessed.\n    \"\"\"\n    vals = path.split(\".\")\n    if len(vals) &lt; 2:\n        raise ValueError(\"Path must contain at least two components\")\n\n    x: Any = getattr(transaction, vals.pop(0))\n    while vals:\n        key = vals.pop(0)\n\n        # Try dict-like access first (includes EventedDict)\n        if hasattr(x, \"__getitem__\") and (isinstance(x, dict) or hasattr(x, \"keys\")):\n            try:\n                x = x[key]\n                continue\n            except (KeyError, TypeError):\n                pass\n\n        # Try attribute access\n        if hasattr(x, key):\n            x = getattr(x, key)\n        else:\n            # Try accessing as index for list-like objects\n            try:\n                x = x[int(key)]\n            except (ValueError, TypeError, IndexError):\n                raise AttributeError(f\"Cannot access '{key}' on {type(x).__name__}\")\n    return x\n</code></pre> <p>Get a value from the transaction using a path.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The transaction.</p> required <code>path</code> <code>str</code> <p>The path to the value e.g. \"request.payload.model\", \"response.payload.choices\", \"data.user_id\".</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value at the path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is invalid or the value cannot be accessed.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers","title":"<code>value_resolvers</code>","text":""},{"location":"#luthien_control.control_policy.conditions.value_resolvers.StaticValue","title":"<code>StaticValue</code>","text":"<p>           Bases: <code>ValueResolver</code></p> Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>class StaticValue(ValueResolver):\n    \"\"\"\n    A static value that doesn't depend on the transaction.\n    \"\"\"\n\n    type: Literal[\"static\"] = Field(default=\"static\")\n    value: Any = Field(...)\n\n    def resolve(self, transaction: Transaction) -&gt; Any:\n        \"\"\"Return the static value.\"\"\"\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        return f\"StaticValue(value={self.value!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another StaticValue.\"\"\"\n        return isinstance(other, StaticValue) and self.value == other.value\n</code></pre> <p>A static value that doesn't depend on the transaction.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.StaticValue.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another StaticValue.\"\"\"\n    return isinstance(other, StaticValue) and self.value == other.value\n</code></pre> <p>Check equality with another StaticValue.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.StaticValue.resolve","title":"<code>resolve(transaction)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def resolve(self, transaction: Transaction) -&gt; Any:\n    \"\"\"Return the static value.\"\"\"\n    return self.value\n</code></pre> <p>Return the static value.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.TransactionPath","title":"<code>TransactionPath</code>","text":"<p>           Bases: <code>ValueResolver</code></p> Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>class TransactionPath(ValueResolver):\n    \"\"\"\n    A value resolver that extracts a value from a transaction using a path.\n    \"\"\"\n\n    type: Literal[\"transaction_path\"] = Field(default=\"transaction_path\")\n    path: str = Field(...)\n\n    def resolve(self, transaction: Transaction) -&gt; Any:\n        \"\"\"Resolve the value from the transaction using the path.\"\"\"\n        try:\n            return get_transaction_value(transaction, self.path)\n        except (AttributeError, ValueError):\n            return None\n\n    def __repr__(self) -&gt; str:\n        return f\"TransactionPath(path={self.path!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another TransactionPath.\"\"\"\n        return isinstance(other, TransactionPath) and self.path == other.path\n</code></pre> <p>A value resolver that extracts a value from a transaction using a path.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.TransactionPath.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another TransactionPath.\"\"\"\n    return isinstance(other, TransactionPath) and self.path == other.path\n</code></pre> <p>Check equality with another TransactionPath.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.TransactionPath.resolve","title":"<code>resolve(transaction)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def resolve(self, transaction: Transaction) -&gt; Any:\n    \"\"\"Resolve the value from the transaction using the path.\"\"\"\n    try:\n        return get_transaction_value(transaction, self.path)\n    except (AttributeError, ValueError):\n        return None\n</code></pre> <p>Resolve the value from the transaction using the path.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.ValueResolver","title":"<code>ValueResolver</code>","text":"<p>           Bases: <code>BaseModel</code>, <code>ABC</code></p> Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>class ValueResolver(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for resolving values from transactions.\n    \"\"\"\n\n    type: Any = Field(default=\"\")  # Allow any string type including Literal types\n\n    @abstractmethod\n    def resolve(self, transaction: Transaction) -&gt; Any:\n        \"\"\"\n        Resolve and return a value from the transaction.\n\n        Args:\n            transaction: The transaction to resolve the value from\n\n        Returns:\n            The resolved value\n        \"\"\"\n        pass\n\n    def serialize(self) -&gt; SerializableDict:\n        \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n        return safe_model_dump(self)\n\n    @classmethod\n    def from_serialized(cls, serialized: SerializableDict) -&gt; \"ValueResolver\":\n        \"\"\"\n        Create a value resolver from a serialized dictionary.\n\n        Args:\n            serialized: The serialized representation\n\n        Returns:\n            A ValueResolver instance\n        \"\"\"\n        return safe_model_validate(cls, serialized)\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre> <p>Abstract base class for resolving values from transactions.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.ValueResolver.from_serialized","title":"<code>from_serialized(serialized)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>@classmethod\ndef from_serialized(cls, serialized: SerializableDict) -&gt; \"ValueResolver\":\n    \"\"\"\n    Create a value resolver from a serialized dictionary.\n\n    Args:\n        serialized: The serialized representation\n\n    Returns:\n        A ValueResolver instance\n    \"\"\"\n    return safe_model_validate(cls, serialized)\n</code></pre> <p>Create a value resolver from a serialized dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializableDict</code> <p>The serialized representation</p> required <p>Returns:</p> Type Description <code>ValueResolver</code> <p>A ValueResolver instance</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.ValueResolver.resolve","title":"<code>resolve(transaction)</code>  <code>abstractmethod</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>@abstractmethod\ndef resolve(self, transaction: Transaction) -&gt; Any:\n    \"\"\"\n    Resolve and return a value from the transaction.\n\n    Args:\n        transaction: The transaction to resolve the value from\n\n    Returns:\n        The resolved value\n    \"\"\"\n    pass\n</code></pre> <p>Resolve and return a value from the transaction.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The transaction to resolve the value from</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The resolved value</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.ValueResolver.serialize","title":"<code>serialize()</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def serialize(self) -&gt; SerializableDict:\n    \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n    return safe_model_dump(self)\n</code></pre> <p>Serialize using Pydantic model_dump through SerializableDict validation.</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.auto_resolve_value","title":"<code>auto_resolve_value(value)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def auto_resolve_value(value: Any) -&gt; ValueResolver:\n    \"\"\"\n    Automatically convert a value to an appropriate ValueResolver.\n\n    Args:\n        value: Either a static value or a ValueResolver instance\n\n    Returns:\n        A ValueResolver instance\n    \"\"\"\n    if isinstance(value, ValueResolver):\n        return value\n    else:\n        return StaticValue(value=value)\n</code></pre> <p>Automatically convert a value to an appropriate ValueResolver.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Either a static value or a ValueResolver instance</p> required <p>Returns:</p> Type Description <code>ValueResolver</code> <p>A ValueResolver instance</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.create_value_resolver","title":"<code>create_value_resolver(serialized)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def create_value_resolver(serialized: SerializableDict) -&gt; ValueResolver:\n    \"\"\"\n    Create a value resolver from serialized data.\n\n    Args:\n        serialized: The serialized value resolver data\n\n    Returns:\n        A ValueResolver instance\n\n    Raises:\n        ValueError: If the resolver type is unknown\n        KeyError: If the type field is missing\n    \"\"\"\n    resolver_type = serialized.get(\"type\")\n    if resolver_type not in VALUE_RESOLVER_REGISTRY:\n        raise ValueError(f\"Unknown value resolver type: {resolver_type}\")\n\n    resolver_class = VALUE_RESOLVER_REGISTRY[resolver_type]\n    return safe_model_validate(resolver_class, serialized)\n</code></pre> <p>Create a value resolver from serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializableDict</code> <p>The serialized value resolver data</p> required <p>Returns:</p> Type Description <code>ValueResolver</code> <p>A ValueResolver instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the resolver type is unknown</p> <code>KeyError</code> <p>If the type field is missing</p>"},{"location":"#luthien_control.control_policy.conditions.value_resolvers.path","title":"<code>path(transaction_path)</code>","text":"Source code in <code>luthien_control/control_policy/conditions/value_resolvers.py</code> <pre><code>def path(transaction_path: str) -&gt; TransactionPath:\n    \"\"\"\n    Convenience function to create a TransactionPath.\n\n    Args:\n        transaction_path: The path to the value in the transaction\n\n    Returns:\n        A TransactionPath instance\n\n    Example:\n        path(\"request.payload.model\")\n    \"\"\"\n    return TransactionPath(path=transaction_path)\n</code></pre> <p>Convenience function to create a TransactionPath.</p> <p>Parameters:</p> Name Type Description Default <code>transaction_path</code> <code>str</code> <p>The path to the value in the transaction</p> required <p>Returns:</p> Type Description <code>TransactionPath</code> <p>A TransactionPath instance</p> Example <p>path(\"request.payload.model\")</p>"},{"location":"#luthien_control.control_policy.control_policy","title":"<code>control_policy</code>","text":""},{"location":"#luthien_control.control_policy.control_policy.ControlPolicy","title":"<code>ControlPolicy</code>","text":"<p>           Bases: <code>BaseModel</code>, <code>ABC</code></p> Source code in <code>luthien_control/control_policy/control_policy.py</code> <pre><code>class ControlPolicy(BaseModel, abc.ABC):\n    \"\"\"Abstract Base Class defining the interface for a processing step.\n\n    Attributes:\n        name (Optional[str]): An optional name for the policy instance.\n            Subclasses are expected to set this, often in their `__init__` method.\n            It's used for logging and identification purposes.\n    \"\"\"\n\n    name: Optional[str] = Field(default=None)\n    type: str = Field(default=\"\")\n    logger: logging.Logger = Field(default_factory=lambda: logging.getLogger(__name__), exclude=True)\n\n    @classmethod\n    def get_policy_type_name(cls) -&gt; str:\n        \"\"\"Get the canonical policy type name for serialization.\n\n        By default, this looks up the class in the registry to get its registered name.\n        Subclasses can override this if they need custom behavior.\n\n        Returns:\n            The policy type name used in serialization.\n        \"\"\"\n        # Import here to avoid circular imports\n        from luthien_control.control_policy.registry import POLICY_CLASS_TO_NAME\n\n        policy_type = POLICY_CLASS_TO_NAME.get(cls)\n        if policy_type is None:\n            raise ValueError(f\"{cls.__name__} is not registered in POLICY_CLASS_TO_NAME registry\")\n        return policy_type\n\n    def __init__(self, **data: Any) -&gt; None:\n        \"\"\"Initializes the ControlPolicy.\n\n        This is an abstract base class, and this constructor typically handles\n        common initialization or can be overridden by subclasses.\n\n        Args:\n            **data: Arbitrary keyword arguments that subclasses might use.\n        \"\"\"\n        if \"type\" not in data:\n            data[\"type\"] = self.get_policy_type_name()\n        super().__init__(**data)\n\n    @abc.abstractmethod\n    async def apply(\n        self,\n        transaction: \"Transaction\",\n        container: \"DependencyContainer\",\n        session: \"AsyncSession\",\n    ) -&gt; \"Transaction\":\n        \"\"\"\n        Apply the policy to the transaction using provided dependencies.\n\n        Args:\n            transaction: The current transaction.\n            container: The dependency injection container.\n            session: The database session for the current request. We include this separately because\n                it's request-scoped rather than application-scoped.\n\n        Returns:\n            The potentially modified transaction.\n\n        Raises:\n            Exception: Processors may raise exceptions to halt the processing flow.\n        \"\"\"\n        raise NotImplementedError\n\n    def serialize(self) -&gt; SerializableDict:\n        \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n        data = self.model_dump(mode=\"python\", by_alias=True, exclude_none=True)\n        from luthien_control.control_policy.serialization import SerializableDictAdapter\n\n        return SerializableDictAdapter.validate_python(data)\n\n    # construct from serialization\n    @classmethod\n    def from_serialized(cls: Type[PolicyT], config: SerializableDict) -&gt; PolicyT:\n        \"\"\"\n        Construct a policy from a serialized configuration and optional dependencies.\n\n        This method acts as a dispatcher. It looks up the concrete policy class\n        based on the 'type' field in the config and delegates to its from_serialized method.\n\n        Args:\n            config: The policy-specific configuration dictionary. It must contain a 'type' key\n                    that maps to a registered policy type.\n            **kwargs: Additional dependencies needed for instantiation, passed to the\n                      concrete policy's from_serialized method.\n\n        Returns:\n            An instance of the concrete policy class.\n\n        Raises:\n            ValueError: If the 'type' key is missing in config or the type is not registered.\n        \"\"\"\n        # Import inside the method to break circular dependency\n        from luthien_control.control_policy.registry import POLICY_NAME_TO_CLASS\n\n        config_copy = dict(config)\n\n        policy_type_name_val = config_copy.get(\"type\")\n\n        if not policy_type_name_val and cls != ControlPolicy:\n            try:\n                inferred_type = cls.get_policy_type_name()\n                config_copy[\"type\"] = inferred_type\n                policy_type_name_val = inferred_type\n            except ValueError:\n                pass\n\n        if not policy_type_name_val:\n            raise ValueError(\"Policy configuration must include a 'type' field\")\n\n        target_policy_class = POLICY_NAME_TO_CLASS.get(str(policy_type_name_val))\n        if not target_policy_class:\n            raise ValueError(\n                f\"Unknown policy type '{policy_type_name_val}'. Ensure it is registered in POLICY_NAME_TO_CLASS.\"\n            )\n\n        return cast(PolicyT, safe_model_validate(target_policy_class, config_copy))\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre> <p>Abstract Base Class defining the interface for a processing step.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>An optional name for the policy instance. Subclasses are expected to set this, often in their <code>__init__</code> method. It's used for logging and identification purposes.</p>"},{"location":"#luthien_control.control_policy.control_policy.ControlPolicy.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>luthien_control/control_policy/control_policy.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    \"\"\"Initializes the ControlPolicy.\n\n    This is an abstract base class, and this constructor typically handles\n    common initialization or can be overridden by subclasses.\n\n    Args:\n        **data: Arbitrary keyword arguments that subclasses might use.\n    \"\"\"\n    if \"type\" not in data:\n        data[\"type\"] = self.get_policy_type_name()\n    super().__init__(**data)\n</code></pre> <p>Initializes the ControlPolicy.</p> <p>This is an abstract base class, and this constructor typically handles common initialization or can be overridden by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>Arbitrary keyword arguments that subclasses might use.</p> <code>{}</code>"},{"location":"#luthien_control.control_policy.control_policy.ControlPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>abstractmethod</code> <code>async</code>","text":"Source code in <code>luthien_control/control_policy/control_policy.py</code> <pre><code>@abc.abstractmethod\nasync def apply(\n    self,\n    transaction: \"Transaction\",\n    container: \"DependencyContainer\",\n    session: \"AsyncSession\",\n) -&gt; \"Transaction\":\n    \"\"\"\n    Apply the policy to the transaction using provided dependencies.\n\n    Args:\n        transaction: The current transaction.\n        container: The dependency injection container.\n        session: The database session for the current request. We include this separately because\n            it's request-scoped rather than application-scoped.\n\n    Returns:\n        The potentially modified transaction.\n\n    Raises:\n        Exception: Processors may raise exceptions to halt the processing flow.\n    \"\"\"\n    raise NotImplementedError\n</code></pre> <p>Apply the policy to the transaction using provided dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The dependency injection container.</p> required <code>session</code> <code>AsyncSession</code> <p>The database session for the current request. We include this separately because it's request-scoped rather than application-scoped.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The potentially modified transaction.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Processors may raise exceptions to halt the processing flow.</p>"},{"location":"#luthien_control.control_policy.control_policy.ControlPolicy.from_serialized","title":"<code>from_serialized(config)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/control_policy.py</code> <pre><code>@classmethod\ndef from_serialized(cls: Type[PolicyT], config: SerializableDict) -&gt; PolicyT:\n    \"\"\"\n    Construct a policy from a serialized configuration and optional dependencies.\n\n    This method acts as a dispatcher. It looks up the concrete policy class\n    based on the 'type' field in the config and delegates to its from_serialized method.\n\n    Args:\n        config: The policy-specific configuration dictionary. It must contain a 'type' key\n                that maps to a registered policy type.\n        **kwargs: Additional dependencies needed for instantiation, passed to the\n                  concrete policy's from_serialized method.\n\n    Returns:\n        An instance of the concrete policy class.\n\n    Raises:\n        ValueError: If the 'type' key is missing in config or the type is not registered.\n    \"\"\"\n    # Import inside the method to break circular dependency\n    from luthien_control.control_policy.registry import POLICY_NAME_TO_CLASS\n\n    config_copy = dict(config)\n\n    policy_type_name_val = config_copy.get(\"type\")\n\n    if not policy_type_name_val and cls != ControlPolicy:\n        try:\n            inferred_type = cls.get_policy_type_name()\n            config_copy[\"type\"] = inferred_type\n            policy_type_name_val = inferred_type\n        except ValueError:\n            pass\n\n    if not policy_type_name_val:\n        raise ValueError(\"Policy configuration must include a 'type' field\")\n\n    target_policy_class = POLICY_NAME_TO_CLASS.get(str(policy_type_name_val))\n    if not target_policy_class:\n        raise ValueError(\n            f\"Unknown policy type '{policy_type_name_val}'. Ensure it is registered in POLICY_NAME_TO_CLASS.\"\n        )\n\n    return cast(PolicyT, safe_model_validate(target_policy_class, config_copy))\n</code></pre> <p>Construct a policy from a serialized configuration and optional dependencies.</p> <p>This method acts as a dispatcher. It looks up the concrete policy class based on the 'type' field in the config and delegates to its from_serialized method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SerializableDict</code> <p>The policy-specific configuration dictionary. It must contain a 'type' key     that maps to a registered policy type.</p> required <code>**kwargs</code> <p>Additional dependencies needed for instantiation, passed to the       concrete policy's from_serialized method.</p> required <p>Returns:</p> Type Description <code>PolicyT</code> <p>An instance of the concrete policy class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'type' key is missing in config or the type is not registered.</p>"},{"location":"#luthien_control.control_policy.control_policy.ControlPolicy.get_policy_type_name","title":"<code>get_policy_type_name()</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/control_policy.py</code> <pre><code>@classmethod\ndef get_policy_type_name(cls) -&gt; str:\n    \"\"\"Get the canonical policy type name for serialization.\n\n    By default, this looks up the class in the registry to get its registered name.\n    Subclasses can override this if they need custom behavior.\n\n    Returns:\n        The policy type name used in serialization.\n    \"\"\"\n    # Import here to avoid circular imports\n    from luthien_control.control_policy.registry import POLICY_CLASS_TO_NAME\n\n    policy_type = POLICY_CLASS_TO_NAME.get(cls)\n    if policy_type is None:\n        raise ValueError(f\"{cls.__name__} is not registered in POLICY_CLASS_TO_NAME registry\")\n    return policy_type\n</code></pre> <p>Get the canonical policy type name for serialization.</p> <p>By default, this looks up the class in the registry to get its registered name. Subclasses can override this if they need custom behavior.</p> <p>Returns:</p> Type Description <code>str</code> <p>The policy type name used in serialization.</p>"},{"location":"#luthien_control.control_policy.control_policy.ControlPolicy.serialize","title":"<code>serialize()</code>","text":"Source code in <code>luthien_control/control_policy/control_policy.py</code> <pre><code>def serialize(self) -&gt; SerializableDict:\n    \"\"\"Serialize using Pydantic model_dump through SerializableDict validation.\"\"\"\n    data = self.model_dump(mode=\"python\", by_alias=True, exclude_none=True)\n    from luthien_control.control_policy.serialization import SerializableDictAdapter\n\n    return SerializableDictAdapter.validate_python(data)\n</code></pre> <p>Serialize using Pydantic model_dump through SerializableDict validation.</p>"},{"location":"#luthien_control.control_policy.exceptions","title":"<code>exceptions</code>","text":""},{"location":"#luthien_control.control_policy.exceptions.ApiKeyNotFoundError","title":"<code>ApiKeyNotFoundError</code>","text":"<p>           Bases: <code>ControlPolicyError</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class ApiKeyNotFoundError(ControlPolicyError):\n    \"\"\"Exception raised when the API key is not found in the settings.\"\"\"\n\n    def __init__(self, detail: str, status_code: int = 500):\n        \"\"\"Initializes the ApiKeyNotFoundError.\n\n        Args:\n            detail (str): A detailed error message explaining the missing API key.\n            status_code (int): The HTTP status code to associate with this error.\n                               Defaults to 500 (Internal Server Error).\n        \"\"\"\n        super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Exception raised when the API key is not found in the settings.</p>"},{"location":"#luthien_control.control_policy.exceptions.ApiKeyNotFoundError.__init__","title":"<code>__init__(detail, status_code=500)</code>","text":"Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>def __init__(self, detail: str, status_code: int = 500):\n    \"\"\"Initializes the ApiKeyNotFoundError.\n\n    Args:\n        detail (str): A detailed error message explaining the missing API key.\n        status_code (int): The HTTP status code to associate with this error.\n                           Defaults to 500 (Internal Server Error).\n    \"\"\"\n    super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Initializes the ApiKeyNotFoundError.</p> <p>Parameters:</p> Name Type Description Default <code>detail</code> <code>str</code> <p>A detailed error message explaining the missing API key.</p> required <code>status_code</code> <code>int</code> <p>The HTTP status code to associate with this error.                Defaults to 500 (Internal Server Error).</p> <code>500</code>"},{"location":"#luthien_control.control_policy.exceptions.ClientAuthenticationError","title":"<code>ClientAuthenticationError</code>","text":"<p>           Bases: <code>ControlPolicyError</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class ClientAuthenticationError(ControlPolicyError):\n    \"\"\"Exception raised when client API key authentication fails.\"\"\"\n\n    def __init__(self, detail: str, status_code: int = 401):\n        \"\"\"Initializes the ClientAuthenticationError.\n\n        Args:\n            detail (str): A detailed error message explaining the authentication failure.\n            status_code (int): The HTTP status code to associate with this error.\n                               Defaults to 401 (Unauthorized).\n        \"\"\"\n        # Pass detail positionally for Exception.__str__ and keywords for ControlPolicyError attributes\n        super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Exception raised when client API key authentication fails.</p>"},{"location":"#luthien_control.control_policy.exceptions.ClientAuthenticationError.__init__","title":"<code>__init__(detail, status_code=401)</code>","text":"Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>def __init__(self, detail: str, status_code: int = 401):\n    \"\"\"Initializes the ClientAuthenticationError.\n\n    Args:\n        detail (str): A detailed error message explaining the authentication failure.\n        status_code (int): The HTTP status code to associate with this error.\n                           Defaults to 401 (Unauthorized).\n    \"\"\"\n    # Pass detail positionally for Exception.__str__ and keywords for ControlPolicyError attributes\n    super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Initializes the ClientAuthenticationError.</p> <p>Parameters:</p> Name Type Description Default <code>detail</code> <code>str</code> <p>A detailed error message explaining the authentication failure.</p> required <code>status_code</code> <code>int</code> <p>The HTTP status code to associate with this error.                Defaults to 401 (Unauthorized).</p> <code>401</code>"},{"location":"#luthien_control.control_policy.exceptions.ClientAuthenticationNotFoundError","title":"<code>ClientAuthenticationNotFoundError</code>","text":"<p>           Bases: <code>ControlPolicyError</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class ClientAuthenticationNotFoundError(ControlPolicyError):\n    \"\"\"Exception raised when the client API key is not found in the request.\"\"\"\n\n    def __init__(self, detail: str, status_code: int = 401):\n        \"\"\"Initializes the ClientAuthenticationNotFoundError.\n\n        Args:\n            detail (str): A detailed error message explaining why the key was not found.\n            status_code (int): The HTTP status code to associate with this error.\n                               Defaults to 401 (Unauthorized).\n        \"\"\"\n        # Pass detail positionally for Exception.__str__ and keywords for ControlPolicyError attributes\n        super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Exception raised when the client API key is not found in the request.</p>"},{"location":"#luthien_control.control_policy.exceptions.ClientAuthenticationNotFoundError.__init__","title":"<code>__init__(detail, status_code=401)</code>","text":"Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>def __init__(self, detail: str, status_code: int = 401):\n    \"\"\"Initializes the ClientAuthenticationNotFoundError.\n\n    Args:\n        detail (str): A detailed error message explaining why the key was not found.\n        status_code (int): The HTTP status code to associate with this error.\n                           Defaults to 401 (Unauthorized).\n    \"\"\"\n    # Pass detail positionally for Exception.__str__ and keywords for ControlPolicyError attributes\n    super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Initializes the ClientAuthenticationNotFoundError.</p> <p>Parameters:</p> Name Type Description Default <code>detail</code> <code>str</code> <p>A detailed error message explaining why the key was not found.</p> required <code>status_code</code> <code>int</code> <p>The HTTP status code to associate with this error.                Defaults to 401 (Unauthorized).</p> <code>401</code>"},{"location":"#luthien_control.control_policy.exceptions.ControlPolicyError","title":"<code>ControlPolicyError</code>","text":"<p>           Bases: <code>LuthienException</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class ControlPolicyError(LuthienException):\n    \"\"\"Base exception for all control policy errors.\n\n    Attributes:\n        policy_name (Optional[str]): The name of the policy where the error\n            occurred, if specified.\n        status_code (Optional[int]): An HTTP status code associated with this\n            error, if specified.\n        detail (Optional[str]): A detailed error message. If not provided directly\n            during initialization but other arguments are, the first positional\n            argument is used as the detail.\n    \"\"\"\n\n    def __init__(\n        self, *args, policy_name: str | None = None, status_code: int | None = None, detail: str | None = None\n    ):\n        \"\"\"Initializes the ControlPolicyError.\n\n        Args:\n            *args: Arguments passed to the base Exception class.\n            policy_name (Optional[str]): The name of the policy where the error occurred.\n            status_code (Optional[int]): An HTTP status code associated with this error.\n            detail (Optional[str]): A detailed error message. If not provided and `args`\n                                    is not empty, the first argument in `args` is used.\n        \"\"\"\n        super().__init__(*args)\n        self.policy_name = policy_name\n        self.status_code = status_code\n        # Use the first arg as detail if detail kwarg is not provided and args exist\n        self.detail = detail or (args[0] if args else None)\n</code></pre> <p>Base exception for all control policy errors.</p> <p>Attributes:</p> Name Type Description <code>policy_name</code> <code>Optional[str]</code> <p>The name of the policy where the error occurred, if specified.</p> <code>status_code</code> <code>Optional[int]</code> <p>An HTTP status code associated with this error, if specified.</p> <code>detail</code> <code>Optional[str]</code> <p>A detailed error message. If not provided directly during initialization but other arguments are, the first positional argument is used as the detail.</p>"},{"location":"#luthien_control.control_policy.exceptions.ControlPolicyError.__init__","title":"<code>__init__(*args, policy_name=None, status_code=None, detail=None)</code>","text":"Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>def __init__(\n    self, *args, policy_name: str | None = None, status_code: int | None = None, detail: str | None = None\n):\n    \"\"\"Initializes the ControlPolicyError.\n\n    Args:\n        *args: Arguments passed to the base Exception class.\n        policy_name (Optional[str]): The name of the policy where the error occurred.\n        status_code (Optional[int]): An HTTP status code associated with this error.\n        detail (Optional[str]): A detailed error message. If not provided and `args`\n                                is not empty, the first argument in `args` is used.\n    \"\"\"\n    super().__init__(*args)\n    self.policy_name = policy_name\n    self.status_code = status_code\n    # Use the first arg as detail if detail kwarg is not provided and args exist\n    self.detail = detail or (args[0] if args else None)\n</code></pre> <p>Initializes the ControlPolicyError.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to the base Exception class.</p> <code>()</code> <code>policy_name</code> <code>Optional[str]</code> <p>The name of the policy where the error occurred.</p> <code>None</code> <code>status_code</code> <code>Optional[int]</code> <p>An HTTP status code associated with this error.</p> <code>None</code> <code>detail</code> <code>Optional[str]</code> <p>A detailed error message. If not provided and <code>args</code>                     is not empty, the first argument in <code>args</code> is used.</p> <code>None</code>"},{"location":"#luthien_control.control_policy.exceptions.LeakedApiKeyError","title":"<code>LeakedApiKeyError</code>","text":"<p>           Bases: <code>ControlPolicyError</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class LeakedApiKeyError(ControlPolicyError):\n    \"\"\"Exception raised when a leaked API key is detected.\"\"\"\n\n    def __init__(self, detail: str, status_code: int = 403):\n        \"\"\"Initializes the LeakedApiKeyError.\n\n        Args:\n            detail (str): A detailed error message explaining the leaked key detection.\n            status_code (int): The HTTP status code to associate with this error.\n                               Defaults to 403 (Forbidden).\n        \"\"\"\n        # Pass detail positionally for Exception.__str__ and keywords for ControlPolicyError attributes\n        super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Exception raised when a leaked API key is detected.</p>"},{"location":"#luthien_control.control_policy.exceptions.LeakedApiKeyError.__init__","title":"<code>__init__(detail, status_code=403)</code>","text":"Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>def __init__(self, detail: str, status_code: int = 403):\n    \"\"\"Initializes the LeakedApiKeyError.\n\n    Args:\n        detail (str): A detailed error message explaining the leaked key detection.\n        status_code (int): The HTTP status code to associate with this error.\n                           Defaults to 403 (Forbidden).\n    \"\"\"\n    # Pass detail positionally for Exception.__str__ and keywords for ControlPolicyError attributes\n    super().__init__(detail, status_code=status_code, detail=detail)\n</code></pre> <p>Initializes the LeakedApiKeyError.</p> <p>Parameters:</p> Name Type Description Default <code>detail</code> <code>str</code> <p>A detailed error message explaining the leaked key detection.</p> required <code>status_code</code> <code>int</code> <p>The HTTP status code to associate with this error.                Defaults to 403 (Forbidden).</p> <code>403</code>"},{"location":"#luthien_control.control_policy.exceptions.NoRequestError","title":"<code>NoRequestError</code>","text":"<p>           Bases: <code>ControlPolicyError</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class NoRequestError(ControlPolicyError):\n    \"\"\"Exception raised when the request object is not found in the context.\"\"\"\n\n    pass\n</code></pre> <p>Exception raised when the request object is not found in the context.</p>"},{"location":"#luthien_control.control_policy.exceptions.PolicyLoadError","title":"<code>PolicyLoadError</code>","text":"<p>           Bases: <code>ValueError</code>, <code>ControlPolicyError</code></p> Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>class PolicyLoadError(ValueError, ControlPolicyError):\n    \"\"\"Custom exception for errors during policy loading/instantiation.\"\"\"\n\n    # Inherit from ValueError for semantic meaning (bad value/config)\n    # Inherit from ControlPolicyError for categorization\n    def __init__(\n        self, *args, policy_name: str | None = None, status_code: int | None = None, detail: str | None = None\n    ):\n        \"\"\"Initializes the PolicyLoadError.\n\n        Args:\n            *args: Arguments passed to the base Exception class.\n            policy_name (Optional[str]): The name of the policy that failed to load.\n            status_code (Optional[int]): An HTTP status code associated with this error.\n            detail (Optional[str]): A detailed error message. If not provided and `args`\n                                    is not empty, the first argument in `args` is used.\n        \"\"\"\n        # Explicitly call ControlPolicyError.__init__ to handle kwargs\n        ControlPolicyError.__init__(self, *args, policy_name=policy_name, status_code=status_code, detail=detail)\n</code></pre> <p>Custom exception for errors during policy loading/instantiation.</p>"},{"location":"#luthien_control.control_policy.exceptions.PolicyLoadError.__init__","title":"<code>__init__(*args, policy_name=None, status_code=None, detail=None)</code>","text":"Source code in <code>luthien_control/control_policy/exceptions.py</code> <pre><code>def __init__(\n    self, *args, policy_name: str | None = None, status_code: int | None = None, detail: str | None = None\n):\n    \"\"\"Initializes the PolicyLoadError.\n\n    Args:\n        *args: Arguments passed to the base Exception class.\n        policy_name (Optional[str]): The name of the policy that failed to load.\n        status_code (Optional[int]): An HTTP status code associated with this error.\n        detail (Optional[str]): A detailed error message. If not provided and `args`\n                                is not empty, the first argument in `args` is used.\n    \"\"\"\n    # Explicitly call ControlPolicyError.__init__ to handle kwargs\n    ControlPolicyError.__init__(self, *args, policy_name=policy_name, status_code=status_code, detail=detail)\n</code></pre> <p>Initializes the PolicyLoadError.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to the base Exception class.</p> <code>()</code> <code>policy_name</code> <code>Optional[str]</code> <p>The name of the policy that failed to load.</p> <code>None</code> <code>status_code</code> <code>Optional[int]</code> <p>An HTTP status code associated with this error.</p> <code>None</code> <code>detail</code> <code>Optional[str]</code> <p>A detailed error message. If not provided and <code>args</code>                     is not empty, the first argument in <code>args</code> is used.</p> <code>None</code>"},{"location":"#luthien_control.control_policy.leaked_api_key_detection","title":"<code>leaked_api_key_detection</code>","text":"<p>Control Policy for detecting leaked API keys in LLM message content.</p> <p>This policy inspects the 'messages' field in request bodies to prevent sensitive API keys from being sent to language models.</p>"},{"location":"#luthien_control.control_policy.leaked_api_key_detection.LeakedApiKeyDetectionPolicy","title":"<code>LeakedApiKeyDetectionPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/leaked_api_key_detection.py</code> <pre><code>class LeakedApiKeyDetectionPolicy(ControlPolicy):\n    \"\"\"Detects API keys that might be leaked in message content sent to LLMs.\n\n    This policy scans message content for patterns matching common API key formats\n    to prevent accidental exposure of sensitive credentials to language models.\n    \"\"\"\n\n    # Common API key patterns\n    DEFAULT_PATTERNS: ClassVar[List[str]] = [\n        r\"sk-[a-zA-Z0-9]{48}\",  # OpenAI API key pattern\n        r\"xoxb-[a-zA-Z0-9\\-]{50,}\",  # Slack bot token pattern\n        r\"github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59}\",  # GitHub PAT pattern\n    ]\n\n    name: Optional[str] = Field(default_factory=lambda: \"LeakedApiKeyDetectionPolicy\")\n    patterns: List[str] = Field(default_factory=lambda: LeakedApiKeyDetectionPolicy.DEFAULT_PATTERNS)\n    compiled_patterns: List[re.Pattern] = Field(default_factory=list, exclude=True)\n\n    @field_validator(\"patterns\", mode=\"before\")\n    @classmethod\n    def validate_patterns(cls, value):\n        \"\"\"Handle patterns validation and fallback to defaults for empty lists.\"\"\"\n        if value is None or (isinstance(value, list) and not value):\n            return cls.DEFAULT_PATTERNS\n        return value\n\n    @model_validator(mode=\"after\")\n    def compile_patterns(self):\n        \"\"\"Compile regex patterns after validation.\"\"\"\n        self.compiled_patterns = [re.compile(pattern) for pattern in self.patterns]\n        return self\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Checks message content for potentially leaked API keys.\n\n        Args:\n            transaction: The current transaction.\n            container: The application dependency container.\n            session: An active SQLAlchemy AsyncSession.\n\n        Returns:\n            The transaction, potentially with an error response set.\n\n        Raises:\n            NoRequestError: If the request is not found in the transaction.\n            LeakedApiKeyError: If a potential API key is detected in message content.\n        \"\"\"\n        if transaction.request is None:\n            raise NoRequestError(\"No request in transaction.\")\n\n        self.logger.info(f\"Checking for leaked API keys in message content ({self.name}).\")\n\n        if hasattr(transaction.request.payload, \"messages\"):\n            messages = transaction.request.payload.messages\n\n            # Inspect each message's content\n            for message in messages:\n                if hasattr(message, \"content\") and isinstance(message.content, str):\n                    content = message.content\n                    if self._check_text(content):\n                        error_message = (\n                            \"Potential API key detected in message content. For security, the request has been blocked.\"\n                        )\n                        self.logger.warning(f\"{error_message} ({self.name})\")\n                        raise LeakedApiKeyError(detail=error_message)\n\n        return transaction\n\n    def _check_text(self, text: str) -&gt; bool:\n        \"\"\"\n        Checks if the given text contains any patterns matching potential API keys.\n\n        Args:\n            text: The text to check.\n\n        Returns:\n            True if a potential API key is found, False otherwise.\n        \"\"\"\n        for pattern in self.compiled_patterns:\n            if pattern.search(text):\n                return True\n        return False\n</code></pre> <p>Detects API keys that might be leaked in message content sent to LLMs.</p> <p>This policy scans message content for patterns matching common API key formats to prevent accidental exposure of sensitive credentials to language models.</p>"},{"location":"#luthien_control.control_policy.leaked_api_key_detection.LeakedApiKeyDetectionPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/leaked_api_key_detection.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Checks message content for potentially leaked API keys.\n\n    Args:\n        transaction: The current transaction.\n        container: The application dependency container.\n        session: An active SQLAlchemy AsyncSession.\n\n    Returns:\n        The transaction, potentially with an error response set.\n\n    Raises:\n        NoRequestError: If the request is not found in the transaction.\n        LeakedApiKeyError: If a potential API key is detected in message content.\n    \"\"\"\n    if transaction.request is None:\n        raise NoRequestError(\"No request in transaction.\")\n\n    self.logger.info(f\"Checking for leaked API keys in message content ({self.name}).\")\n\n    if hasattr(transaction.request.payload, \"messages\"):\n        messages = transaction.request.payload.messages\n\n        # Inspect each message's content\n        for message in messages:\n            if hasattr(message, \"content\") and isinstance(message.content, str):\n                content = message.content\n                if self._check_text(content):\n                    error_message = (\n                        \"Potential API key detected in message content. For security, the request has been blocked.\"\n                    )\n                    self.logger.warning(f\"{error_message} ({self.name})\")\n                    raise LeakedApiKeyError(detail=error_message)\n\n    return transaction\n</code></pre> <p>Checks message content for potentially leaked API keys.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The transaction, potentially with an error response set.</p> <p>Raises:</p> Type Description <code>NoRequestError</code> <p>If the request is not found in the transaction.</p> <code>LeakedApiKeyError</code> <p>If a potential API key is detected in message content.</p>"},{"location":"#luthien_control.control_policy.leaked_api_key_detection.LeakedApiKeyDetectionPolicy.compile_patterns","title":"<code>compile_patterns()</code>","text":"Source code in <code>luthien_control/control_policy/leaked_api_key_detection.py</code> <pre><code>@model_validator(mode=\"after\")\ndef compile_patterns(self):\n    \"\"\"Compile regex patterns after validation.\"\"\"\n    self.compiled_patterns = [re.compile(pattern) for pattern in self.patterns]\n    return self\n</code></pre> <p>Compile regex patterns after validation.</p>"},{"location":"#luthien_control.control_policy.leaked_api_key_detection.LeakedApiKeyDetectionPolicy.validate_patterns","title":"<code>validate_patterns(value)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/leaked_api_key_detection.py</code> <pre><code>@field_validator(\"patterns\", mode=\"before\")\n@classmethod\ndef validate_patterns(cls, value):\n    \"\"\"Handle patterns validation and fallback to defaults for empty lists.\"\"\"\n    if value is None or (isinstance(value, list) and not value):\n        return cls.DEFAULT_PATTERNS\n    return value\n</code></pre> <p>Handle patterns validation and fallback to defaults for empty lists.</p>"},{"location":"#luthien_control.control_policy.loader","title":"<code>loader</code>","text":""},{"location":"#luthien_control.control_policy.loader.load_policy","title":"<code>load_policy(serialized_policy)</code>","text":"Source code in <code>luthien_control/control_policy/loader.py</code> <pre><code>def load_policy(serialized_policy: SerializedPolicy) -&gt; \"ControlPolicy\":\n    \"\"\"\n    Loads a ControlPolicy instance from a dictionary containing its name and config,\n    injecting required dependencies.\n\n    Args:\n        serialized_policy: A SerializedPolicy object.\n\n    Returns:\n        An instantiated ControlPolicy object.\n\n    Raises:\n        PolicyLoadError: If the policy name is unknown, data is missing/malformed,\n                         or a required dependency is not provided.\n        Exception: Potentially from the policy's from_serialized method if config is invalid.\n    \"\"\"\n    # Import the policy registry here to avoid circular import\n    from .registry import POLICY_NAME_TO_CLASS  # noqa: F401\n\n    logger = logging.getLogger(__name__)\n\n    policy_type = serialized_policy.type\n    policy_config = serialized_policy.config\n\n    if not isinstance(policy_type, str):\n        raise PolicyLoadError(f\"Policy 'type' must be a string, got: {type(policy_type)}\")\n    if not isinstance(policy_config, dict):\n        raise PolicyLoadError(f\"Policy 'config' must be a dictionary, got: {type(policy_config)}\")\n\n    policy_class = POLICY_NAME_TO_CLASS.get(policy_type)\n\n    # Explicitly check if the policy type was found in the registry\n    if policy_class is None:\n        raise PolicyLoadError(\n            f\"Unknown policy type: '{policy_type}'. Available policies: {list(POLICY_NAME_TO_CLASS.keys())}\"\n        )\n\n    try:\n        instance = policy_class.from_serialized(policy_config)\n        logger.info(f\"Successfully loaded policy: {getattr(instance, 'name', policy_type)}\")\n        return instance\n    except Exception as e:\n        logger.error(f\"Error instantiating policy '{policy_type}': {e}\", exc_info=True)\n        raise PolicyLoadError(f\"Error instantiating policy '{policy_type}': {e}\") from e\n</code></pre> <p>Loads a ControlPolicy instance from a dictionary containing its name and config, injecting required dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>serialized_policy</code> <code>SerializedPolicy</code> <p>A SerializedPolicy object.</p> required <p>Returns:</p> Type Description <code>ControlPolicy</code> <p>An instantiated ControlPolicy object.</p> <p>Raises:</p> Type Description <code>PolicyLoadError</code> <p>If the policy name is unknown, data is missing/malformed,              or a required dependency is not provided.</p> <code>Exception</code> <p>Potentially from the policy's from_serialized method if config is invalid.</p>"},{"location":"#luthien_control.control_policy.loader.load_policy_from_file","title":"<code>load_policy_from_file(filepath)</code>","text":"Source code in <code>luthien_control/control_policy/loader.py</code> <pre><code>def load_policy_from_file(filepath: str) -&gt; \"ControlPolicy\":\n    \"\"\"Load a policy configuration from a file and instantiate it using the control_policy loader.\"\"\"\n    with open(filepath, \"r\") as f:\n        raw_policy_data = json.load(f)\n\n    if not isinstance(raw_policy_data, dict):\n        raise PolicyLoadError(f\"Policy data loaded from {filepath} must be a dictionary, got {type(raw_policy_data)}\")\n\n    policy_type = raw_policy_data.get(\"type\")\n    policy_config = raw_policy_data.get(\"config\")\n\n    if not isinstance(policy_type, str):\n        raise PolicyLoadError(\n            f\"Policy file {filepath} must contain a 'type' field as a string. Got: {type(policy_type)}\"\n        )\n    if not isinstance(policy_config, dict):\n        raise PolicyLoadError(\n            f\"Policy file {filepath} must contain a 'config' field as a dictionary. Got: {type(policy_config)}\"\n        )\n\n    serialized_policy_obj = SerializedPolicy(type=policy_type, config=policy_config)\n    return load_policy(serialized_policy_obj)\n</code></pre> <p>Load a policy configuration from a file and instantiate it using the control_policy loader.</p>"},{"location":"#luthien_control.control_policy.model_name_replacement","title":"<code>model_name_replacement</code>","text":""},{"location":"#luthien_control.control_policy.model_name_replacement.ModelNameReplacementPolicy","title":"<code>ModelNameReplacementPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/model_name_replacement.py</code> <pre><code>class ModelNameReplacementPolicy(ControlPolicy):\n    \"\"\"Replaces model names in requests based on a configured mapping.\n\n    This policy allows clients to use fake model names that will be\n    replaced with real model names before the request is sent to the backend.\n    This is useful for services like Cursor that assume model strings that match\n    known models must route through specific endpoints.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"ModelNameReplacementPolicy\")\n    model_mapping: Dict[str, str] = Field(default_factory=dict)\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Replaces the model name in the request payload based on the configured mapping.\n\n        Args:\n            transaction: The current transaction.\n            container: The application dependency container.\n            session: An active SQLAlchemy AsyncSession (unused).\n\n        Returns:\n            The potentially modified transaction.\n\n        Raises:\n            NoRequestError: If no request is found in the transaction.\n        \"\"\"\n        if transaction.request is None:\n            raise NoRequestError(\"No request in transaction.\")\n\n        if hasattr(transaction.request.payload, \"model\"):\n            original_model = transaction.request.payload.model\n\n            if original_model in self.model_mapping:\n                new_model = self.model_mapping[original_model]\n                self.logger.info(f\"Replacing model name: {original_model} -&gt; {new_model}\")\n                transaction.request.payload.model = new_model\n\n        return transaction\n</code></pre> <p>Replaces model names in requests based on a configured mapping.</p> <p>This policy allows clients to use fake model names that will be replaced with real model names before the request is sent to the backend. This is useful for services like Cursor that assume model strings that match known models must route through specific endpoints.</p>"},{"location":"#luthien_control.control_policy.model_name_replacement.ModelNameReplacementPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/model_name_replacement.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Replaces the model name in the request payload based on the configured mapping.\n\n    Args:\n        transaction: The current transaction.\n        container: The application dependency container.\n        session: An active SQLAlchemy AsyncSession (unused).\n\n    Returns:\n        The potentially modified transaction.\n\n    Raises:\n        NoRequestError: If no request is found in the transaction.\n    \"\"\"\n    if transaction.request is None:\n        raise NoRequestError(\"No request in transaction.\")\n\n    if hasattr(transaction.request.payload, \"model\"):\n        original_model = transaction.request.payload.model\n\n        if original_model in self.model_mapping:\n            new_model = self.model_mapping[original_model]\n            self.logger.info(f\"Replacing model name: {original_model} -&gt; {new_model}\")\n            transaction.request.payload.model = new_model\n\n    return transaction\n</code></pre> <p>Replaces the model name in the request payload based on the configured mapping.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession (unused).</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The potentially modified transaction.</p> <p>Raises:</p> Type Description <code>NoRequestError</code> <p>If no request is found in the transaction.</p>"},{"location":"#luthien_control.control_policy.noop_policy","title":"<code>noop_policy</code>","text":""},{"location":"#luthien_control.control_policy.noop_policy.NoopPolicy","title":"<code>NoopPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/noop_policy.py</code> <pre><code>class NoopPolicy(ControlPolicy):\n    \"\"\"A policy that does nothing.\n\n    This is the simplest possible policy implementation. It passes through\n    the transaction unchanged and has no policy-specific configuration beyond\n    its name.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"NoopPolicy\")\n\n    async def apply(\n        self, transaction: Transaction, container: DependencyContainer, session: AsyncSession\n    ) -&gt; Transaction:\n        \"\"\"Simply returns the transaction unchanged.\"\"\"\n        return transaction\n</code></pre> <p>A policy that does nothing.</p> <p>This is the simplest possible policy implementation. It passes through the transaction unchanged and has no policy-specific configuration beyond its name.</p>"},{"location":"#luthien_control.control_policy.noop_policy.NoopPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/noop_policy.py</code> <pre><code>async def apply(\n    self, transaction: Transaction, container: DependencyContainer, session: AsyncSession\n) -&gt; Transaction:\n    \"\"\"Simply returns the transaction unchanged.\"\"\"\n    return transaction\n</code></pre> <p>Simply returns the transaction unchanged.</p>"},{"location":"#luthien_control.control_policy.send_backend_request","title":"<code>send_backend_request</code>","text":""},{"location":"#luthien_control.control_policy.send_backend_request.SendBackendRequestPolicy","title":"<code>SendBackendRequestPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/send_backend_request.py</code> <pre><code>class SendBackendRequestPolicy(ControlPolicy):\n    \"\"\"\n    Policy responsible for sending the chat completions request to the OpenAI-compatible backend\n    using the OpenAI SDK and storing the structured response.\n\n    Attributes:\n        name (str): The name of this policy instance, used for logging and\n            identification. It defaults to the class name if not provided\n            during initialization.\n        logger (logging.Logger): The logger instance for this policy.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"SendBackendRequestPolicy\")\n\n    def _create_debug_info(\n        self, backend_url: str, request_payload: Any, error: Exception, api_key: str = \"\"\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create debug information for backend request failures.\"\"\"\n        debug_info = {\n            \"backend_url\": backend_url,\n            \"request_model\": getattr(request_payload, \"model\", \"unknown\"),\n            \"request_messages_count\": len(getattr(request_payload, \"messages\", [])),\n            \"error_type\": error.__class__.__name__,\n            \"error_message\": str(error),\n        }\n\n        # Add OpenAI-specific error details if available\n        if hasattr(error, \"response\") and getattr(error, \"response\", None) is not None:\n            response = getattr(error, \"response\")\n            status_code = getattr(response, \"status_code\", None)\n            debug_info[\"backend_response\"] = {\n                \"status_code\": status_code,\n                \"headers\": dict(getattr(response, \"headers\", {})),\n            }\n            # Try to get response body if available\n            if hasattr(response, \"text\"):\n                debug_info[\"backend_response\"][\"body\"] = getattr(response, \"text\", \"\")\n\n            # For 404 errors, include identifying characters from the API key\n            if status_code == 404 and api_key:\n                debug_info[\"api_key_identifier\"] = self._get_api_key_identifier(api_key)\n\n        if hasattr(error, \"body\") and getattr(error, \"body\", None) is not None:\n            debug_info[\"backend_error_body\"] = getattr(error, \"body\")\n\n        return debug_info\n\n    def _get_api_key_identifier(self, api_key: str) -&gt; str:\n        \"\"\"Get identifying characters from API key for debugging (first 8 and last 4 chars).\"\"\"\n        if not api_key:\n            return \"empty\"\n        if len(api_key) &lt;= 12:\n            return f\"{api_key[:4]}...{api_key[-2:]}\"\n        return f\"{api_key[:8]}...{api_key[-4:]}\"\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Sends the chat completions request to the OpenAI-compatible backend using the OpenAI SDK.\n\n        This policy uses the OpenAI SDK to send the structured chat completions request\n        from transaction.request.payload to the backend API endpoint. The response\n        is stored as a structured OpenAIChatCompletionsResponse in transaction.response.payload.\n\n        Args:\n            transaction: The current transaction, containing the request payload to be sent.\n            container: The application dependency container, providing settings and OpenAI client.\n            session: An active SQLAlchemy AsyncSession. (Unused by this policy but required by the interface).\n\n        Returns:\n            The Transaction, updated with transaction.response.payload containing the\n            OpenAIChatCompletionsResponse from the backend.\n\n        Raises:\n            ValueError: If backend URL or API key is not configured.\n            openai.APIError: For API-related errors from the OpenAI backend.\n            openai.APITimeoutError: If the request to the backend times out.\n            openai.APIConnectionError: For network-related issues during the backend request.\n            Exception: For any other unexpected errors during request execution.\n        \"\"\"\n        # Create OpenAI client for the backend request\n        backend_url = transaction.request.api_endpoint\n        api_key = transaction.request.api_key\n\n        if not backend_url:\n            raise ValueError(\"Backend URL is not configured\")\n        if not api_key:\n            raise ValueError(\"OpenAI API key is not configured\")\n\n        self.logger.info(f\"Creating OpenAI client with backend URL: '{backend_url}' ({self.name})\")\n        openai_client = container.create_openai_client(backend_url, api_key)\n\n        # Get the structured request payload\n        request_payload = transaction.request.payload\n\n        self.logger.info(\n            f\"Sending chat completions request to backend with model '{request_payload.model}' \"\n            f\"and {len(request_payload.messages)} messages. ({self.name}); \"\n            f\"Target url: {backend_url}\"\n        )\n\n        try:\n            # Send request using OpenAI SDK\n            # Use the request payload directly - the OpenAI SDK should accept our Pydantic model\n            request_dict = request_payload.model_dump()\n            # Remove any None values to avoid issues with the OpenAI SDK\n            request_dict = {k: v for k, v in request_dict.items() if v is not None}\n\n            backend_response = await openai_client.chat.completions.create(**request_dict)\n\n            # Convert OpenAI SDK response to our structured response model\n            response_payload = OpenAIChatCompletionsResponse.model_validate(backend_response.model_dump())\n\n            # Store the structured response in the transaction\n            transaction.response.payload = response_payload\n            transaction.response.api_endpoint = backend_url\n\n            self.logger.info(\n                f\"Received backend response with {len(response_payload.choices)} choices \"\n                f\"and usage: {response_payload.usage}. ({self.name})\"\n            )\n\n        except openai.APITimeoutError as e:\n            self.logger.error(f\"Timeout error during backend request: {e} ({self.name})\")\n            # Store debug information for potential dev mode access\n            debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n            e.debug_info = debug_info  # type: ignore\n            raise\n        except openai.APIConnectionError as e:\n            self.logger.error(f\"Connection error during backend request: {e} ({self.name})\")\n            # Store debug information for potential dev mode access\n            debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n            e.debug_info = debug_info  # type: ignore\n            raise\n        except openai.APIError as e:\n            self.logger.error(f\"OpenAI API error during backend request: {e} ({self.name})\")\n            # Store debug information for potential dev mode access\n            debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n            e.debug_info = debug_info  # type: ignore\n            raise\n        except Exception as e:\n            self.logger.exception(f\"Unexpected error during backend request: {e} ({self.name})\")\n            # Store debug information for potential dev mode access\n            debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n            e.debug_info = debug_info  # type: ignore\n            raise\n\n        return transaction\n</code></pre> <p>Policy responsible for sending the chat completions request to the OpenAI-compatible backend using the OpenAI SDK and storing the structured response.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of this policy instance, used for logging and identification. It defaults to the class name if not provided during initialization.</p> <code>logger</code> <code>Logger</code> <p>The logger instance for this policy.</p>"},{"location":"#luthien_control.control_policy.send_backend_request.SendBackendRequestPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/send_backend_request.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Sends the chat completions request to the OpenAI-compatible backend using the OpenAI SDK.\n\n    This policy uses the OpenAI SDK to send the structured chat completions request\n    from transaction.request.payload to the backend API endpoint. The response\n    is stored as a structured OpenAIChatCompletionsResponse in transaction.response.payload.\n\n    Args:\n        transaction: The current transaction, containing the request payload to be sent.\n        container: The application dependency container, providing settings and OpenAI client.\n        session: An active SQLAlchemy AsyncSession. (Unused by this policy but required by the interface).\n\n    Returns:\n        The Transaction, updated with transaction.response.payload containing the\n        OpenAIChatCompletionsResponse from the backend.\n\n    Raises:\n        ValueError: If backend URL or API key is not configured.\n        openai.APIError: For API-related errors from the OpenAI backend.\n        openai.APITimeoutError: If the request to the backend times out.\n        openai.APIConnectionError: For network-related issues during the backend request.\n        Exception: For any other unexpected errors during request execution.\n    \"\"\"\n    # Create OpenAI client for the backend request\n    backend_url = transaction.request.api_endpoint\n    api_key = transaction.request.api_key\n\n    if not backend_url:\n        raise ValueError(\"Backend URL is not configured\")\n    if not api_key:\n        raise ValueError(\"OpenAI API key is not configured\")\n\n    self.logger.info(f\"Creating OpenAI client with backend URL: '{backend_url}' ({self.name})\")\n    openai_client = container.create_openai_client(backend_url, api_key)\n\n    # Get the structured request payload\n    request_payload = transaction.request.payload\n\n    self.logger.info(\n        f\"Sending chat completions request to backend with model '{request_payload.model}' \"\n        f\"and {len(request_payload.messages)} messages. ({self.name}); \"\n        f\"Target url: {backend_url}\"\n    )\n\n    try:\n        # Send request using OpenAI SDK\n        # Use the request payload directly - the OpenAI SDK should accept our Pydantic model\n        request_dict = request_payload.model_dump()\n        # Remove any None values to avoid issues with the OpenAI SDK\n        request_dict = {k: v for k, v in request_dict.items() if v is not None}\n\n        backend_response = await openai_client.chat.completions.create(**request_dict)\n\n        # Convert OpenAI SDK response to our structured response model\n        response_payload = OpenAIChatCompletionsResponse.model_validate(backend_response.model_dump())\n\n        # Store the structured response in the transaction\n        transaction.response.payload = response_payload\n        transaction.response.api_endpoint = backend_url\n\n        self.logger.info(\n            f\"Received backend response with {len(response_payload.choices)} choices \"\n            f\"and usage: {response_payload.usage}. ({self.name})\"\n        )\n\n    except openai.APITimeoutError as e:\n        self.logger.error(f\"Timeout error during backend request: {e} ({self.name})\")\n        # Store debug information for potential dev mode access\n        debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n        e.debug_info = debug_info  # type: ignore\n        raise\n    except openai.APIConnectionError as e:\n        self.logger.error(f\"Connection error during backend request: {e} ({self.name})\")\n        # Store debug information for potential dev mode access\n        debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n        e.debug_info = debug_info  # type: ignore\n        raise\n    except openai.APIError as e:\n        self.logger.error(f\"OpenAI API error during backend request: {e} ({self.name})\")\n        # Store debug information for potential dev mode access\n        debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n        e.debug_info = debug_info  # type: ignore\n        raise\n    except Exception as e:\n        self.logger.exception(f\"Unexpected error during backend request: {e} ({self.name})\")\n        # Store debug information for potential dev mode access\n        debug_info = self._create_debug_info(backend_url, request_payload, e, api_key)\n        e.debug_info = debug_info  # type: ignore\n        raise\n\n    return transaction\n</code></pre> <p>Sends the chat completions request to the OpenAI-compatible backend using the OpenAI SDK.</p> <p>This policy uses the OpenAI SDK to send the structured chat completions request from transaction.request.payload to the backend API endpoint. The response is stored as a structured OpenAIChatCompletionsResponse in transaction.response.payload.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction, containing the request payload to be sent.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container, providing settings and OpenAI client.</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession. (Unused by this policy but required by the interface).</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The Transaction, updated with transaction.response.payload containing the</p> <code>Transaction</code> <p>OpenAIChatCompletionsResponse from the backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If backend URL or API key is not configured.</p> <code>APIError</code> <p>For API-related errors from the OpenAI backend.</p> <code>APITimeoutError</code> <p>If the request to the backend times out.</p> <code>APIConnectionError</code> <p>For network-related issues during the backend request.</p> <code>Exception</code> <p>For any other unexpected errors during request execution.</p>"},{"location":"#luthien_control.control_policy.serial_policy","title":"<code>serial_policy</code>","text":""},{"location":"#luthien_control.control_policy.serial_policy.SerialPolicy","title":"<code>SerialPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/serial_policy.py</code> <pre><code>class SerialPolicy(ControlPolicy):\n    \"\"\"\n    A Control Policy that applies an ordered sequence of other policies.\n\n    Policies are applied sequentially. If any policy raises an exception,\n    the execution stops, and the exception propagates.\n\n    Attributes:\n        policies (Sequence[ControlPolicy]): The ordered sequence of ControlPolicy\n            instances that this policy will apply.\n        logger (logging.Logger): The logger instance for this policy.\n        name (str): The name of this policy instance, used for logging and\n            identification.\n    \"\"\"\n\n    name: Optional[str] = Field(default=\"SerialPolicy\")\n    policies: Sequence[ControlPolicy] = Field(...)\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if not self.policies:\n            import logging\n\n            logger = logging.getLogger(__name__)\n            logger.warning(f\"Initializing SerialPolicy '{self.name}' with an empty policy list.\")\n\n    async def apply(\n        self,\n        transaction: Transaction,\n        container: DependencyContainer,\n        session: AsyncSession,\n    ) -&gt; Transaction:\n        \"\"\"\n        Applies the contained policies sequentially to the transaction.\n        Requires the DependencyContainer and an active SQLAlchemy AsyncSession.\n\n        Args:\n            transaction: The current transaction.\n            container: The application dependency container.\n            session: An active SQLAlchemy AsyncSession, passed to member policies.\n\n        Returns:\n            The transaction after all contained policies have been applied.\n\n        Raises:\n            Exception: Propagates any exception raised by a contained policy.\n        \"\"\"\n        self.logger.debug(f\"Entering SerialPolicy: {self.name}\")\n        current_transaction = transaction\n        for i, policy in enumerate(self.policies):\n            member_policy_name = getattr(policy, \"name\", policy.__class__.__name__)  # Get policy name if available\n            self.logger.info(f\"Applying policy {i + 1}/{len(self.policies)} in {self.name}: {member_policy_name}\")\n            try:\n                current_transaction = await policy.apply(current_transaction, container=container, session=session)\n            except Exception as e:\n                self.logger.error(\n                    f\"Error applying policy {member_policy_name} within {self.name}: {e}\",\n                    exc_info=True,\n                )\n                raise  # Re-raise the exception to halt processing\n        self.logger.debug(f\"Exiting SerialPolicy: {self.name}\")\n        return current_transaction\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Provides a developer-friendly representation.\"\"\"\n        # Get the name of each policy, using getattr as fallback like in apply\n        policy_reprs = [f\"{p.name} &lt;{p.__class__.__name__}&gt;\" for p in self.policies]\n        policy_list_str = \", \".join(policy_reprs)\n        return f\"&lt;{self.name}(policies=[{policy_list_str}])&gt;\"\n\n    @classmethod\n    def from_serialized(cls, config: SerializableDict) -&gt; \"SerialPolicy\":\n        \"\"\"\n        Constructs a SerialPolicy from serialized data, loading member policies.\n\n        Args:\n            config: The serialized configuration dictionary. Expects a 'policies' key\n                    containing a list of dictionaries, each with 'type' and 'config'.\n\n        Returns:\n            An instance of SerialPolicy.\n\n        Raises:\n            PolicyLoadError: If 'policies' key is missing, not a list, or if loading\n                             a member policy fails.\n        \"\"\"\n        member_policy_data_list_val = config.get(\"policies\")\n\n        if member_policy_data_list_val is None:\n            raise PolicyLoadError(\"SerialPolicy config missing 'policies' list (key not found).\")\n        if not isinstance(member_policy_data_list_val, Iterable):\n            raise PolicyLoadError(\n                f\"SerialPolicy 'policies' must be an iterable. Got {type(member_policy_data_list_val)}\"\n            )\n\n        instantiated_policies = []\n\n        for i, member_data in enumerate(member_policy_data_list_val):\n            if not isinstance(member_data, dict):\n                raise PolicyLoadError(\n                    f\"Item at index {i} in SerialPolicy 'policies' is not a dictionary. Got {type(member_data)}\"\n                )\n\n            try:\n                # Import load_policy to properly handle member policy loading\n                from luthien_control.control_policy.loader import load_policy\n\n                # Get the type and config from member_data\n                member_type = member_data.get(\"type\")\n                member_config = member_data.get(\"config\", {})\n\n                if not isinstance(member_type, str):\n                    raise PolicyLoadError(\n                        f\"Member policy at index {i} must have a 'type' field as string. Got: {type(member_type)}\"\n                    )\n                if not isinstance(member_config, dict):\n                    raise PolicyLoadError(\n                        f\"Member policy at index {i} must have a 'config' field as dict. Got: {type(member_config)}\"\n                    )\n\n                # If name is at the top level (legacy format), move it to config\n                if \"name\" in member_data and \"name\" not in member_config:\n                    member_config[\"name\"] = member_data.get(\"name\")\n\n                # Create SerializedPolicy object from member_data\n                serialized_member = SerializedPolicy(type=member_type, config=member_config)\n                member_policy = load_policy(serialized_member)\n                instantiated_policies.append(member_policy)\n            except PolicyLoadError as e:\n                raise PolicyLoadError(\n                    f\"Failed to load member policy at index {i} \"\n                    f\"(name: {member_data.get('name', 'unknown')}) \"\n                    f\"within SerialPolicy: {e}\"\n                ) from e\n            except Exception as e:\n                raise PolicyLoadError(\n                    f\"Unexpected error loading member policy at index {i} \"\n                    f\"(name: {member_data.get('name', 'unknown')}) \"\n                    f\"within SerialPolicy: {e}\"\n                ) from e\n\n        return cls(policies=instantiated_policies, **{k: v for k, v in config.items() if k != \"policies\"})\n</code></pre> <p>A Control Policy that applies an ordered sequence of other policies.</p> <p>Policies are applied sequentially. If any policy raises an exception, the execution stops, and the exception propagates.</p> <p>Attributes:</p> Name Type Description <code>policies</code> <code>Sequence[ControlPolicy]</code> <p>The ordered sequence of ControlPolicy instances that this policy will apply.</p> <code>logger</code> <code>Logger</code> <p>The logger instance for this policy.</p> <code>name</code> <code>str</code> <p>The name of this policy instance, used for logging and identification.</p>"},{"location":"#luthien_control.control_policy.serial_policy.SerialPolicy.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>luthien_control/control_policy/serial_policy.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Provides a developer-friendly representation.\"\"\"\n    # Get the name of each policy, using getattr as fallback like in apply\n    policy_reprs = [f\"{p.name} &lt;{p.__class__.__name__}&gt;\" for p in self.policies]\n    policy_list_str = \", \".join(policy_reprs)\n    return f\"&lt;{self.name}(policies=[{policy_list_str}])&gt;\"\n</code></pre> <p>Provides a developer-friendly representation.</p>"},{"location":"#luthien_control.control_policy.serial_policy.SerialPolicy.apply","title":"<code>apply(transaction, container, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/control_policy/serial_policy.py</code> <pre><code>async def apply(\n    self,\n    transaction: Transaction,\n    container: DependencyContainer,\n    session: AsyncSession,\n) -&gt; Transaction:\n    \"\"\"\n    Applies the contained policies sequentially to the transaction.\n    Requires the DependencyContainer and an active SQLAlchemy AsyncSession.\n\n    Args:\n        transaction: The current transaction.\n        container: The application dependency container.\n        session: An active SQLAlchemy AsyncSession, passed to member policies.\n\n    Returns:\n        The transaction after all contained policies have been applied.\n\n    Raises:\n        Exception: Propagates any exception raised by a contained policy.\n    \"\"\"\n    self.logger.debug(f\"Entering SerialPolicy: {self.name}\")\n    current_transaction = transaction\n    for i, policy in enumerate(self.policies):\n        member_policy_name = getattr(policy, \"name\", policy.__class__.__name__)  # Get policy name if available\n        self.logger.info(f\"Applying policy {i + 1}/{len(self.policies)} in {self.name}: {member_policy_name}\")\n        try:\n            current_transaction = await policy.apply(current_transaction, container=container, session=session)\n        except Exception as e:\n            self.logger.error(\n                f\"Error applying policy {member_policy_name} within {self.name}: {e}\",\n                exc_info=True,\n            )\n            raise  # Re-raise the exception to halt processing\n    self.logger.debug(f\"Exiting SerialPolicy: {self.name}\")\n    return current_transaction\n</code></pre> <p>Applies the contained policies sequentially to the transaction. Requires the DependencyContainer and an active SQLAlchemy AsyncSession.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Transaction</code> <p>The current transaction.</p> required <code>container</code> <code>DependencyContainer</code> <p>The application dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>An active SQLAlchemy AsyncSession, passed to member policies.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The transaction after all contained policies have been applied.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates any exception raised by a contained policy.</p>"},{"location":"#luthien_control.control_policy.serial_policy.SerialPolicy.from_serialized","title":"<code>from_serialized(config)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/control_policy/serial_policy.py</code> <pre><code>@classmethod\ndef from_serialized(cls, config: SerializableDict) -&gt; \"SerialPolicy\":\n    \"\"\"\n    Constructs a SerialPolicy from serialized data, loading member policies.\n\n    Args:\n        config: The serialized configuration dictionary. Expects a 'policies' key\n                containing a list of dictionaries, each with 'type' and 'config'.\n\n    Returns:\n        An instance of SerialPolicy.\n\n    Raises:\n        PolicyLoadError: If 'policies' key is missing, not a list, or if loading\n                         a member policy fails.\n    \"\"\"\n    member_policy_data_list_val = config.get(\"policies\")\n\n    if member_policy_data_list_val is None:\n        raise PolicyLoadError(\"SerialPolicy config missing 'policies' list (key not found).\")\n    if not isinstance(member_policy_data_list_val, Iterable):\n        raise PolicyLoadError(\n            f\"SerialPolicy 'policies' must be an iterable. Got {type(member_policy_data_list_val)}\"\n        )\n\n    instantiated_policies = []\n\n    for i, member_data in enumerate(member_policy_data_list_val):\n        if not isinstance(member_data, dict):\n            raise PolicyLoadError(\n                f\"Item at index {i} in SerialPolicy 'policies' is not a dictionary. Got {type(member_data)}\"\n            )\n\n        try:\n            # Import load_policy to properly handle member policy loading\n            from luthien_control.control_policy.loader import load_policy\n\n            # Get the type and config from member_data\n            member_type = member_data.get(\"type\")\n            member_config = member_data.get(\"config\", {})\n\n            if not isinstance(member_type, str):\n                raise PolicyLoadError(\n                    f\"Member policy at index {i} must have a 'type' field as string. Got: {type(member_type)}\"\n                )\n            if not isinstance(member_config, dict):\n                raise PolicyLoadError(\n                    f\"Member policy at index {i} must have a 'config' field as dict. Got: {type(member_config)}\"\n                )\n\n            # If name is at the top level (legacy format), move it to config\n            if \"name\" in member_data and \"name\" not in member_config:\n                member_config[\"name\"] = member_data.get(\"name\")\n\n            # Create SerializedPolicy object from member_data\n            serialized_member = SerializedPolicy(type=member_type, config=member_config)\n            member_policy = load_policy(serialized_member)\n            instantiated_policies.append(member_policy)\n        except PolicyLoadError as e:\n            raise PolicyLoadError(\n                f\"Failed to load member policy at index {i} \"\n                f\"(name: {member_data.get('name', 'unknown')}) \"\n                f\"within SerialPolicy: {e}\"\n            ) from e\n        except Exception as e:\n            raise PolicyLoadError(\n                f\"Unexpected error loading member policy at index {i} \"\n                f\"(name: {member_data.get('name', 'unknown')}) \"\n                f\"within SerialPolicy: {e}\"\n            ) from e\n\n    return cls(policies=instantiated_policies, **{k: v for k, v in config.items() if k != \"policies\"})\n</code></pre> <p>Constructs a SerialPolicy from serialized data, loading member policies.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SerializableDict</code> <p>The serialized configuration dictionary. Expects a 'policies' key     containing a list of dictionaries, each with 'type' and 'config'.</p> required <p>Returns:</p> Type Description <code>SerialPolicy</code> <p>An instance of SerialPolicy.</p> <p>Raises:</p> Type Description <code>PolicyLoadError</code> <p>If 'policies' key is missing, not a list, or if loading              a member policy fails.</p>"},{"location":"#luthien_control.control_policy.serialization","title":"<code>serialization</code>","text":""},{"location":"#luthien_control.control_policy.serialization.SerializedPolicy","title":"<code>SerializedPolicy</code>  <code>dataclass</code>","text":"Source code in <code>luthien_control/control_policy/serialization.py</code> <pre><code>@dataclass\nclass SerializedPolicy:\n    \"\"\"Represents the serialized form of a ControlPolicy.\n\n    This structure is used to store and transfer policy configurations.\n    The 'type' field identifies the specific policy class, and the 'config'\n    field contains the parameters needed to reconstruct that policy instance.\n\n    Attributes:\n        type (str): The registered name of the policy type (e.g., \"AddApiKeyHeader\").\n        config (SerializableDict): A dictionary containing the configuration\n                                   parameters for the policy instance.\n    \"\"\"\n\n    type: str\n    config: SerializableDict\n</code></pre> <p>Represents the serialized form of a ControlPolicy.</p> <p>This structure is used to store and transfer policy configurations. The 'type' field identifies the specific policy class, and the 'config' field contains the parameters needed to reconstruct that policy instance.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>The registered name of the policy type (e.g., \"AddApiKeyHeader\").</p> <code>config</code> <code>SerializableDict</code> <p>A dictionary containing the configuration                        parameters for the policy instance.</p>"},{"location":"#luthien_control.control_policy.serialization.safe_model_dump","title":"<code>safe_model_dump(model)</code>","text":"Source code in <code>luthien_control/control_policy/serialization.py</code> <pre><code>def safe_model_dump(model: BaseModel) -&gt; SerializableDict:\n    \"\"\"Safely dump a Pydantic model through SerializableDict validation.\"\"\"\n    data = model.model_dump(mode=\"python\", by_alias=True)\n    return SerializableDictAdapter.validate_python(data)\n</code></pre> <p>Safely dump a Pydantic model through SerializableDict validation.</p>"},{"location":"#luthien_control.control_policy.serialization.safe_model_validate","title":"<code>safe_model_validate(model_class, data)</code>","text":"Source code in <code>luthien_control/control_policy/serialization.py</code> <pre><code>def safe_model_validate(model_class: type[T], data: SerializableDict) -&gt; T:\n    \"\"\"Safely validate data through SerializableDict before creating model.\"\"\"\n    validated_data = SerializableDictAdapter.validate_python(data)\n    return model_class.model_validate(validated_data, from_attributes=True)\n</code></pre> <p>Safely validate data through SerializableDict before creating model.</p>"},{"location":"#luthien_control.control_policy.set_backend_policy","title":"<code>set_backend_policy</code>","text":""},{"location":"#luthien_control.control_policy.set_backend_policy.SetBackendPolicy","title":"<code>SetBackendPolicy</code>","text":"<p>           Bases: <code>ControlPolicy</code></p> Source code in <code>luthien_control/control_policy/set_backend_policy.py</code> <pre><code>class SetBackendPolicy(ControlPolicy):\n    \"\"\"A policy that sets the backend URL for the transaction.\"\"\"\n\n    name: Optional[str] = Field(default=\"SetBackendPolicy\")\n    backend_url: Optional[str] = Field(default=None)\n\n    async def apply(\n        self, transaction: Transaction, container: DependencyContainer, session: AsyncSession\n    ) -&gt; Transaction:\n        if self.backend_url is not None:\n            # Set the base URL only - the OpenAI client will append the specific endpoint path\n            # The original api_endpoint (e.g., \"chat/completions\") will be used by the OpenAI client\n            transaction.request.api_endpoint = self.backend_url\n        return transaction\n\n    def _get_policy_specific_config(self) -&gt; SerializableDict:\n        \"\"\"Return policy-specific configuration for backward compatibility with tests.\"\"\"\n        return SerializableDict(\n            backend_url=self.backend_url,\n        )\n</code></pre> <p>A policy that sets the backend URL for the transaction.</p>"},{"location":"#luthien_control.core","title":"<code>core</code>","text":""},{"location":"#luthien_control.core.dependencies","title":"<code>dependencies</code>","text":""},{"location":"#luthien_control.core.dependencies.get_db_session","title":"<code>get_db_session(dependencies=Depends(get_dependencies))</code>  <code>async</code>","text":"Source code in <code>luthien_control/core/dependencies.py</code> <pre><code>async def get_db_session(\n    dependencies: DependencyContainer = Depends(get_dependencies),\n) -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"FastAPI dependency to get an async database session using the container's factory.\"\"\"\n    session_factory = dependencies.db_session_factory\n    if session_factory is None:\n        # This shouldn't happen if the container is initialized correctly\n        logger.critical(\"DB Session Factory not found in DependencyContainer.\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error: Database session factory not available.\",\n        )\n\n    async with session_factory() as session:\n        try:\n            yield session\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            # The session context manager should handle commit/close,\n            # but rollback is explicit on exception.\n            pass\n</code></pre> <p>FastAPI dependency to get an async database session using the container's factory.</p>"},{"location":"#luthien_control.core.dependencies.get_dependencies","title":"<code>get_dependencies(request)</code>","text":"Source code in <code>luthien_control/core/dependencies.py</code> <pre><code>def get_dependencies(request: Request) -&gt; DependencyContainer:\n    \"\"\"Dependency to retrieve the DependencyContainer from application state.\"\"\"\n    dependencies: DependencyContainer | None = getattr(request.app.state, \"dependencies\", None)\n    if dependencies is None:\n        logger.critical(\n            \"DependencyContainer not found in application state. \"\n            \"This indicates a critical setup error in the application lifespan.\"\n        )\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error: Application dependencies not initialized.\",\n        )\n    return dependencies\n</code></pre> <p>Dependency to retrieve the DependencyContainer from application state.</p>"},{"location":"#luthien_control.core.dependencies.get_main_control_policy","title":"<code>get_main_control_policy(dependencies=Depends(get_dependencies))</code>  <code>async</code>","text":"Source code in <code>luthien_control/core/dependencies.py</code> <pre><code>async def get_main_control_policy(\n    dependencies: DependencyContainer = Depends(get_dependencies),\n) -&gt; ControlPolicy:\n    \"\"\"\n    Dependency to load and provide the main ControlPolicy instance.\n\n    Uses the DependencyContainer to access settings, http_client, and a database session.\n    \"\"\"\n    settings = dependencies.settings\n    policy_filepath = settings.get_policy_filepath()\n    if policy_filepath:\n        logger.info(f\"Loading main control policy from file: {policy_filepath}\")\n        return load_policy_from_file(policy_filepath)\n\n    top_level_policy_name = settings.get_top_level_policy_name()\n    if not top_level_policy_name:\n        logger.error(\"TOP_LEVEL_POLICY_NAME is not configured in settings.\")\n        raise HTTPException(status_code=500, detail=\"Internal server error: Control policy name not configured.\")\n    try:\n        # Get a session using the container's factory - No longer needed here, load_policy_from_db handles it\n        # async with session_factory() as session:\n        # Pass the container directly to load_policy_from_db\n        main_policy = await load_policy_from_db(\n            name=top_level_policy_name,\n            container=dependencies,  # Pass the whole container\n        )\n\n        if not main_policy:\n            logger.error(f\"Main control policy '{top_level_policy_name}' could not be loaded (not found or inactive).\")\n            raise HTTPException(\n                status_code=500,\n                detail=f\"Internal server error: Main control policy '{top_level_policy_name}' not found or inactive.\",\n            )\n\n        return main_policy\n\n    except PolicyLoadError as e:\n        logger.exception(f\"Failed to load main control policy '{top_level_policy_name}': {e}\")\n        raise HTTPException(status_code=500, detail=f\"Internal server error: Could not load main control policy. {e}\")\n    except HTTPException:  # Re-raise HTTPExceptions from session creation\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error loading main control policy '{top_level_policy_name}': {e}\")\n        raise HTTPException(\n            status_code=500, detail=\"Internal server error: Unexpected issue loading main control policy.\"\n        )\n</code></pre> <p>Dependency to load and provide the main ControlPolicy instance.</p> <p>Uses the DependencyContainer to access settings, http_client, and a database session.</p>"},{"location":"#luthien_control.core.dependencies.initialize_app_dependencies","title":"<code>initialize_app_dependencies(app_settings)</code>  <code>async</code>","text":"Source code in <code>luthien_control/core/dependencies.py</code> <pre><code>async def initialize_app_dependencies(app_settings: Settings) -&gt; DependencyContainer:\n    \"\"\"Initialize and configure core application dependencies.\n\n    This function sets up essential services required by the application,\n    including an HTTP client and a database connection pool. It encapsulates\n    the creation and configuration of these dependencies into a\n    DependencyContainer instance.\n\n    Args:\n        app_settings: The application settings instance.\n\n    Returns:\n        A DependencyContainer instance populated with initialized dependencies.\n\n    Raises:\n        RuntimeError: If initialization of the HTTP client or database engine fails.\n    \"\"\"\n    logger.info(\"Initializing core application dependencies...\")\n\n    # Initialize HTTP client\n    timeout = httpx.Timeout(5.0, connect=5.0, read=60.0, write=5.0)\n    http_client = httpx.AsyncClient(timeout=timeout)\n    logger.info(\"HTTP Client initialized for DependencyContainer.\")\n\n    # Initialize Database Engine and Session Factory\n    try:\n        logger.info(\"Attempting to create main DB engine and session factory for DependencyContainer...\")\n        _db_engine = await create_db_engine()  # Uses app_settings implicitly via global settings instance\n        logger.info(\"Main DB engine successfully created for DependencyContainer.\")\n        # Use the actual session factory from database_async module\n        db_session_factory = db_get_session\n        logger.info(\"DB Session Factory reference obtained for DependencyContainer.\")\n\n    except Exception as db_exc:\n        logger.critical(f\"Failed to initialize database for DependencyContainer due to exception: {db_exc}\")\n        await http_client.aclose()  # Clean up HTTP client\n        logger.info(\"HTTP client closed due to DB initialization failure.\")\n        # No need to call close_db_engine here, as db_engine might not be valid or fully initialized.\n        # The caller (lifespan) will handle global engine cleanup if needed.\n        raise RuntimeError(f\"Failed to initialize database for DependencyContainer: {db_exc}\") from db_exc\n\n    # Create and return Dependency Container\n    try:\n        dependencies = DependencyContainer(\n            settings=app_settings,\n            http_client=http_client,\n            db_session_factory=db_session_factory,\n        )\n        logger.info(\"Dependency Container created successfully.\")\n        return dependencies\n    except Exception as container_exc:\n        logger.critical(f\"Failed to create Dependency Container instance: {container_exc}\", exc_info=True)\n        # Clean up resources created within this helper function\n        await http_client.aclose()\n        logger.info(\"HTTP client closed due to Dependency Container instantiation failure.\")\n        # If db_engine was successfully created, it's now managed by the global close_db_engine,\n        # which will be called by the lifespan's shutdown phase.\n        # We don't call close_db_engine(db_engine_instance_if_any) here because the global one handles it.\n        raise RuntimeError(f\"Failed to create Dependency Container instance: {container_exc}\") from container_exc\n</code></pre> <p>Initialize and configure core application dependencies.</p> <p>This function sets up essential services required by the application, including an HTTP client and a database connection pool. It encapsulates the creation and configuration of these dependencies into a DependencyContainer instance.</p> <p>Parameters:</p> Name Type Description Default <code>app_settings</code> <code>Settings</code> <p>The application settings instance.</p> required <p>Returns:</p> Type Description <code>DependencyContainer</code> <p>A DependencyContainer instance populated with initialized dependencies.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If initialization of the HTTP client or database engine fails.</p>"},{"location":"#luthien_control.core.dependency_container","title":"<code>dependency_container</code>","text":""},{"location":"#luthien_control.core.dependency_container.DependencyContainer","title":"<code>DependencyContainer</code>","text":"Source code in <code>luthien_control/core/dependency_container.py</code> <pre><code>class DependencyContainer:\n    \"\"\"Holds shared dependencies for the application.\n\n    This class is responsible for holding all shared dependencies for the application.\n    It is used to inject dependencies into the application and to make it easier to mock dependencies for testing.\n    \"\"\"\n\n    def __init__(\n        self,\n        settings: Settings,\n        http_client: httpx.AsyncClient,\n        db_session_factory: Callable[[], AsyncContextManager[AsyncSession]],\n    ) -&gt; None:\n        \"\"\"\n        Initializes the container.\n\n        Args:\n            settings: Application settings.\n            http_client: Shared asynchronous HTTP client.\n            db_session_factory: A factory function that returns an async context manager\n                                yielding an SQLAlchemy AsyncSession.\n        \"\"\"\n        self.settings = settings\n        self.http_client = http_client\n        self.db_session_factory = db_session_factory\n\n    def create_openai_client(self, base_url: str, api_key: str) -&gt; openai.AsyncOpenAI:\n        \"\"\"\n        Creates an OpenAI client for the specified backend URL and API key.\n\n        We include this factory here for the sake of consistency with other external dependencies.\n        By maintaining all external dependencies in one place, we can easily mock them for testing\n        and keep track of which parts of the application have external dependencies.\n\n        Args:\n            base_url: The base URL for the OpenAI-compatible API endpoint.\n            api_key: The API key for authentication.\n\n        Returns:\n            An configured OpenAI AsyncClient instance.\n\n        Raises:\n            ValueError: If the base_url is missing or doesn't have a valid protocol.\n        \"\"\"\n        if not base_url:\n            raise ValueError(\"Base URL cannot be empty\")\n\n        if not base_url.startswith((\"http://\", \"https://\")):\n            raise ValueError(f\"Base URL must start with 'http://' or 'https://': {base_url}\")\n\n        return openai.AsyncOpenAI(api_key=api_key, base_url=base_url)\n</code></pre> <p>Holds shared dependencies for the application.</p> <p>This class is responsible for holding all shared dependencies for the application. It is used to inject dependencies into the application and to make it easier to mock dependencies for testing.</p>"},{"location":"#luthien_control.core.dependency_container.DependencyContainer.__init__","title":"<code>__init__(settings, http_client, db_session_factory)</code>","text":"Source code in <code>luthien_control/core/dependency_container.py</code> <pre><code>def __init__(\n    self,\n    settings: Settings,\n    http_client: httpx.AsyncClient,\n    db_session_factory: Callable[[], AsyncContextManager[AsyncSession]],\n) -&gt; None:\n    \"\"\"\n    Initializes the container.\n\n    Args:\n        settings: Application settings.\n        http_client: Shared asynchronous HTTP client.\n        db_session_factory: A factory function that returns an async context manager\n                            yielding an SQLAlchemy AsyncSession.\n    \"\"\"\n    self.settings = settings\n    self.http_client = http_client\n    self.db_session_factory = db_session_factory\n</code></pre> <p>Initializes the container.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Settings</code> <p>Application settings.</p> required <code>http_client</code> <code>AsyncClient</code> <p>Shared asynchronous HTTP client.</p> required <code>db_session_factory</code> <code>Callable[[], AsyncContextManager[AsyncSession]]</code> <p>A factory function that returns an async context manager                 yielding an SQLAlchemy AsyncSession.</p> required"},{"location":"#luthien_control.core.dependency_container.DependencyContainer.create_openai_client","title":"<code>create_openai_client(base_url, api_key)</code>","text":"Source code in <code>luthien_control/core/dependency_container.py</code> <pre><code>def create_openai_client(self, base_url: str, api_key: str) -&gt; openai.AsyncOpenAI:\n    \"\"\"\n    Creates an OpenAI client for the specified backend URL and API key.\n\n    We include this factory here for the sake of consistency with other external dependencies.\n    By maintaining all external dependencies in one place, we can easily mock them for testing\n    and keep track of which parts of the application have external dependencies.\n\n    Args:\n        base_url: The base URL for the OpenAI-compatible API endpoint.\n        api_key: The API key for authentication.\n\n    Returns:\n        An configured OpenAI AsyncClient instance.\n\n    Raises:\n        ValueError: If the base_url is missing or doesn't have a valid protocol.\n    \"\"\"\n    if not base_url:\n        raise ValueError(\"Base URL cannot be empty\")\n\n    if not base_url.startswith((\"http://\", \"https://\")):\n        raise ValueError(f\"Base URL must start with 'http://' or 'https://': {base_url}\")\n\n    return openai.AsyncOpenAI(api_key=api_key, base_url=base_url)\n</code></pre> <p>Creates an OpenAI client for the specified backend URL and API key.</p> <p>We include this factory here for the sake of consistency with other external dependencies. By maintaining all external dependencies in one place, we can easily mock them for testing and keep track of which parts of the application have external dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the OpenAI-compatible API endpoint.</p> required <code>api_key</code> <code>str</code> <p>The API key for authentication.</p> required <p>Returns:</p> Type Description <code>AsyncOpenAI</code> <p>An configured OpenAI AsyncClient instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the base_url is missing or doesn't have a valid protocol.</p>"},{"location":"#luthien_control.core.generic_events","title":"<code>generic_events</code>","text":"<p>Generic event system with type-safe event dispatching.</p>"},{"location":"#luthien_control.core.generic_events.Event","title":"<code>Event</code>","text":"<p>           Bases: <code>Generic[T]</code></p> Source code in <code>luthien_control/core/generic_events.py</code> <pre><code>class Event(Generic[T]):\n    \"\"\"A generic event that maintains a named registry of typed event listeners to be dispatched on demand.\n\n\n    Typical usage:\n        start_policy_event = LuthienEventType(\"start_policy\")\n        event: Event[dict] = Event[dict](start_policy_event)\n        data = {\"foo\": \"bar\"}\n        def listener_1(event_type, data):\n            print(f\"Listener 1 received event: {event_type} {data}\")\n        def listener_2(event_type, data):\n            print(f\"Listener 2 received event: {event_type} {data}\")\n\n        event.register(\"listener_1\", listener_1)\n        event.register(\"listener_2\", listener_2)\n        event.dispatch(data)  # Listener 1 and 2 will receive the event\n        event.unregister(\"listener_1\")\n        event.dispatch(data)  # Listener 2 will receive the event\n\n    Type Parameters:\n        T: The type of data that will be passed to event listeners\n    \"\"\"\n\n    def __init__(self, event_type: str) -&gt; None:\n        \"\"\"Initialize an event with no registered listeners.\n\n        Args:\n            event_type: The type of event this observer is for\n        \"\"\"\n        self._event_type = event_type\n        self._listeners: Dict[str, EventListener[T]] = {}\n\n    def register(self, name: str, listener: EventListener[T]) -&gt; None:\n        \"\"\"Register a named observer.\n\n        Args:\n            name: Unique identifier for this listener\n            listener: Callable that accepts an argument of type T\n        \"\"\"\n        self._listeners[name] = listener\n\n    def unregister(self, name: str) -&gt; None:\n        \"\"\"Remove a registered observer by name.\n\n        Args:\n            name: The name of the listener to remove\n\n        Raises:\n            KeyError: If no listener with the given name exists\n        \"\"\"\n        del self._listeners[name]\n\n    def dispatch(self, data: T) -&gt; None:\n        \"\"\"Dispatch the event to all registered observers.\n\n        Args:\n            data: The data of type T to pass to all listeners\n        \"\"\"\n        for name, listener in self._listeners.items():\n            try:\n                listener(self._event_type, data)\n            except Exception as e:\n                logging.exception(f\"Error dispatching event to listener {name}: {e}\")\n\n    @property\n    def listener_count(self) -&gt; int:\n        \"\"\"Return the number of registered listeners.\"\"\"\n        return len(self._listeners)\n\n    def get_listeners(self) -&gt; Dict[str, EventListener[T]]:\n        \"\"\"Return a *copy* of the registered listeners dictionary.\n\n        Returns:\n            A copy of the listeners registry\n        \"\"\"\n        return self._listeners.copy()\n</code></pre> <p>A generic event that maintains a named registry of typed event listeners to be dispatched on demand.</p> Typical usage <p>start_policy_event = LuthienEventType(\"start_policy\") event: Event[dict] = Eventdict data = {\"foo\": \"bar\"} def listener_1(event_type, data):     print(f\"Listener 1 received event: {event_type} {data}\") def listener_2(event_type, data):     print(f\"Listener 2 received event: {event_type} {data}\")</p> <p>event.register(\"listener_1\", listener_1) event.register(\"listener_2\", listener_2) event.dispatch(data)  # Listener 1 and 2 will receive the event event.unregister(\"listener_1\") event.dispatch(data)  # Listener 2 will receive the event</p> Type Parameters <p>T: The type of data that will be passed to event listeners</p>"},{"location":"#luthien_control.core.generic_events.Event.listener_count","title":"<code>property</code>","text":"<p>Return the number of registered listeners.</p>"},{"location":"#luthien_control.core.generic_events.Event.listener_count","title":"<code>listener_count</code>  <code>property</code>","text":"<p>Return the number of registered listeners.</p>"},{"location":"#luthien_control.core.generic_events.Event.__init__","title":"<code>__init__(event_type)</code>","text":"Source code in <code>luthien_control/core/generic_events.py</code> <pre><code>def __init__(self, event_type: str) -&gt; None:\n    \"\"\"Initialize an event with no registered listeners.\n\n    Args:\n        event_type: The type of event this observer is for\n    \"\"\"\n    self._event_type = event_type\n    self._listeners: Dict[str, EventListener[T]] = {}\n</code></pre> <p>Initialize an event with no registered listeners.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>The type of event this observer is for</p> required"},{"location":"#luthien_control.core.generic_events.Event.dispatch","title":"<code>dispatch(data)</code>","text":"Source code in <code>luthien_control/core/generic_events.py</code> <pre><code>def dispatch(self, data: T) -&gt; None:\n    \"\"\"Dispatch the event to all registered observers.\n\n    Args:\n        data: The data of type T to pass to all listeners\n    \"\"\"\n    for name, listener in self._listeners.items():\n        try:\n            listener(self._event_type, data)\n        except Exception as e:\n            logging.exception(f\"Error dispatching event to listener {name}: {e}\")\n</code></pre> <p>Dispatch the event to all registered observers.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data of type T to pass to all listeners</p> required"},{"location":"#luthien_control.core.generic_events.Event.get_listeners","title":"<code>get_listeners()</code>","text":"Source code in <code>luthien_control/core/generic_events.py</code> <pre><code>def get_listeners(self) -&gt; Dict[str, EventListener[T]]:\n    \"\"\"Return a *copy* of the registered listeners dictionary.\n\n    Returns:\n        A copy of the listeners registry\n    \"\"\"\n    return self._listeners.copy()\n</code></pre> <p>Return a copy of the registered listeners dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, EventListener[T]]</code> <p>A copy of the listeners registry</p>"},{"location":"#luthien_control.core.generic_events.Event.register","title":"<code>register(name, listener)</code>","text":"Source code in <code>luthien_control/core/generic_events.py</code> <pre><code>def register(self, name: str, listener: EventListener[T]) -&gt; None:\n    \"\"\"Register a named observer.\n\n    Args:\n        name: Unique identifier for this listener\n        listener: Callable that accepts an argument of type T\n    \"\"\"\n    self._listeners[name] = listener\n</code></pre> <p>Register a named observer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for this listener</p> required <code>listener</code> <code>EventListener[T]</code> <p>Callable that accepts an argument of type T</p> required"},{"location":"#luthien_control.core.generic_events.Event.unregister","title":"<code>unregister(name)</code>","text":"Source code in <code>luthien_control/core/generic_events.py</code> <pre><code>def unregister(self, name: str) -&gt; None:\n    \"\"\"Remove a registered observer by name.\n\n    Args:\n        name: The name of the listener to remove\n\n    Raises:\n        KeyError: If no listener with the given name exists\n    \"\"\"\n    del self._listeners[name]\n</code></pre> <p>Remove a registered observer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the listener to remove</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no listener with the given name exists</p>"},{"location":"#luthien_control.core.logging","title":"<code>logging</code>","text":""},{"location":"#luthien_control.core.logging.setup_logging","title":"<code>setup_logging()</code>","text":"Source code in <code>luthien_control/core/logging.py</code> <pre><code>def setup_logging():\n    \"\"\"\n    Configures logging for the application.\n\n    Reads the desired log level from the LOG_LEVEL environment variable.\n    Defaults to INFO if not set or invalid.\n    Sets a standard format and directs logs to stderr.\n    Sets louder libraries to WARNING level.\n    Optionally configures Loki handler if LOKI_URL is set.\n    \"\"\"\n    settings = Settings()\n    log_level_name = settings.get_log_level(default=DEFAULT_LOG_LEVEL)\n\n    if log_level_name not in VALID_LOG_LEVELS:\n        print(\n            f\"WARNING: Invalid LOG_LEVEL '{log_level_name}'. \"\n            f\"Defaulting to {DEFAULT_LOG_LEVEL}. \"\n            f\"Valid levels are: {', '.join(VALID_LOG_LEVELS)}\",\n            file=sys.stderr,\n        )\n        log_level_name = DEFAULT_LOG_LEVEL\n\n    log_level = logging.getLevelName(log_level_name)\n\n    # Configure root logger\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n\n    # Clear any existing handlers\n    root_logger.handlers.clear()\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stderr)\n    console_handler.setFormatter(logging.Formatter(LOG_FORMAT))\n    root_logger.addHandler(console_handler)\n\n    # Loki handler if configured\n    loki_url = os.getenv(\"LOKI_URL\")\n    if loki_url:\n        loki_handler = _get_loki_handler(loki_url)\n        if loki_handler:\n            root_logger.addHandler(loki_handler)\n            logging.getLogger(__name__).info(f\"Loki logging configured for {loki_url}\")\n\n    # Quiet down noisy libraries\n    for lib_name in NOISY_LIBRARIES:\n        logging.getLogger(lib_name).setLevel(logging.WARNING)\n\n    # Log that configuration is complete (useful for debugging setup issues)\n    logging.getLogger(__name__).info(f\"Logging configured with level {log_level_name}.\")\n</code></pre> <p>Configures logging for the application.</p> <p>Reads the desired log level from the LOG_LEVEL environment variable. Defaults to INFO if not set or invalid. Sets a standard format and directs logs to stderr. Sets louder libraries to WARNING level. Optionally configures Loki handler if LOKI_URL is set.</p>"},{"location":"#luthien_control.core.request","title":"<code>request</code>","text":""},{"location":"#luthien_control.core.request.Request","title":"<code>Request</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/core/request.py</code> <pre><code>class Request(DeepEventedModel):\n    \"\"\"A request to the Luthien Control API.\"\"\"\n\n    payload: OpenAIChatCompletionsRequest = Field()\n    api_endpoint: str = Field()\n    api_key: str = Field()\n</code></pre> <p>A request to the Luthien Control API.</p>"},{"location":"#luthien_control.core.response","title":"<code>response</code>","text":""},{"location":"#luthien_control.core.response.Response","title":"<code>Response</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/core/response.py</code> <pre><code>class Response(DeepEventedModel):\n    \"\"\"A response from the Luthien Control API.\"\"\"\n\n    payload: Optional[OpenAIChatCompletionsResponse] = Field(default=None)\n    api_endpoint: Optional[str] = Field(default=None)\n</code></pre> <p>A response from the Luthien Control API.</p>"},{"location":"#luthien_control.core.tracked_context","title":"<code>tracked_context</code>","text":"<p>TrackedContext module with explicit mutation API and event tracking.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext","title":"<code>TrackedContext</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>class TrackedContext:\n    \"\"\"Transaction context with explicit mutation API and event tracking.\"\"\"\n\n    def __init__(self, transaction_id: Optional[uuid.UUID] = None):\n        \"\"\"Initialize tracked context.\"\"\"\n        self._transaction_id = transaction_id or uuid.uuid4()\n        self._request: Optional[httpx.Request] = None\n        self._response: Optional[httpx.Response] = None\n        self._data: Dict[str, Any] = {}\n        self.events = ContextEvents()\n\n    @property\n    def transaction_id(self) -&gt; uuid.UUID:\n        \"\"\"Get transaction ID.\"\"\"\n        return self._transaction_id\n\n    def update_request(\n        self,\n        method: Optional[str] = None,\n        url: Optional[str] = None,\n        headers: Optional[Dict[str, str]] = None,\n        content: Optional[bytes] = None,\n        from_scratch: bool = False,\n        preserve_existing_headers: bool = True,\n    ) -&gt; httpx.Request:\n        \"\"\"Create or set the request.\"\"\"\n        differences = {}\n        if from_scratch or self._request is None:\n            if not all([method, url]):\n                raise ValueError(\"Attempted to create new request, but method and url are required\")\n            method = str(method)\n            url = str(url)\n            self._request = httpx.Request(method=method, url=url, headers=headers, content=content)\n            differences = {\n                k: {\"old\": None, \"new\": getattr(self._request, k)} for k in [\"method\", \"url\", \"headers\", \"content\"]\n            }\n        else:\n            if method is not None:\n                differences[\"method\"] = {\"old\": self._request.method, \"new\": method}\n                self._request.method = method\n            if url is not None:\n                differences[\"url\"] = {\"old\": self._request.url, \"new\": url}\n                self._request.url = httpx.URL(url)\n            if headers is not None:\n                header_diffs = _update_headers(self._request, headers, preserve_existing_headers)\n                differences[\"headers\"] = header_diffs\n            if content is not None:\n                differences[\"content\"] = {\"old\": self._request.content, \"new\": content}\n                self._request._content = content\n\n        self.events.mutation.dispatch(\n            MutationEventPayload(\n                transaction_id=self._transaction_id,\n                operation=\"set_request\",\n                details=differences,\n            )\n        )\n        return self._request\n\n    @property\n    def request(self) -&gt; Optional[httpx.Request]:\n        \"\"\"Get a copy of the tracked request.\"\"\"\n        return copy(self._request)\n\n    def update_response(\n        self,\n        status_code: Optional[int] = None,\n        content: Optional[bytes] = None,\n        headers: Optional[Dict[str, str]] = None,\n        from_scratch: bool = False,\n        preserve_existing_headers: bool = True,\n    ) -&gt; httpx.Response:\n        \"\"\"Update the response.\"\"\"\n        differences = {}\n        if from_scratch or self._response is None:\n            if not status_code:\n                raise ValueError(\"Attempted to create new response, but status_code is required\")\n            status_code = int(status_code)\n            self._response = httpx.Response(\n                status_code=status_code,\n                headers=headers,\n                content=content,\n            )\n            differences = {\n                k: {\"old\": None, \"new\": getattr(self._response, k)} for k in [\"status_code\", \"headers\", \"content\"]\n            }\n        else:\n            if status_code is not None:\n                differences[\"status_code\"] = {\"old\": self._response.status_code, \"new\": status_code}\n                self._response.status_code = status_code\n            if headers is not None:\n                differences[\"headers\"] = _update_headers(self._response, headers, preserve_existing_headers)\n            if content is not None:\n                differences[\"content\"] = {\"old\": self._response.content, \"new\": content}\n                self._response._content = content\n\n        self.events.mutation.dispatch(\n            MutationEventPayload(\n                transaction_id=self._transaction_id,\n                operation=\"set_response\",\n                details=differences,\n            )\n        )\n        return self._response\n\n    @property\n    def response(self) -&gt; Optional[httpx.Response]:\n        \"\"\"Get a copy of the tracked response.\"\"\"\n        return copy(self._response)\n\n    def get_data(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get data value.\"\"\"\n        return self._data.get(key, default)\n\n    def set_data(self, key: str, value: Any) -&gt; None:\n        \"\"\"Set data value.\"\"\"\n        old_value = self._data.get(key)\n        self._data[key] = value\n        self.events.mutation.dispatch(\n            MutationEventPayload(\n                transaction_id=self._transaction_id,\n                operation=\"set_data\",\n                details={\"key\": key, \"old_value\": old_value, \"new_value\": value},\n            )\n        )\n\n    def get_all_data(self) -&gt; Dict[str, Any]:\n        \"\"\"Get copy of all data.\"\"\"\n        return self._data.copy()\n</code></pre> <p>Transaction context with explicit mutation API and event tracking.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.request","title":"<code>property</code>","text":"<p>Get a copy of the tracked request.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.request","title":"<code>request</code>  <code>property</code>","text":"<p>Get a copy of the tracked request.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.response","title":"<code>property</code>","text":"<p>Get a copy of the tracked response.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.response","title":"<code>response</code>  <code>property</code>","text":"<p>Get a copy of the tracked response.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.transaction_id","title":"<code>property</code>","text":"<p>Get transaction ID.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.transaction_id","title":"<code>transaction_id</code>  <code>property</code>","text":"<p>Get transaction ID.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.__init__","title":"<code>__init__(transaction_id=None)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def __init__(self, transaction_id: Optional[uuid.UUID] = None):\n    \"\"\"Initialize tracked context.\"\"\"\n    self._transaction_id = transaction_id or uuid.uuid4()\n    self._request: Optional[httpx.Request] = None\n    self._response: Optional[httpx.Response] = None\n    self._data: Dict[str, Any] = {}\n    self.events = ContextEvents()\n</code></pre> <p>Initialize tracked context.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.get_all_data","title":"<code>get_all_data()</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def get_all_data(self) -&gt; Dict[str, Any]:\n    \"\"\"Get copy of all data.\"\"\"\n    return self._data.copy()\n</code></pre> <p>Get copy of all data.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.get_data","title":"<code>get_data(key, default=None)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def get_data(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Get data value.\"\"\"\n    return self._data.get(key, default)\n</code></pre> <p>Get data value.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.set_data","title":"<code>set_data(key, value)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def set_data(self, key: str, value: Any) -&gt; None:\n    \"\"\"Set data value.\"\"\"\n    old_value = self._data.get(key)\n    self._data[key] = value\n    self.events.mutation.dispatch(\n        MutationEventPayload(\n            transaction_id=self._transaction_id,\n            operation=\"set_data\",\n            details={\"key\": key, \"old_value\": old_value, \"new_value\": value},\n        )\n    )\n</code></pre> <p>Set data value.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.update_request","title":"<code>update_request(method=None, url=None, headers=None, content=None, from_scratch=False, preserve_existing_headers=True)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def update_request(\n    self,\n    method: Optional[str] = None,\n    url: Optional[str] = None,\n    headers: Optional[Dict[str, str]] = None,\n    content: Optional[bytes] = None,\n    from_scratch: bool = False,\n    preserve_existing_headers: bool = True,\n) -&gt; httpx.Request:\n    \"\"\"Create or set the request.\"\"\"\n    differences = {}\n    if from_scratch or self._request is None:\n        if not all([method, url]):\n            raise ValueError(\"Attempted to create new request, but method and url are required\")\n        method = str(method)\n        url = str(url)\n        self._request = httpx.Request(method=method, url=url, headers=headers, content=content)\n        differences = {\n            k: {\"old\": None, \"new\": getattr(self._request, k)} for k in [\"method\", \"url\", \"headers\", \"content\"]\n        }\n    else:\n        if method is not None:\n            differences[\"method\"] = {\"old\": self._request.method, \"new\": method}\n            self._request.method = method\n        if url is not None:\n            differences[\"url\"] = {\"old\": self._request.url, \"new\": url}\n            self._request.url = httpx.URL(url)\n        if headers is not None:\n            header_diffs = _update_headers(self._request, headers, preserve_existing_headers)\n            differences[\"headers\"] = header_diffs\n        if content is not None:\n            differences[\"content\"] = {\"old\": self._request.content, \"new\": content}\n            self._request._content = content\n\n    self.events.mutation.dispatch(\n        MutationEventPayload(\n            transaction_id=self._transaction_id,\n            operation=\"set_request\",\n            details=differences,\n        )\n    )\n    return self._request\n</code></pre> <p>Create or set the request.</p>"},{"location":"#luthien_control.core.tracked_context.TrackedContext.update_response","title":"<code>update_response(status_code=None, content=None, headers=None, from_scratch=False, preserve_existing_headers=True)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def update_response(\n    self,\n    status_code: Optional[int] = None,\n    content: Optional[bytes] = None,\n    headers: Optional[Dict[str, str]] = None,\n    from_scratch: bool = False,\n    preserve_existing_headers: bool = True,\n) -&gt; httpx.Response:\n    \"\"\"Update the response.\"\"\"\n    differences = {}\n    if from_scratch or self._response is None:\n        if not status_code:\n            raise ValueError(\"Attempted to create new response, but status_code is required\")\n        status_code = int(status_code)\n        self._response = httpx.Response(\n            status_code=status_code,\n            headers=headers,\n            content=content,\n        )\n        differences = {\n            k: {\"old\": None, \"new\": getattr(self._response, k)} for k in [\"status_code\", \"headers\", \"content\"]\n        }\n    else:\n        if status_code is not None:\n            differences[\"status_code\"] = {\"old\": self._response.status_code, \"new\": status_code}\n            self._response.status_code = status_code\n        if headers is not None:\n            differences[\"headers\"] = _update_headers(self._response, headers, preserve_existing_headers)\n        if content is not None:\n            differences[\"content\"] = {\"old\": self._response.content, \"new\": content}\n            self._response._content = content\n\n    self.events.mutation.dispatch(\n        MutationEventPayload(\n            transaction_id=self._transaction_id,\n            operation=\"set_response\",\n            details=differences,\n        )\n    )\n    return self._response\n</code></pre> <p>Update the response.</p>"},{"location":"#luthien_control.core.tracked_context.get_tx_value","title":"<code>get_tx_value(tracked_context, path)</code>","text":"Source code in <code>luthien_control/core/tracked_context/util.py</code> <pre><code>def get_tx_value(tracked_context: TrackedContext, path: str) -&gt; Any:\n    \"\"\"Get a value from the tracked context using a path.\n\n    Args:\n        tracked_context: The tracked context.\n        path: The path to the value e.g. \"request.headers.user-agent\", \"response.status_code\", \"data.user_id\".\n\n    Returns:\n        The value at the path.\n\n    Raises:\n        ValueError: If the path is invalid or the value cannot be accessed.\n    \"\"\"\n    vals = path.split(\".\")\n    if len(vals) &lt; 2:\n        raise ValueError(\"Path must contain at least two components\")\n\n    # Handle the first segment specially for TrackedContext\n    first_segment = vals.pop(0)\n    if first_segment == \"request\":\n        if tracked_context.request is None:\n            raise ValueError(\"Request is None in tracked context\")\n        x: Any = tracked_context.request\n    elif first_segment == \"response\":\n        if tracked_context.response is None:\n            raise ValueError(\"Response is None in tracked context\")\n        x = tracked_context.response\n    elif first_segment == \"data\":\n        x = tracked_context.get_all_data()\n    else:\n        raise ValueError(f\"Invalid path segment: {first_segment}\")\n\n    for next_segment in vals:\n        if isinstance(x, bytes):\n            try:\n                x = json.loads(x)\n            except json.JSONDecodeError as e:\n                # Wrapping the original error for better diagnostics\n                raise ValueError(f\"Failed to decode JSON content for path '{path}' at segment '{next_segment}'\") from e\n\n        if isinstance(x, dict):\n            x = x[next_segment]\n        else:\n            x = getattr(x, next_segment)\n    return x\n</code></pre> <p>Get a value from the tracked context using a path.</p> <p>Parameters:</p> Name Type Description Default <code>tracked_context</code> <code>TrackedContext</code> <p>The tracked context.</p> required <code>path</code> <code>str</code> <p>The path to the value e.g. \"request.headers.user-agent\", \"response.status_code\", \"data.user_id\".</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value at the path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is invalid or the value cannot be accessed.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context","title":"<code>tracked_context</code>","text":"<p>TrackedContext with explicit mutation API and event tracking.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.MutationEventPayload","title":"<code>MutationEventPayload</code>  <code>dataclass</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>@dataclass\nclass MutationEventPayload:\n    \"\"\"Record of an explicit mutation.\"\"\"\n\n    transaction_id: Optional[uuid.UUID]\n    operation: str  # e.g., \"set_header\", \"set_response_status\"\n    details: Dict[str, Any]\n</code></pre> <p>Record of an explicit mutation.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext","title":"<code>TrackedContext</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>class TrackedContext:\n    \"\"\"Transaction context with explicit mutation API and event tracking.\"\"\"\n\n    def __init__(self, transaction_id: Optional[uuid.UUID] = None):\n        \"\"\"Initialize tracked context.\"\"\"\n        self._transaction_id = transaction_id or uuid.uuid4()\n        self._request: Optional[httpx.Request] = None\n        self._response: Optional[httpx.Response] = None\n        self._data: Dict[str, Any] = {}\n        self.events = ContextEvents()\n\n    @property\n    def transaction_id(self) -&gt; uuid.UUID:\n        \"\"\"Get transaction ID.\"\"\"\n        return self._transaction_id\n\n    def update_request(\n        self,\n        method: Optional[str] = None,\n        url: Optional[str] = None,\n        headers: Optional[Dict[str, str]] = None,\n        content: Optional[bytes] = None,\n        from_scratch: bool = False,\n        preserve_existing_headers: bool = True,\n    ) -&gt; httpx.Request:\n        \"\"\"Create or set the request.\"\"\"\n        differences = {}\n        if from_scratch or self._request is None:\n            if not all([method, url]):\n                raise ValueError(\"Attempted to create new request, but method and url are required\")\n            method = str(method)\n            url = str(url)\n            self._request = httpx.Request(method=method, url=url, headers=headers, content=content)\n            differences = {\n                k: {\"old\": None, \"new\": getattr(self._request, k)} for k in [\"method\", \"url\", \"headers\", \"content\"]\n            }\n        else:\n            if method is not None:\n                differences[\"method\"] = {\"old\": self._request.method, \"new\": method}\n                self._request.method = method\n            if url is not None:\n                differences[\"url\"] = {\"old\": self._request.url, \"new\": url}\n                self._request.url = httpx.URL(url)\n            if headers is not None:\n                header_diffs = _update_headers(self._request, headers, preserve_existing_headers)\n                differences[\"headers\"] = header_diffs\n            if content is not None:\n                differences[\"content\"] = {\"old\": self._request.content, \"new\": content}\n                self._request._content = content\n\n        self.events.mutation.dispatch(\n            MutationEventPayload(\n                transaction_id=self._transaction_id,\n                operation=\"set_request\",\n                details=differences,\n            )\n        )\n        return self._request\n\n    @property\n    def request(self) -&gt; Optional[httpx.Request]:\n        \"\"\"Get a copy of the tracked request.\"\"\"\n        return copy(self._request)\n\n    def update_response(\n        self,\n        status_code: Optional[int] = None,\n        content: Optional[bytes] = None,\n        headers: Optional[Dict[str, str]] = None,\n        from_scratch: bool = False,\n        preserve_existing_headers: bool = True,\n    ) -&gt; httpx.Response:\n        \"\"\"Update the response.\"\"\"\n        differences = {}\n        if from_scratch or self._response is None:\n            if not status_code:\n                raise ValueError(\"Attempted to create new response, but status_code is required\")\n            status_code = int(status_code)\n            self._response = httpx.Response(\n                status_code=status_code,\n                headers=headers,\n                content=content,\n            )\n            differences = {\n                k: {\"old\": None, \"new\": getattr(self._response, k)} for k in [\"status_code\", \"headers\", \"content\"]\n            }\n        else:\n            if status_code is not None:\n                differences[\"status_code\"] = {\"old\": self._response.status_code, \"new\": status_code}\n                self._response.status_code = status_code\n            if headers is not None:\n                differences[\"headers\"] = _update_headers(self._response, headers, preserve_existing_headers)\n            if content is not None:\n                differences[\"content\"] = {\"old\": self._response.content, \"new\": content}\n                self._response._content = content\n\n        self.events.mutation.dispatch(\n            MutationEventPayload(\n                transaction_id=self._transaction_id,\n                operation=\"set_response\",\n                details=differences,\n            )\n        )\n        return self._response\n\n    @property\n    def response(self) -&gt; Optional[httpx.Response]:\n        \"\"\"Get a copy of the tracked response.\"\"\"\n        return copy(self._response)\n\n    def get_data(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get data value.\"\"\"\n        return self._data.get(key, default)\n\n    def set_data(self, key: str, value: Any) -&gt; None:\n        \"\"\"Set data value.\"\"\"\n        old_value = self._data.get(key)\n        self._data[key] = value\n        self.events.mutation.dispatch(\n            MutationEventPayload(\n                transaction_id=self._transaction_id,\n                operation=\"set_data\",\n                details={\"key\": key, \"old_value\": old_value, \"new_value\": value},\n            )\n        )\n\n    def get_all_data(self) -&gt; Dict[str, Any]:\n        \"\"\"Get copy of all data.\"\"\"\n        return self._data.copy()\n</code></pre> <p>Transaction context with explicit mutation API and event tracking.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.request","title":"<code>property</code>","text":"<p>Get a copy of the tracked request.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.request","title":"<code>request</code>  <code>property</code>","text":"<p>Get a copy of the tracked request.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.response","title":"<code>property</code>","text":"<p>Get a copy of the tracked response.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.response","title":"<code>response</code>  <code>property</code>","text":"<p>Get a copy of the tracked response.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.transaction_id","title":"<code>property</code>","text":"<p>Get transaction ID.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.transaction_id","title":"<code>transaction_id</code>  <code>property</code>","text":"<p>Get transaction ID.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.__init__","title":"<code>__init__(transaction_id=None)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def __init__(self, transaction_id: Optional[uuid.UUID] = None):\n    \"\"\"Initialize tracked context.\"\"\"\n    self._transaction_id = transaction_id or uuid.uuid4()\n    self._request: Optional[httpx.Request] = None\n    self._response: Optional[httpx.Response] = None\n    self._data: Dict[str, Any] = {}\n    self.events = ContextEvents()\n</code></pre> <p>Initialize tracked context.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.get_all_data","title":"<code>get_all_data()</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def get_all_data(self) -&gt; Dict[str, Any]:\n    \"\"\"Get copy of all data.\"\"\"\n    return self._data.copy()\n</code></pre> <p>Get copy of all data.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.get_data","title":"<code>get_data(key, default=None)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def get_data(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Get data value.\"\"\"\n    return self._data.get(key, default)\n</code></pre> <p>Get data value.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.set_data","title":"<code>set_data(key, value)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def set_data(self, key: str, value: Any) -&gt; None:\n    \"\"\"Set data value.\"\"\"\n    old_value = self._data.get(key)\n    self._data[key] = value\n    self.events.mutation.dispatch(\n        MutationEventPayload(\n            transaction_id=self._transaction_id,\n            operation=\"set_data\",\n            details={\"key\": key, \"old_value\": old_value, \"new_value\": value},\n        )\n    )\n</code></pre> <p>Set data value.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.update_request","title":"<code>update_request(method=None, url=None, headers=None, content=None, from_scratch=False, preserve_existing_headers=True)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def update_request(\n    self,\n    method: Optional[str] = None,\n    url: Optional[str] = None,\n    headers: Optional[Dict[str, str]] = None,\n    content: Optional[bytes] = None,\n    from_scratch: bool = False,\n    preserve_existing_headers: bool = True,\n) -&gt; httpx.Request:\n    \"\"\"Create or set the request.\"\"\"\n    differences = {}\n    if from_scratch or self._request is None:\n        if not all([method, url]):\n            raise ValueError(\"Attempted to create new request, but method and url are required\")\n        method = str(method)\n        url = str(url)\n        self._request = httpx.Request(method=method, url=url, headers=headers, content=content)\n        differences = {\n            k: {\"old\": None, \"new\": getattr(self._request, k)} for k in [\"method\", \"url\", \"headers\", \"content\"]\n        }\n    else:\n        if method is not None:\n            differences[\"method\"] = {\"old\": self._request.method, \"new\": method}\n            self._request.method = method\n        if url is not None:\n            differences[\"url\"] = {\"old\": self._request.url, \"new\": url}\n            self._request.url = httpx.URL(url)\n        if headers is not None:\n            header_diffs = _update_headers(self._request, headers, preserve_existing_headers)\n            differences[\"headers\"] = header_diffs\n        if content is not None:\n            differences[\"content\"] = {\"old\": self._request.content, \"new\": content}\n            self._request._content = content\n\n    self.events.mutation.dispatch(\n        MutationEventPayload(\n            transaction_id=self._transaction_id,\n            operation=\"set_request\",\n            details=differences,\n        )\n    )\n    return self._request\n</code></pre> <p>Create or set the request.</p>"},{"location":"#luthien_control.core.tracked_context.tracked_context.TrackedContext.update_response","title":"<code>update_response(status_code=None, content=None, headers=None, from_scratch=False, preserve_existing_headers=True)</code>","text":"Source code in <code>luthien_control/core/tracked_context/tracked_context.py</code> <pre><code>def update_response(\n    self,\n    status_code: Optional[int] = None,\n    content: Optional[bytes] = None,\n    headers: Optional[Dict[str, str]] = None,\n    from_scratch: bool = False,\n    preserve_existing_headers: bool = True,\n) -&gt; httpx.Response:\n    \"\"\"Update the response.\"\"\"\n    differences = {}\n    if from_scratch or self._response is None:\n        if not status_code:\n            raise ValueError(\"Attempted to create new response, but status_code is required\")\n        status_code = int(status_code)\n        self._response = httpx.Response(\n            status_code=status_code,\n            headers=headers,\n            content=content,\n        )\n        differences = {\n            k: {\"old\": None, \"new\": getattr(self._response, k)} for k in [\"status_code\", \"headers\", \"content\"]\n        }\n    else:\n        if status_code is not None:\n            differences[\"status_code\"] = {\"old\": self._response.status_code, \"new\": status_code}\n            self._response.status_code = status_code\n        if headers is not None:\n            differences[\"headers\"] = _update_headers(self._response, headers, preserve_existing_headers)\n        if content is not None:\n            differences[\"content\"] = {\"old\": self._response.content, \"new\": content}\n            self._response._content = content\n\n    self.events.mutation.dispatch(\n        MutationEventPayload(\n            transaction_id=self._transaction_id,\n            operation=\"set_response\",\n            details=differences,\n        )\n    )\n    return self._response\n</code></pre> <p>Update the response.</p>"},{"location":"#luthien_control.core.tracked_context.util","title":"<code>util</code>","text":"<p>Utilities for working with TrackedContext.</p>"},{"location":"#luthien_control.core.tracked_context.util.get_tx_value","title":"<code>get_tx_value(tracked_context, path)</code>","text":"Source code in <code>luthien_control/core/tracked_context/util.py</code> <pre><code>def get_tx_value(tracked_context: TrackedContext, path: str) -&gt; Any:\n    \"\"\"Get a value from the tracked context using a path.\n\n    Args:\n        tracked_context: The tracked context.\n        path: The path to the value e.g. \"request.headers.user-agent\", \"response.status_code\", \"data.user_id\".\n\n    Returns:\n        The value at the path.\n\n    Raises:\n        ValueError: If the path is invalid or the value cannot be accessed.\n    \"\"\"\n    vals = path.split(\".\")\n    if len(vals) &lt; 2:\n        raise ValueError(\"Path must contain at least two components\")\n\n    # Handle the first segment specially for TrackedContext\n    first_segment = vals.pop(0)\n    if first_segment == \"request\":\n        if tracked_context.request is None:\n            raise ValueError(\"Request is None in tracked context\")\n        x: Any = tracked_context.request\n    elif first_segment == \"response\":\n        if tracked_context.response is None:\n            raise ValueError(\"Response is None in tracked context\")\n        x = tracked_context.response\n    elif first_segment == \"data\":\n        x = tracked_context.get_all_data()\n    else:\n        raise ValueError(f\"Invalid path segment: {first_segment}\")\n\n    for next_segment in vals:\n        if isinstance(x, bytes):\n            try:\n                x = json.loads(x)\n            except json.JSONDecodeError as e:\n                # Wrapping the original error for better diagnostics\n                raise ValueError(f\"Failed to decode JSON content for path '{path}' at segment '{next_segment}'\") from e\n\n        if isinstance(x, dict):\n            x = x[next_segment]\n        else:\n            x = getattr(x, next_segment)\n    return x\n</code></pre> <p>Get a value from the tracked context using a path.</p> <p>Parameters:</p> Name Type Description Default <code>tracked_context</code> <code>TrackedContext</code> <p>The tracked context.</p> required <code>path</code> <code>str</code> <p>The path to the value e.g. \"request.headers.user-agent\", \"response.status_code\", \"data.user_id\".</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value at the path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is invalid or the value cannot be accessed.</p>"},{"location":"#luthien_control.core.transaction","title":"<code>transaction</code>","text":""},{"location":"#luthien_control.core.transaction.Transaction","title":"<code>Transaction</code>","text":"<p>           Bases: <code>DeepEventedModel</code></p> Source code in <code>luthien_control/core/transaction.py</code> <pre><code>class Transaction(DeepEventedModel):\n    \"\"\"A transaction between the Luthien Control API and the client.\"\"\"\n\n    transaction_id: UUID = Field(default_factory=uuid4)\n    request: Request = Field()\n    response: Response = Field()\n    data: EventedDict[str, Any] = Field(default_factory=EventedDict)\n</code></pre> <p>A transaction between the Luthien Control API and the client.</p>"},{"location":"#luthien_control.core.transaction_context","title":"<code>transaction_context</code>","text":""},{"location":"#luthien_control.core.transaction_context.TransactionContext","title":"<code>TransactionContext</code>  <code>dataclass</code>","text":"Source code in <code>luthien_control/core/transaction_context.py</code> <pre><code>@dataclass\nclass TransactionContext:\n    \"\"\"Holds the state for a single transaction through the proxy.\n\n    Attributes:\n        transaction_id: A unique identifier for the transaction.\n        request: The incoming HTTP request object.\n        response: The outgoing HTTP response object.\n        data: A general-purpose dictionary for policies to store and share\n            information related to this transaction.\n    \"\"\"\n\n    # Core Identifiers and State\n    transaction_id: uuid.UUID = field(default_factory=uuid.uuid4)\n    request: Optional[Request] = None\n    response: Optional[Response] = None\n\n    # General purpose data store for policies to share information\n    data: Dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>Holds the state for a single transaction through the proxy.</p> <p>Attributes:</p> Name Type Description <code>transaction_id</code> <code>UUID</code> <p>A unique identifier for the transaction.</p> <code>request</code> <code>Optional[Request]</code> <p>The incoming HTTP request object.</p> <code>response</code> <code>Optional[Response]</code> <p>The outgoing HTTP response object.</p> <code>data</code> <code>Dict[str, Any]</code> <p>A general-purpose dictionary for policies to store and share information related to this transaction.</p>"},{"location":"#luthien_control.core.transaction_context.get_tx_value","title":"<code>get_tx_value(transaction_context, path)</code>","text":"Source code in <code>luthien_control/core/transaction_context.py</code> <pre><code>def get_tx_value(transaction_context: TransactionContext, path: str) -&gt; Any:\n    \"\"\"Get a value from the transaction context using a path.\n\n    Args:\n        transaction_context: The transaction context.\n        path: The path to the value e.g. \"request.headers.user-agent\", \"response.status_code\", \"data.user_id\".\n\n    Returns:\n        The value at the path.\n\n    Raises:\n        ValueError: If the path is invalid or the value cannot be accessed.\n        TypeError: If the transaction_id is not a UUID.\n    \"\"\"\n    vals = path.split(\".\")\n    if len(vals) &lt; 2:\n        raise ValueError(\"Path must contain at least two components\")\n\n    x: Any = getattr(transaction_context, vals.pop(0))\n    while vals:\n        # If x is bytes, and we still have path segments to process,\n        # it implies these segments are keys into the JSON content.\n        if isinstance(x, bytes) and vals:  # Check if vals is not empty\n            x = json.loads(x)\n\n        if isinstance(x, dict):\n            x = x[vals.pop(0)]\n        else:\n            x = getattr(x, vals.pop(0))\n    return x\n</code></pre> <p>Get a value from the transaction context using a path.</p> <p>Parameters:</p> Name Type Description Default <code>transaction_context</code> <code>TransactionContext</code> <p>The transaction context.</p> required <code>path</code> <code>str</code> <p>The path to the value e.g. \"request.headers.user-agent\", \"response.status_code\", \"data.user_id\".</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value at the path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is invalid or the value cannot be accessed.</p> <code>TypeError</code> <p>If the transaction_id is not a UUID.</p>"},{"location":"#luthien_control.custom_openapi_schema","title":"<code>custom_openapi_schema</code>","text":""},{"location":"#luthien_control.custom_openapi_schema.create_custom_openapi","title":"<code>create_custom_openapi(app)</code>","text":"Source code in <code>luthien_control/custom_openapi_schema.py</code> <pre><code>def create_custom_openapi(app: FastAPI):\n    \"\"\"\n    Generate a custom OpenAPI schema for the FastAPI application.\n\n    This function retrieves the default schema and modifies it, specifically\n    to set `allowReserved=True` for the `full_path` path parameter used\n    in proxy routes. This is necessary for correctly handling URLs containing\n    reserved characters within that path segment.\n\n    Args:\n        app: The FastAPI application instance.\n\n    Returns:\n        The modified OpenAPI schema dictionary.\n    \"\"\"\n    # Check if schema already exists to avoid redundant generation\n    if app.openapi_schema:\n        return app.openapi_schema\n\n    logger.debug(\"Generating custom OpenAPI schema.\")\n    openapi_schema = get_openapi(\n        title=app.title,\n        version=app.version,\n        description=app.description,\n        routes=app.routes,\n    )\n\n    # Modify the schema for the path parameter\n    paths = openapi_schema.get(\"paths\", {})\n    logger.debug(f\"Found {len(paths)} paths in schema. Searching for '{{full_path}}'.\")\n    for path_key, path_item in paths.items():\n        if \"{full_path}\" in path_key:\n            logger.debug(f\"Processing path: {path_key}\")\n            # path_item contains methods like 'get', 'post', etc.\n            for method, method_item in path_item.items():\n                # Ensure 'parameters' exists and is a list\n                parameters = method_item.get(\"parameters\", [])\n                if not isinstance(parameters, list):\n                    logger.warning(f\"Unexpected 'parameters' format in {path_key} -&gt; {method}. Skipping.\")\n                    continue\n\n                found_param = False\n                for param in parameters:\n                    # Ensure param is a dictionary and has 'name' and 'in' keys\n                    if not isinstance(param, dict) or \"name\" not in param or \"in\" not in param:\n                        logger.warning(\n                            f\"Malformed parameter definition in {path_key} -&gt; {method}. Skipping param: {param}\"\n                        )\n                        continue\n\n                    if param[\"name\"] == \"full_path\" and param[\"in\"] == \"path\":\n                        param[\"allowReserved\"] = True\n                        found_param = True\n                        logger.info(f\"Set allowReserved=true for 'full_path' parameter in {path_key} -&gt; {method}\")\n                        # Assuming only one 'full_path' param per method\n                        break  # No need to check other params for this method\n                if not found_param:\n                    logger.debug(f\"No 'full_path' path parameter found in {path_key} -&gt; {method}\")\n\n    # Cache the generated schema in the app instance\n    app.openapi_schema = openapi_schema\n    logger.debug(\"Custom OpenAPI schema generation complete.\")\n    return app.openapi_schema\n</code></pre> <p>Generate a custom OpenAPI schema for the FastAPI application.</p> <p>This function retrieves the default schema and modifies it, specifically to set <code>allowReserved=True</code> for the <code>full_path</code> path parameter used in proxy routes. This is necessary for correctly handling URLs containing reserved characters within that path segment.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI application instance.</p> required <p>Returns:</p> Type Description <p>The modified OpenAPI schema dictionary.</p>"},{"location":"#luthien_control.db","title":"<code>db</code>","text":"<p>Database models and session management.</p>"},{"location":"#luthien_control.db.ControlPolicy","title":"<code>ControlPolicy</code>","text":"<p>           Bases: <code>SQLModel</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class ControlPolicy(SQLModel, table=True):\n    __tablename__ = \"policies\"  # type: ignore (again, shut up pyright)\n    \"\"\"Database model for storing control policy configurations.\"\"\"\n\n    # Primary key\n    id: Optional[int] = Field(default=None, primary_key=True)\n\n    # --- Core Fields ---\n    name: str = Field(index=True, unique=True)  # Unique name used for lookup\n    type: str = Field()  # Type of policy, used for instantiation\n    config: dict[str, Any] = Field(default={}, sa_column=Column(JSON))\n    is_active: bool = Field(default=True, index=True)\n    description: Optional[str] = Field(default=None)\n\n    # --- Timestamps ---\n    created_at: dt.datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc).replace(tzinfo=None), nullable=False\n    )\n    updated_at: dt.datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc).replace(tzinfo=None), nullable=False\n    )\n\n    def __init__(self, **data: Any):\n        # Ensure timestamps are set on creation if not provided\n        if \"created_at\" not in data:\n            data[\"created_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n        if \"updated_at\" not in data:\n            data[\"updated_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n        super().__init__(**data)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_timestamps(cls, values):\n        \"\"\"Ensure updated_at is always set/updated.\"\"\"\n        if isinstance(values, dict):\n            values[\"updated_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n        return values\n</code></pre>"},{"location":"#luthien_control.db.ControlPolicy.__tablename__","title":"<code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database model for storing control policy configurations.</p>"},{"location":"#luthien_control.db.ControlPolicy.__tablename__","title":"<code>__tablename__ = 'policies'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database model for storing control policy configurations.</p>"},{"location":"#luthien_control.db.ControlPolicy.validate_timestamps","title":"<code>validate_timestamps(values)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef validate_timestamps(cls, values):\n    \"\"\"Ensure updated_at is always set/updated.\"\"\"\n    if isinstance(values, dict):\n        values[\"updated_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n    return values\n</code></pre> <p>Ensure updated_at is always set/updated.</p>"},{"location":"#luthien_control.db.LuthienLog","title":"<code>LuthienLog</code>","text":"<p>           Bases: <code>SQLModel</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class LuthienLog(SQLModel, table=True):\n    \"\"\"\n    Represents a log entry in the Luthien logging system using SQLModel.\n\n    Attributes:\n        id: Unique identifier for the log entry (primary key).\n        transaction_id: Identifier to group related log entries.\n        datetime: Timestamp indicating when the log entry was generated (timezone-aware).\n        data: JSON blob containing the primary logged data.\n        datatype: String identifier for the nature and schema of 'data'.\n        notes: JSON blob for additional contextual information.\n    \"\"\"\n\n    __tablename__ = \"luthien_log\"  # type: ignore (shut up pyright)\n\n    id: Optional[int] = Field(default=None, primary_key=True, index=True)\n    transaction_id: str = Field(index=True, nullable=False)\n    datetime: NaiveDatetime = Field(\n        default_factory=NaiveDatetime.now,\n        nullable=False,\n        index=True,\n    )\n    data: Optional[dict[str, Any]] = Field(default=None, sa_column=Column(JsonBOrJson))\n    datatype: str = Field(index=True, nullable=False)\n    notes: Optional[dict[str, Any]] = Field(default=None, sa_column=Column(JsonBOrJson))\n\n    def __init__(self, **data: Any) -&gt; None:\n        \"\"\"Override init to ensure datetime is converted to NaiveDatetime.\"\"\"\n        if \"datetime\" in data:\n            dt_value = data[\"datetime\"]\n            if isinstance(dt_value, datetime) and not isinstance(dt_value, NaiveDatetime):\n                data[\"datetime\"] = NaiveDatetime(dt_value)\n        super().__init__(**data)\n\n    # __table_args__ = (\n    #     Index(\"ix_sqlmodel_luthien_log_transaction_id\", \"transaction_id\"),\n    #     Index(\"ix_sqlmodel_luthien_log_datetime\", \"datetime\"),\n    #     Index(\"ix_sqlmodel_luthien_log_datatype\", \"datatype\"),\n    #     {\"extend_existing\": True},\n    # )\n\n    # __repr__ is not automatically generated by SQLModel like Pydantic models,\n    # but you can add one if desired.\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;LuthienLog(id={self.id}, \"\n            f\"transaction_id='{self.transaction_id}', \"\n            f\"datetime='{self.datetime}', \"\n            f\"datatype='{self.datatype}')&gt;\"\n        )\n</code></pre> <p>Represents a log entry in the Luthien logging system using SQLModel.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[int]</code> <p>Unique identifier for the log entry (primary key).</p> <code>transaction_id</code> <code>str</code> <p>Identifier to group related log entries.</p> <code>datetime</code> <code>NaiveDatetime</code> <p>Timestamp indicating when the log entry was generated (timezone-aware).</p> <code>data</code> <code>Optional[dict[str, Any]]</code> <p>JSON blob containing the primary logged data.</p> <code>datatype</code> <code>str</code> <p>String identifier for the nature and schema of 'data'.</p> <code>notes</code> <code>Optional[dict[str, Any]]</code> <p>JSON blob for additional contextual information.</p>"},{"location":"#luthien_control.db.LuthienLog.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    \"\"\"Override init to ensure datetime is converted to NaiveDatetime.\"\"\"\n    if \"datetime\" in data:\n        dt_value = data[\"datetime\"]\n        if isinstance(dt_value, datetime) and not isinstance(dt_value, NaiveDatetime):\n            data[\"datetime\"] = NaiveDatetime(dt_value)\n    super().__init__(**data)\n</code></pre> <p>Override init to ensure datetime is converted to NaiveDatetime.</p>"},{"location":"#luthien_control.db.client_api_key_crud","title":"<code>client_api_key_crud</code>","text":""},{"location":"#luthien_control.db.client_api_key_crud.create_api_key","title":"<code>create_api_key(session, api_key)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/client_api_key_crud.py</code> <pre><code>async def create_api_key(session: AsyncSession, api_key: ClientApiKey) -&gt; ClientApiKey:\n    \"\"\"Create a new API key in the database.\n\n    Args:\n        session: The database session\n        api_key: The API key to create\n\n    Returns:\n        The created API key with updated ID\n\n    Raises:\n        LuthienDBIntegrityError: If a constraint violation occurs\n        LuthienDBTransactionError: If the transaction fails\n        LuthienDBOperationError: For other database errors\n    \"\"\"\n    try:\n        session.add(api_key)\n        await session.commit()\n        await session.refresh(api_key)\n        logger.info(f\"Successfully created API key with ID: {api_key.id}\")\n        return api_key\n    except IntegrityError as ie:\n        await session.rollback()\n        logger.error(f\"Integrity error creating API key: {ie}\")\n        raise LuthienDBIntegrityError(f\"Could not create API key due to constraint violation: {ie}\", ie) from ie\n    except SQLAlchemyError as sqla_err:\n        await session.rollback()\n        logger.error(f\"SQLAlchemy error creating API key: {sqla_err}\")\n        raise LuthienDBTransactionError(f\"Database transaction failed while creating API key: {sqla_err}\") from sqla_err\n    except Exception as e:\n        await session.rollback()\n        logger.error(f\"Unexpected error creating API key: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during API key creation: {e}\") from e\n</code></pre> <p>Create a new API key in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>api_key</code> <code>ClientApiKey</code> <p>The API key to create</p> required <p>Returns:</p> Type Description <code>ClientApiKey</code> <p>The created API key with updated ID</p> <p>Raises:</p> Type Description <code>LuthienDBIntegrityError</code> <p>If a constraint violation occurs</p> <code>LuthienDBTransactionError</code> <p>If the transaction fails</p> <code>LuthienDBOperationError</code> <p>For other database errors</p>"},{"location":"#luthien_control.db.client_api_key_crud.get_api_key_by_value","title":"<code>get_api_key_by_value(session, key_value)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/client_api_key_crud.py</code> <pre><code>async def get_api_key_by_value(session: AsyncSession, key_value: str) -&gt; ClientApiKey:\n    \"\"\"Get an active API key by its value.\n\n    Args:\n        session: The database session\n        key_value: The value of the API key to retrieve\n\n    Returns:\n        The API key\n\n    Raises:\n        LuthienDBQueryError: If the API key is not found or if the query execution fails\n        LuthienDBOperationError: For unexpected errors during lookup\n    \"\"\"\n    try:\n        stmt = select(ClientApiKey).where(\n            ClientApiKey.key_value == key_value,  # type: ignore[arg-type]\n            ClientApiKey.is_active,  # type: ignore[arg-type]\n        )\n        result = await session.execute(stmt)\n        api_key = result.scalar_one_or_none()\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error fetching API key by value: {sqla_err}\", exc_info=True)\n        raise LuthienDBQueryError(f\"Database query failed while fetching API key: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error fetching API key by value: {e}\", exc_info=True)\n        raise LuthienDBOperationError(f\"Unexpected error during API key lookup: {e}\") from e\n\n    if not api_key:\n        raise LuthienDBQueryError(f\"Active API key with value '{key_value}' not found\")\n\n    return api_key\n</code></pre> <p>Get an active API key by its value.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>key_value</code> <code>str</code> <p>The value of the API key to retrieve</p> required <p>Returns:</p> Type Description <code>ClientApiKey</code> <p>The API key</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the API key is not found or if the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors during lookup</p>"},{"location":"#luthien_control.db.client_api_key_crud.list_api_keys","title":"<code>list_api_keys(session, active_only=False)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/client_api_key_crud.py</code> <pre><code>async def list_api_keys(session: AsyncSession, active_only: bool = False) -&gt; List[ClientApiKey]:\n    \"\"\"Get a list of all API keys.\n\n    Args:\n        session: The database session\n        active_only: If True, only return active API keys\n\n    Returns:\n        A list of API keys\n\n    Raises:\n        LuthienDBQueryError: If the query execution fails\n    \"\"\"\n    try:\n        if active_only:\n            stmt = select(ClientApiKey).where(ClientApiKey.is_active)  # type: ignore[arg-type]\n        else:\n            stmt = select(ClientApiKey)\n\n        result = await session.execute(stmt)\n        return list(result.scalars().all())\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error listing API keys: {sqla_err}\")\n        raise LuthienDBQueryError(f\"Database query failed while listing API keys: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error listing API keys: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during API key listing: {e}\") from e\n</code></pre> <p>Get a list of all API keys.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>active_only</code> <code>bool</code> <p>If True, only return active API keys</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ClientApiKey]</code> <p>A list of API keys</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the query execution fails</p>"},{"location":"#luthien_control.db.client_api_key_crud.update_api_key","title":"<code>update_api_key(session, key_id, api_key_update)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/client_api_key_crud.py</code> <pre><code>async def update_api_key(session: AsyncSession, key_id: int, api_key_update: ClientApiKey) -&gt; ClientApiKey:\n    \"\"\"Update an existing API key.\n\n    Args:\n        session: The database session\n        key_id: The ID of the API key to update\n        api_key_update: The updated API key data\n\n    Returns:\n        The updated API key\n\n    Raises:\n        LuthienDBQueryError: If the API key is not found\n        LuthienDBIntegrityError: If a constraint violation occurs\n        LuthienDBTransactionError: If the transaction fails\n        LuthienDBOperationError: For other database errors\n    \"\"\"\n    try:\n        stmt = select(ClientApiKey).where(ClientApiKey.id == key_id)  # type: ignore[arg-type]\n        result = await session.execute(stmt)\n        api_key = result.scalar_one_or_none()\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error updating API key: {sqla_err}\")\n        raise LuthienDBTransactionError(f\"Database transaction failed while updating API key: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error updating API key: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during API key update: {e}\") from e\n\n    if not api_key:\n        raise LuthienDBQueryError(f\"API key with ID {key_id} not found\")\n\n    try:\n        # Update fields\n        api_key.name = api_key_update.name\n        api_key.is_active = api_key_update.is_active\n        api_key.metadata_ = api_key_update.metadata_\n\n        await session.commit()\n        await session.refresh(api_key)\n        logger.info(f\"Successfully updated API key with ID: {api_key.id}\")\n        return api_key\n    except IntegrityError as ie:\n        await session.rollback()\n        logger.error(f\"Integrity error updating API key: {ie}\")\n        raise LuthienDBIntegrityError(f\"Could not update API key due to constraint violation: {ie}\", ie) from ie\n    except SQLAlchemyError as sqla_err:\n        await session.rollback()\n        logger.error(f\"SQLAlchemy error updating API key: {sqla_err}\")\n        raise LuthienDBTransactionError(f\"Database transaction failed while updating API key: {sqla_err}\") from sqla_err\n    except Exception as e:\n        await session.rollback()\n        logger.error(f\"Unexpected error updating API key: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during API key update: {e}\") from e\n</code></pre> <p>Update an existing API key.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>key_id</code> <code>int</code> <p>The ID of the API key to update</p> required <code>api_key_update</code> <code>ClientApiKey</code> <p>The updated API key data</p> required <p>Returns:</p> Type Description <code>ClientApiKey</code> <p>The updated API key</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the API key is not found</p> <code>LuthienDBIntegrityError</code> <p>If a constraint violation occurs</p> <code>LuthienDBTransactionError</code> <p>If the transaction fails</p> <code>LuthienDBOperationError</code> <p>For other database errors</p>"},{"location":"#luthien_control.db.control_policy_crud","title":"<code>control_policy_crud</code>","text":""},{"location":"#luthien_control.db.control_policy_crud.get_policy_by_name","title":"<code>get_policy_by_name(session, name)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/control_policy_crud.py</code> <pre><code>async def get_policy_by_name(session: AsyncSession, name: str) -&gt; DBControlPolicy:\n    \"\"\"Get a policy by its name.\n\n    Args:\n        session: The database session\n        name: The name of the policy to retrieve\n\n    Returns:\n        The policy\n\n    Raises:\n        LuthienDBQueryError: If the policy is not found or if the query execution fails\n        LuthienDBOperationError: For unexpected errors during lookup\n    \"\"\"\n    try:\n        stmt = select(DBControlPolicy).where(\n            DBControlPolicy.name == name,  # type: ignore[arg-type]\n            DBControlPolicy.is_active,  # type: ignore[arg-type]\n        )\n        result = await session.execute(stmt)\n        policy = result.scalar_one_or_none()\n        if not policy:\n            raise LuthienDBQueryError(f\"Policy with name '{name}' not found\")\n        return policy\n    except LuthienDBQueryError:\n        raise\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error fetching policy by name '{name}': {sqla_err}\", exc_info=True)\n        raise LuthienDBQueryError(f\"Database query failed while fetching policy '{name}': {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error fetching policy by name '{name}': {e}\", exc_info=True)\n        raise LuthienDBOperationError(f\"Unexpected error during policy lookup: {e}\") from e\n</code></pre> <p>Get a policy by its name.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>name</code> <code>str</code> <p>The name of the policy to retrieve</p> required <p>Returns:</p> Type Description <code>ControlPolicy</code> <p>The policy</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the policy is not found or if the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors during lookup</p>"},{"location":"#luthien_control.db.control_policy_crud.get_policy_config_by_name","title":"<code>get_policy_config_by_name(session, name)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/control_policy_crud.py</code> <pre><code>async def get_policy_config_by_name(session: AsyncSession, name: str) -&gt; DBControlPolicy:\n    \"\"\"Get a policy configuration by its name, regardless of its active status.\n\n    Args:\n        session: The database session\n        name: The name of the policy to retrieve\n\n    Returns:\n        The policy\n\n    Raises:\n        LuthienDBQueryError: If the policy is not found or if the query execution fails\n        LuthienDBOperationError: For unexpected errors during lookup\n    \"\"\"\n    try:\n        stmt = select(DBControlPolicy).where(DBControlPolicy.name == name)  # type: ignore[arg-type]\n        result = await session.execute(stmt)\n        policy = result.scalar_one_or_none()\n        if not policy:\n            raise LuthienDBQueryError(f\"Policy with name '{name}' not found\")\n        return policy\n    except LuthienDBQueryError:\n        raise\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error fetching policy configuration by name '{name}': {sqla_err}\", exc_info=True)\n        raise LuthienDBQueryError(f\"Database query failed while fetching policy config '{name}'\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error fetching policy configuration by name '{name}': {e}\", exc_info=True)\n        raise LuthienDBOperationError(f\"Unexpected error during policy config lookup: {e}\") from e\n</code></pre> <p>Get a policy configuration by its name, regardless of its active status.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>name</code> <code>str</code> <p>The name of the policy to retrieve</p> required <p>Returns:</p> Type Description <code>ControlPolicy</code> <p>The policy</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the policy is not found or if the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors during lookup</p>"},{"location":"#luthien_control.db.control_policy_crud.list_policies","title":"<code>list_policies(session, active_only=False)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/control_policy_crud.py</code> <pre><code>async def list_policies(session: AsyncSession, active_only: bool = False) -&gt; List[DBControlPolicy]:\n    \"\"\"Get a list of all policies.\n\n    Args:\n        session: The database session\n        active_only: If True, only return active policies\n\n    Returns:\n        A list of policies\n\n    Raises:\n        LuthienDBQueryError: If the query execution fails\n    \"\"\"\n    try:\n        if active_only:\n            stmt = select(DBControlPolicy).where(DBControlPolicy.is_active)  # type: ignore[arg-type]\n        else:\n            stmt = select(DBControlPolicy)\n\n        result = await session.execute(stmt)\n        return list(result.scalars().all())\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error listing policies: {sqla_err}\")\n        raise LuthienDBQueryError(f\"Database query failed while listing policies: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error listing policies: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during policy listing: {e}\") from e\n</code></pre> <p>Get a list of all policies.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>active_only</code> <code>bool</code> <p>If True, only return active policies</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ControlPolicy]</code> <p>A list of policies</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the query execution fails</p>"},{"location":"#luthien_control.db.control_policy_crud.load_policy_from_db","title":"<code>load_policy_from_db(name, container)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/control_policy_crud.py</code> <pre><code>async def load_policy_from_db(\n    name: str,\n    container: \"DependencyContainer\",\n) -&gt; \"ABCControlPolicy\":\n    \"\"\"Load a policy configuration from the database and instantiate it using the control_policy loader.\n\n    Args:\n        name: The name of the policy to load\n        container: The dependency container providing access to the database session\n\n    Returns:\n        The instantiated policy\n\n    Raises:\n        LuthienDBQueryError: If the database query fails or policy is not found\n        LuthienDBOperationError: If the policy cannot be instantiated or other database operation errors occur\n    \"\"\"\n    try:\n        async with container.db_session_factory() as session:\n            policy_name = await get_policy_by_name(session, name)\n\n        # Prepare the data for the simple loader\n        policy_data_dict = {\n            \"type\": policy_name.type,  # The loader uses this to find the class\n            \"config\": policy_name.config or {},\n        }\n\n        # Construct the SerializedPolicy dataclass instance\n        serialized_policy_obj = SerializedPolicy(type=policy_data_dict[\"type\"], config=policy_data_dict[\"config\"])\n\n        try:\n            instance = load_policy(serialized_policy_obj)\n            logger.info(f\"Successfully loaded and instantiated policy '{policy_name.name}' from database.\")\n            return instance\n        except PolicyLoadError as e:\n            logger.error(f\"Failed to load policy '{name}' from database: {e}\")\n            raise LuthienDBOperationError(\n                f\"Failed to instantiate policy '{name}' from database configuration: {e}\"\n            ) from e\n        except Exception as e:\n            logger.exception(f\"Unexpected error loading policy '{name}' from database: {e}\")\n            raise LuthienDBOperationError(f\"Unexpected error during policy instantiation for '{name}': {e}\") from e\n    except LuthienDBQueryError:\n        raise\n    except LuthienDBOperationError:\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error during policy loading process for '{name}': {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during policy loading process for '{name}': {e}\") from e\n</code></pre> <p>Load a policy configuration from the database and instantiate it using the control_policy loader.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the policy to load</p> required <code>container</code> <code>DependencyContainer</code> <p>The dependency container providing access to the database session</p> required <p>Returns:</p> Type Description <code>ControlPolicy</code> <p>The instantiated policy</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the database query fails or policy is not found</p> <code>LuthienDBOperationError</code> <p>If the policy cannot be instantiated or other database operation errors occur</p>"},{"location":"#luthien_control.db.control_policy_crud.save_policy_to_db","title":"<code>save_policy_to_db(session, policy)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/control_policy_crud.py</code> <pre><code>async def save_policy_to_db(session: AsyncSession, policy: DBControlPolicy) -&gt; DBControlPolicy:\n    \"\"\"Create a new policy in the database.\n\n    Args:\n        session: The database session\n        policy: The policy to create\n\n    Returns:\n        The created policy with updated ID\n\n    Raises:\n        LuthienDBIntegrityError: If a constraint violation occurs\n        LuthienDBTransactionError: If the transaction fails\n        LuthienDBOperationError: For other database errors\n    \"\"\"\n    try:\n        session.add(policy)\n        await session.commit()\n        await session.refresh(policy)\n        logger.info(f\"Successfully created policy with ID: {policy.id}\")\n        return policy\n    except IntegrityError as ie:\n        await session.rollback()\n        logger.error(f\"Integrity error creating policy: {ie}\")\n        raise LuthienDBIntegrityError(f\"Could not create policy due to constraint violation: {ie}\", ie) from ie\n    except SQLAlchemyError as sqla_err:\n        await session.rollback()\n        logger.error(f\"SQLAlchemy error creating policy: {sqla_err}\")\n        raise LuthienDBTransactionError(f\"Database transaction failed while creating policy: {sqla_err}\") from sqla_err\n    except Exception as e:\n        await session.rollback()\n        logger.error(f\"Error creating policy: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during policy creation: {e}\") from e\n</code></pre> <p>Create a new policy in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>policy</code> <code>ControlPolicy</code> <p>The policy to create</p> required <p>Returns:</p> Type Description <code>ControlPolicy</code> <p>The created policy with updated ID</p> <p>Raises:</p> Type Description <code>LuthienDBIntegrityError</code> <p>If a constraint violation occurs</p> <code>LuthienDBTransactionError</code> <p>If the transaction fails</p> <code>LuthienDBOperationError</code> <p>For other database errors</p>"},{"location":"#luthien_control.db.control_policy_crud.update_policy","title":"<code>update_policy(session, policy_id, policy_update)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/control_policy_crud.py</code> <pre><code>async def update_policy(session: AsyncSession, policy_id: int, policy_update: DBControlPolicy) -&gt; DBControlPolicy:\n    \"\"\"Update an existing policy.\n\n    Args:\n        session: The database session\n        policy_id: The ID of the policy to update\n        policy_update: The updated policy data\n\n    Returns:\n        The updated policy\n\n    Raises:\n        LuthienDBQueryError: If the policy is not found\n        LuthienDBIntegrityError: If a constraint violation occurs\n        LuthienDBTransactionError: If the transaction fails\n        LuthienDBOperationError: For other database errors\n    \"\"\"\n    try:\n        stmt = select(DBControlPolicy).where(DBControlPolicy.id == policy_id)  # type: ignore[arg-type]\n        result = await session.execute(stmt)\n        policy = result.scalar_one_or_none()\n\n        if not policy:\n            raise LuthienDBQueryError(f\"Policy with ID {policy_id} not found\")\n\n        # Update fields\n        policy.name = policy_update.name\n        policy.config = policy_update.config\n        policy.is_active = policy_update.is_active\n        policy.description = policy_update.description\n\n        await session.commit()\n        await session.refresh(policy)\n        logger.info(f\"Successfully updated policy with ID: {policy.id}\")\n        return policy\n    except LuthienDBQueryError:\n        raise\n    except IntegrityError as ie:\n        await session.rollback()\n        logger.error(f\"Integrity error updating policy: {ie}\")\n        raise LuthienDBIntegrityError(f\"Could not update policy due to constraint violation: {ie}\", ie) from ie\n    except SQLAlchemyError as sqla_err:\n        await session.rollback()\n        logger.error(f\"SQLAlchemy error updating policy: {sqla_err}\")\n        raise LuthienDBTransactionError(f\"Database transaction failed while updating policy: {sqla_err}\") from sqla_err\n    except Exception as e:\n        await session.rollback()\n        logger.error(f\"Error updating policy: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during policy update: {e}\") from e\n</code></pre> <p>Update an existing policy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>policy_id</code> <code>int</code> <p>The ID of the policy to update</p> required <code>policy_update</code> <code>ControlPolicy</code> <p>The updated policy data</p> required <p>Returns:</p> Type Description <code>ControlPolicy</code> <p>The updated policy</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the policy is not found</p> <code>LuthienDBIntegrityError</code> <p>If a constraint violation occurs</p> <code>LuthienDBTransactionError</code> <p>If the transaction fails</p> <code>LuthienDBOperationError</code> <p>For other database errors</p>"},{"location":"#luthien_control.db.database_async","title":"<code>database_async</code>","text":""},{"location":"#luthien_control.db.database_async.close_db_engine","title":"<code>close_db_engine()</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/database_async.py</code> <pre><code>async def close_db_engine() -&gt; None:\n    \"\"\"Closes the database engine.\"\"\"\n    global _db_engine\n    if _db_engine:\n        try:\n            await _db_engine.dispose()\n            logger.info(\"Database engine closed successfully.\")\n        except Exception as e:\n            logger.error(f\"Error closing database engine: {e}\", exc_info=True)\n        finally:\n            _db_engine = None\n    else:\n        logger.info(\"Database engine was already None or not initialized during shutdown.\")\n</code></pre> <p>Closes the database engine.</p>"},{"location":"#luthien_control.db.database_async.create_db_engine","title":"<code>create_db_engine()</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/database_async.py</code> <pre><code>async def create_db_engine() -&gt; AsyncEngine:\n    \"\"\"Creates the asyncpg engine for the application DB.\n    Returns:\n        The asyncpg engine for the application DB.\n\n    Raises:\n        LuthienDBConfigurationError: If the database configuration is invalid.\n        LuthienDBConnectionError: If the database connection fails.\n    \"\"\"\n    global _db_engine, _db_session_factory\n    if _db_engine:\n        logger.debug(\"Database engine already initialized.\")\n        return _db_engine\n\n    logger.info(\"Attempting to create database engine...\")\n\n    db_url = _get_db_url()\n\n    try:\n        # Get and validate pool sizes\n        pool_min_size = settings.get_main_db_pool_min_size()\n        pool_max_size = settings.get_main_db_pool_max_size()\n\n        _db_engine = create_async_engine(\n            db_url,\n            echo=False,  # Set to True for debugging SQL queries\n            pool_pre_ping=True,\n            pool_size=pool_min_size,\n            max_overflow=pool_max_size - pool_min_size,\n        )\n\n        _db_session_factory = async_sessionmaker(\n            _db_engine,\n            expire_on_commit=False,\n            class_=AsyncSession,\n        )\n\n        logger.info(\"Database engine created successfully.\")\n        return _db_engine\n    except Exception as e:\n        masked_url = _mask_password(db_url)\n        raise LuthienDBConnectionError(f\"Failed to create database engine using URL ({masked_url}): {e}\")\n</code></pre> <p>Creates the asyncpg engine for the application DB. Returns:     The asyncpg engine for the application DB.</p> <p>Raises:</p> Type Description <code>LuthienDBConfigurationError</code> <p>If the database configuration is invalid.</p> <code>LuthienDBConnectionError</code> <p>If the database connection fails.</p>"},{"location":"#luthien_control.db.database_async.get_db_session","title":"<code>get_db_session()</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/database_async.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def get_db_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"Get a SQLAlchemy async session for the database as a context manager.\"\"\"\n    if _db_session_factory is None:\n        raise RuntimeError(\"Database session factory has not been initialized\")\n\n    async with _db_session_factory() as session:\n        try:\n            yield session\n        except Exception:\n            await session.rollback()\n            raise\n</code></pre> <p>Get a SQLAlchemy async session for the database as a context manager.</p>"},{"location":"#luthien_control.db.exceptions","title":"<code>exceptions</code>","text":"<p>Database-specific exceptions for the Luthien Control project.</p>"},{"location":"#luthien_control.db.exceptions.LuthienDBIntegrityError","title":"<code>LuthienDBIntegrityError</code>","text":"<p>           Bases: <code>LuthienDBOperationError</code></p> Source code in <code>luthien_control/db/exceptions.py</code> <pre><code>class LuthienDBIntegrityError(LuthienDBOperationError):\n    \"\"\"Exception raised when a database integrity constraint is violated.\n\n    This exception wraps SQLAlchemy's IntegrityError and provides a more\n    specific error type for the Luthien Control project.\n    \"\"\"\n\n    def __init__(self, message: str, original_error: Optional[IntegrityError] = None):\n        \"\"\"Initialize the exception.\n\n        Args:\n            message: A descriptive error message\n            original_error: The original IntegrityError that was raised\n        \"\"\"\n        super().__init__(message)\n        self.original_error = original_error\n</code></pre> <p>Exception raised when a database integrity constraint is violated.</p> <p>This exception wraps SQLAlchemy's IntegrityError and provides a more specific error type for the Luthien Control project.</p>"},{"location":"#luthien_control.db.exceptions.LuthienDBIntegrityError.__init__","title":"<code>__init__(message, original_error=None)</code>","text":"Source code in <code>luthien_control/db/exceptions.py</code> <pre><code>def __init__(self, message: str, original_error: Optional[IntegrityError] = None):\n    \"\"\"Initialize the exception.\n\n    Args:\n        message: A descriptive error message\n        original_error: The original IntegrityError that was raised\n    \"\"\"\n    super().__init__(message)\n    self.original_error = original_error\n</code></pre> <p>Initialize the exception.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>A descriptive error message</p> required <code>original_error</code> <code>Optional[IntegrityError]</code> <p>The original IntegrityError that was raised</p> <code>None</code>"},{"location":"#luthien_control.db.exceptions.LuthienDBOperationError","title":"<code>LuthienDBOperationError</code>","text":"<p>           Bases: <code>LuthienDBException</code></p> Source code in <code>luthien_control/db/exceptions.py</code> <pre><code>class LuthienDBOperationError(LuthienDBException):\n    \"\"\"Base exception for database operation errors.\n\n    This exception is raised when a database operation fails for any reason.\n    It serves as a base class for more specific database operation errors.\n    \"\"\"\n\n    pass\n</code></pre> <p>Base exception for database operation errors.</p> <p>This exception is raised when a database operation fails for any reason. It serves as a base class for more specific database operation errors.</p>"},{"location":"#luthien_control.db.exceptions.LuthienDBQueryError","title":"<code>LuthienDBQueryError</code>","text":"<p>           Bases: <code>LuthienDBOperationError</code></p> Source code in <code>luthien_control/db/exceptions.py</code> <pre><code>class LuthienDBQueryError(LuthienDBOperationError):\n    \"\"\"Exception raised when a database query fails.\n\n    This exception is raised when a SELECT query fails to execute properly.\n    \"\"\"\n\n    pass\n</code></pre> <p>Exception raised when a database query fails.</p> <p>This exception is raised when a SELECT query fails to execute properly.</p>"},{"location":"#luthien_control.db.exceptions.LuthienDBTransactionError","title":"<code>LuthienDBTransactionError</code>","text":"<p>           Bases: <code>LuthienDBOperationError</code></p> Source code in <code>luthien_control/db/exceptions.py</code> <pre><code>class LuthienDBTransactionError(LuthienDBOperationError):\n    \"\"\"Exception raised when a database transaction fails.\n\n    This exception is raised when a transaction (commit, rollback) fails.\n    \"\"\"\n\n    pass\n</code></pre> <p>Exception raised when a database transaction fails.</p> <p>This exception is raised when a transaction (commit, rollback) fails.</p>"},{"location":"#luthien_control.db.luthien_log_crud","title":"<code>luthien_log_crud</code>","text":""},{"location":"#luthien_control.db.luthien_log_crud.count_logs","title":"<code>count_logs(session, transaction_id=None, datatype=None, start_datetime=None, end_datetime=None)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/luthien_log_crud.py</code> <pre><code>async def count_logs(\n    session: AsyncSession,\n    transaction_id: Optional[str] = None,\n    datatype: Optional[str] = None,\n    start_datetime: Optional[datetime] = None,\n    end_datetime: Optional[datetime] = None,\n) -&gt; int:\n    \"\"\"Count logs with optional filtering.\n\n    Args:\n        session: The database session\n        transaction_id: Optional filter by transaction ID\n        datatype: Optional filter by datatype\n        start_datetime: Optional filter for logs after this datetime\n        end_datetime: Optional filter for logs before this datetime\n\n    Returns:\n        The count of matching logs\n\n    Raises:\n        LuthienDBQueryError: If the query execution fails\n        LuthienDBOperationError: For unexpected errors\n    \"\"\"\n    try:\n        stmt = select(col(LuthienLog.id))\n\n        # Apply filters\n        if transaction_id:\n            stmt = stmt.where(col(LuthienLog.transaction_id) == transaction_id)\n        if datatype:\n            stmt = stmt.where(col(LuthienLog.datatype) == datatype)\n        if start_datetime:\n            stmt = stmt.where(col(LuthienLog.datetime) &gt;= start_datetime)\n        if end_datetime:\n            stmt = stmt.where(col(LuthienLog.datetime) &lt;= end_datetime)\n\n        result = await session.execute(stmt)\n        return len(list(result.scalars().all()))\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error counting logs: {sqla_err}\")\n        raise LuthienDBQueryError(f\"Database query failed while counting logs: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error counting logs: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during log counting: {e}\") from e\n</code></pre> <p>Count logs with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>transaction_id</code> <code>Optional[str]</code> <p>Optional filter by transaction ID</p> <code>None</code> <code>datatype</code> <code>Optional[str]</code> <p>Optional filter by datatype</p> <code>None</code> <code>start_datetime</code> <code>Optional[datetime]</code> <p>Optional filter for logs after this datetime</p> <code>None</code> <code>end_datetime</code> <code>Optional[datetime]</code> <p>Optional filter for logs before this datetime</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The count of matching logs</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors</p>"},{"location":"#luthien_control.db.luthien_log_crud.get_log_by_id","title":"<code>get_log_by_id(session, log_id)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/luthien_log_crud.py</code> <pre><code>async def get_log_by_id(session: AsyncSession, log_id: int) -&gt; LuthienLog:\n    \"\"\"Get a specific log by its ID.\n\n    Args:\n        session: The database session\n        log_id: The ID of the log to retrieve\n\n    Returns:\n        The log entry\n\n    Raises:\n        LuthienDBQueryError: If the log is not found or if the query execution fails\n        LuthienDBOperationError: For unexpected errors during lookup\n    \"\"\"\n    try:\n        stmt = select(LuthienLog).where(col(LuthienLog.id) == log_id)\n        result = await session.execute(stmt)\n        log_entry = result.scalar_one_or_none()\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error fetching log by ID: {sqla_err}\", exc_info=True)\n        raise LuthienDBQueryError(f\"Database query failed while fetching log: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error fetching log by ID: {e}\", exc_info=True)\n        raise LuthienDBOperationError(f\"Unexpected error during log lookup: {e}\") from e\n\n    if not log_entry:\n        raise LuthienDBQueryError(f\"Log with ID {log_id} not found\")\n\n    return log_entry\n</code></pre> <p>Get a specific log by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>log_id</code> <code>int</code> <p>The ID of the log to retrieve</p> required <p>Returns:</p> Type Description <code>LuthienLog</code> <p>The log entry</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the log is not found or if the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors during lookup</p>"},{"location":"#luthien_control.db.luthien_log_crud.get_unique_datatypes","title":"<code>get_unique_datatypes(session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/luthien_log_crud.py</code> <pre><code>async def get_unique_datatypes(session: AsyncSession) -&gt; List[str]:\n    \"\"\"Get a list of unique datatypes from the logs.\n\n    Args:\n        session: The database session\n\n    Returns:\n        A list of unique datatype values\n\n    Raises:\n        LuthienDBQueryError: If the query execution fails\n        LuthienDBOperationError: For unexpected errors\n    \"\"\"\n    try:\n        stmt = select(col(LuthienLog.datatype)).distinct().order_by(col(LuthienLog.datatype))\n        result = await session.execute(stmt)\n        return list(result.scalars().all())\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error fetching unique datatypes: {sqla_err}\")\n        raise LuthienDBQueryError(f\"Database query failed while fetching datatypes: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error fetching unique datatypes: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during datatype lookup: {e}\") from e\n</code></pre> <p>Get a list of unique datatypes from the logs.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of unique datatype values</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors</p>"},{"location":"#luthien_control.db.luthien_log_crud.get_unique_transaction_ids","title":"<code>get_unique_transaction_ids(session, limit=100)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/luthien_log_crud.py</code> <pre><code>async def get_unique_transaction_ids(session: AsyncSession, limit: int = 100) -&gt; List[str]:\n    \"\"\"Get a list of unique transaction IDs from recent logs.\n\n    Args:\n        session: The database session\n        limit: Maximum number of transaction IDs to return (default: 100)\n\n    Returns:\n        A list of unique transaction ID values\n\n    Raises:\n        LuthienDBQueryError: If the query execution fails\n        LuthienDBOperationError: For unexpected errors\n    \"\"\"\n    try:\n        # Get distinct transaction_ids ordered by the most recent datetime for each transaction\n        stmt = (\n            select(col(LuthienLog.transaction_id))\n            .group_by(col(LuthienLog.transaction_id))\n            .order_by(desc(col(LuthienLog.transaction_id)))\n            .limit(limit)\n        )\n        result = await session.execute(stmt)\n        return list(result.scalars().all())\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error fetching unique transaction IDs: {sqla_err}\")\n        raise LuthienDBQueryError(f\"Database query failed while fetching transaction IDs: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error fetching unique transaction IDs: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during transaction ID lookup: {e}\") from e\n</code></pre> <p>Get a list of unique transaction IDs from recent logs.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>limit</code> <code>int</code> <p>Maximum number of transaction IDs to return (default: 100)</p> <code>100</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of unique transaction ID values</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors</p>"},{"location":"#luthien_control.db.luthien_log_crud.list_logs","title":"<code>list_logs(session, transaction_id=None, datatype=None, limit=100, offset=0, start_datetime=None, end_datetime=None)</code>  <code>async</code>","text":"Source code in <code>luthien_control/db/luthien_log_crud.py</code> <pre><code>async def list_logs(\n    session: AsyncSession,\n    transaction_id: Optional[str] = None,\n    datatype: Optional[str] = None,\n    limit: int = 100,\n    offset: int = 0,\n    start_datetime: Optional[datetime] = None,\n    end_datetime: Optional[datetime] = None,\n) -&gt; List[LuthienLog]:\n    \"\"\"Get a list of logs with optional filtering.\n\n    Args:\n        session: The database session\n        transaction_id: Optional filter by transaction ID\n        datatype: Optional filter by datatype\n        limit: Maximum number of logs to return (default: 100)\n        offset: Number of logs to skip (default: 0)\n        start_datetime: Optional filter for logs after this datetime\n        end_datetime: Optional filter for logs before this datetime\n\n    Returns:\n        A list of LuthienLog entries\n\n    Raises:\n        LuthienDBQueryError: If the query execution fails\n        LuthienDBOperationError: For unexpected errors\n    \"\"\"\n    try:\n        stmt = select(LuthienLog).order_by(desc(col(LuthienLog.datetime)))\n\n        # Apply filters\n        if transaction_id:\n            stmt = stmt.where(col(LuthienLog.transaction_id) == transaction_id)\n        if datatype:\n            stmt = stmt.where(col(LuthienLog.datatype) == datatype)\n        if start_datetime:\n            stmt = stmt.where(col(LuthienLog.datetime) &gt;= start_datetime)\n        if end_datetime:\n            stmt = stmt.where(col(LuthienLog.datetime) &lt;= end_datetime)\n\n        # Apply pagination\n        stmt = stmt.limit(limit).offset(offset)\n\n        result = await session.execute(stmt)\n        return list(result.scalars().all())\n    except SQLAlchemyError as sqla_err:\n        logger.error(f\"SQLAlchemy error listing logs: {sqla_err}\")\n        raise LuthienDBQueryError(f\"Database query failed while listing logs: {sqla_err}\") from sqla_err\n    except Exception as e:\n        logger.error(f\"Unexpected error listing logs: {e}\")\n        raise LuthienDBOperationError(f\"Unexpected error during log listing: {e}\") from e\n</code></pre> <p>Get a list of logs with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The database session</p> required <code>transaction_id</code> <code>Optional[str]</code> <p>Optional filter by transaction ID</p> <code>None</code> <code>datatype</code> <code>Optional[str]</code> <p>Optional filter by datatype</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of logs to return (default: 100)</p> <code>100</code> <code>offset</code> <code>int</code> <p>Number of logs to skip (default: 0)</p> <code>0</code> <code>start_datetime</code> <code>Optional[datetime]</code> <p>Optional filter for logs after this datetime</p> <code>None</code> <code>end_datetime</code> <code>Optional[datetime]</code> <p>Optional filter for logs before this datetime</p> <code>None</code> <p>Returns:</p> Type Description <code>List[LuthienLog]</code> <p>A list of LuthienLog entries</p> <p>Raises:</p> Type Description <code>LuthienDBQueryError</code> <p>If the query execution fails</p> <code>LuthienDBOperationError</code> <p>For unexpected errors</p>"},{"location":"#luthien_control.db.naive_datetime","title":"<code>naive_datetime</code>","text":""},{"location":"#luthien_control.db.naive_datetime.NaiveDatetime","title":"<code>NaiveDatetime</code>","text":"<p>           Bases: <code>datetime</code></p> Source code in <code>luthien_control/db/naive_datetime.py</code> <pre><code>class NaiveDatetime(datetime):\n    \"\"\"A datetime that automatically strips timezone info.\"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        # Handle datetime object as first argument\n        if args and isinstance(args[0], datetime):\n            dt = args[0]\n            # Convert to naive UTC if timezone-aware, otherwise keep as-is\n            if dt.tzinfo is not None:\n                dt = dt.astimezone(timezone.utc).replace(tzinfo=None)\n            return super().__new__(cls, dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.microsecond)\n        else:\n            # Normal datetime constructor\n            return super().__new__(cls, *args, **kwargs)\n\n    @classmethod\n    def now(cls, tz: Optional[tzinfo] = None) -&gt; \"NaiveDatetime\":\n        \"\"\"Create a NaiveDatetime representing the current UTC time (naive).\"\"\"\n        # Always return naive UTC time regardless of tz parameter for consistency\n        return cls(datetime.now(timezone.utc))\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: Any) -&gt; core_schema.CoreSchema:\n        \"\"\"Pydantic schema for NaiveDatetime.\"\"\"\n        return core_schema.with_info_before_validator_function(\n            cls._convert_to_naive,\n            core_schema.datetime_schema(),\n        )\n\n    @classmethod\n    def _convert_to_naive(cls, value: Any, info: Any) -&gt; Any:\n        \"\"\"Convert datetime to naive before Pydantic processes it.\"\"\"\n        if isinstance(value, datetime):\n            return cls(value)  # This will trigger our __new__ method\n        return value  # Let Pydantic handle other types\n</code></pre> <p>A datetime that automatically strips timezone info.</p>"},{"location":"#luthien_control.db.naive_datetime.NaiveDatetime.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type, handler)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/db/naive_datetime.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source_type: Any, handler: Any) -&gt; core_schema.CoreSchema:\n    \"\"\"Pydantic schema for NaiveDatetime.\"\"\"\n    return core_schema.with_info_before_validator_function(\n        cls._convert_to_naive,\n        core_schema.datetime_schema(),\n    )\n</code></pre> <p>Pydantic schema for NaiveDatetime.</p>"},{"location":"#luthien_control.db.naive_datetime.NaiveDatetime.now","title":"<code>now(tz=None)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/db/naive_datetime.py</code> <pre><code>@classmethod\ndef now(cls, tz: Optional[tzinfo] = None) -&gt; \"NaiveDatetime\":\n    \"\"\"Create a NaiveDatetime representing the current UTC time (naive).\"\"\"\n    # Always return naive UTC time regardless of tz parameter for consistency\n    return cls(datetime.now(timezone.utc))\n</code></pre> <p>Create a NaiveDatetime representing the current UTC time (naive).</p>"},{"location":"#luthien_control.db.sqlmodel_models","title":"<code>sqlmodel_models</code>","text":""},{"location":"#luthien_control.db.sqlmodel_models.AdminSession","title":"<code>AdminSession</code>","text":"<p>           Bases: <code>SQLModel</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class AdminSession(SQLModel, table=True):\n    \"\"\"Admin session model for managing active sessions.\"\"\"\n\n    __tablename__ = \"admin_sessions\"  # type: ignore\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    session_token: str = Field(sa_column=Column(String(255), unique=True, nullable=False))\n    admin_user_id: int = Field(\n        foreign_key=\"admin_users.id\",\n        description=\"Reference to admin user\",\n    )\n    expires_at: datetime = Field(sa_column=Column(DateTime(timezone=True), nullable=False))\n    created_at: datetime = Field(\n        default_factory=datetime.utcnow,\n        sa_column=Column(DateTime(timezone=True), server_default=func.now()),\n    )\n\n    __table_args__ = (\n        Index(\"idx_session_token\", \"session_token\"),\n        Index(\"idx_session_expires\", \"expires_at\"),\n    )\n</code></pre> <p>Admin session model for managing active sessions.</p>"},{"location":"#luthien_control.db.sqlmodel_models.AdminUser","title":"<code>AdminUser</code>","text":"<p>           Bases: <code>SQLModel</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class AdminUser(SQLModel, table=True):\n    \"\"\"Admin user model for authentication and authorization.\"\"\"\n\n    __tablename__ = \"admin_users\"  # type: ignore\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    username: str = Field(sa_column=Column(String(50), unique=True, nullable=False))\n    password_hash: str = Field(sa_column=Column(String(255), nullable=False))\n    is_active: bool = Field(default=True)\n    is_superuser: bool = Field(default=False)\n    last_login: Optional[datetime] = Field(default=None, sa_column=Column(DateTime(timezone=True)))\n    created_at: datetime = Field(\n        default_factory=datetime.utcnow,\n        sa_column=Column(DateTime(timezone=True), server_default=func.now()),\n    )\n    updated_at: datetime = Field(\n        default_factory=datetime.utcnow,\n        sa_column=Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now()),\n    )\n\n    __table_args__ = (\n        Index(\"idx_admin_username\", \"username\"),\n        Index(\"idx_admin_active\", \"is_active\"),\n    )\n</code></pre> <p>Admin user model for authentication and authorization.</p>"},{"location":"#luthien_control.db.sqlmodel_models.ControlPolicy","title":"<code>ControlPolicy</code>","text":"<p>           Bases: <code>SQLModel</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class ControlPolicy(SQLModel, table=True):\n    __tablename__ = \"policies\"  # type: ignore (again, shut up pyright)\n    \"\"\"Database model for storing control policy configurations.\"\"\"\n\n    # Primary key\n    id: Optional[int] = Field(default=None, primary_key=True)\n\n    # --- Core Fields ---\n    name: str = Field(index=True, unique=True)  # Unique name used for lookup\n    type: str = Field()  # Type of policy, used for instantiation\n    config: dict[str, Any] = Field(default={}, sa_column=Column(JSON))\n    is_active: bool = Field(default=True, index=True)\n    description: Optional[str] = Field(default=None)\n\n    # --- Timestamps ---\n    created_at: dt.datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc).replace(tzinfo=None), nullable=False\n    )\n    updated_at: dt.datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc).replace(tzinfo=None), nullable=False\n    )\n\n    def __init__(self, **data: Any):\n        # Ensure timestamps are set on creation if not provided\n        if \"created_at\" not in data:\n            data[\"created_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n        if \"updated_at\" not in data:\n            data[\"updated_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n        super().__init__(**data)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_timestamps(cls, values):\n        \"\"\"Ensure updated_at is always set/updated.\"\"\"\n        if isinstance(values, dict):\n            values[\"updated_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n        return values\n</code></pre>"},{"location":"#luthien_control.db.sqlmodel_models.ControlPolicy.__tablename__","title":"<code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database model for storing control policy configurations.</p>"},{"location":"#luthien_control.db.sqlmodel_models.ControlPolicy.__tablename__","title":"<code>__tablename__ = 'policies'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Database model for storing control policy configurations.</p>"},{"location":"#luthien_control.db.sqlmodel_models.ControlPolicy.validate_timestamps","title":"<code>validate_timestamps(values)</code>  <code>classmethod</code>","text":"Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef validate_timestamps(cls, values):\n    \"\"\"Ensure updated_at is always set/updated.\"\"\"\n    if isinstance(values, dict):\n        values[\"updated_at\"] = datetime.now(timezone.utc).replace(tzinfo=None)\n    return values\n</code></pre> <p>Ensure updated_at is always set/updated.</p>"},{"location":"#luthien_control.db.sqlmodel_models.JsonBOrJson","title":"<code>JsonBOrJson</code>","text":"<p>           Bases: <code>TypeDecorator</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class JsonBOrJson(types.TypeDecorator):\n    \"\"\"\n    Represents a JSON type that uses JSONB for PostgreSQL and JSON for other dialects (like SQLite).\n\n    This is mostly a hack for unit testing, as SQLite does not support JSONB.\n    \"\"\"\n\n    impl = JSON  # Default implementation if dialect-specific is not found\n    cache_ok = True  # Safe to cache this type decorator\n\n    def load_dialect_impl(self, dialect):\n        if dialect.name == \"postgresql\":\n            return dialect.type_descriptor(JSONB())\n        else:\n            return dialect.type_descriptor(JSON())\n</code></pre> <p>Represents a JSON type that uses JSONB for PostgreSQL and JSON for other dialects (like SQLite).</p> <p>This is mostly a hack for unit testing, as SQLite does not support JSONB.</p>"},{"location":"#luthien_control.db.sqlmodel_models.LuthienLog","title":"<code>LuthienLog</code>","text":"<p>           Bases: <code>SQLModel</code></p> Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>class LuthienLog(SQLModel, table=True):\n    \"\"\"\n    Represents a log entry in the Luthien logging system using SQLModel.\n\n    Attributes:\n        id: Unique identifier for the log entry (primary key).\n        transaction_id: Identifier to group related log entries.\n        datetime: Timestamp indicating when the log entry was generated (timezone-aware).\n        data: JSON blob containing the primary logged data.\n        datatype: String identifier for the nature and schema of 'data'.\n        notes: JSON blob for additional contextual information.\n    \"\"\"\n\n    __tablename__ = \"luthien_log\"  # type: ignore (shut up pyright)\n\n    id: Optional[int] = Field(default=None, primary_key=True, index=True)\n    transaction_id: str = Field(index=True, nullable=False)\n    datetime: NaiveDatetime = Field(\n        default_factory=NaiveDatetime.now,\n        nullable=False,\n        index=True,\n    )\n    data: Optional[dict[str, Any]] = Field(default=None, sa_column=Column(JsonBOrJson))\n    datatype: str = Field(index=True, nullable=False)\n    notes: Optional[dict[str, Any]] = Field(default=None, sa_column=Column(JsonBOrJson))\n\n    def __init__(self, **data: Any) -&gt; None:\n        \"\"\"Override init to ensure datetime is converted to NaiveDatetime.\"\"\"\n        if \"datetime\" in data:\n            dt_value = data[\"datetime\"]\n            if isinstance(dt_value, datetime) and not isinstance(dt_value, NaiveDatetime):\n                data[\"datetime\"] = NaiveDatetime(dt_value)\n        super().__init__(**data)\n\n    # __table_args__ = (\n    #     Index(\"ix_sqlmodel_luthien_log_transaction_id\", \"transaction_id\"),\n    #     Index(\"ix_sqlmodel_luthien_log_datetime\", \"datetime\"),\n    #     Index(\"ix_sqlmodel_luthien_log_datatype\", \"datatype\"),\n    #     {\"extend_existing\": True},\n    # )\n\n    # __repr__ is not automatically generated by SQLModel like Pydantic models,\n    # but you can add one if desired.\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;LuthienLog(id={self.id}, \"\n            f\"transaction_id='{self.transaction_id}', \"\n            f\"datetime='{self.datetime}', \"\n            f\"datatype='{self.datatype}')&gt;\"\n        )\n</code></pre> <p>Represents a log entry in the Luthien logging system using SQLModel.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[int]</code> <p>Unique identifier for the log entry (primary key).</p> <code>transaction_id</code> <code>str</code> <p>Identifier to group related log entries.</p> <code>datetime</code> <code>NaiveDatetime</code> <p>Timestamp indicating when the log entry was generated (timezone-aware).</p> <code>data</code> <code>Optional[dict[str, Any]]</code> <p>JSON blob containing the primary logged data.</p> <code>datatype</code> <code>str</code> <p>String identifier for the nature and schema of 'data'.</p> <code>notes</code> <code>Optional[dict[str, Any]]</code> <p>JSON blob for additional contextual information.</p>"},{"location":"#luthien_control.db.sqlmodel_models.LuthienLog.__init__","title":"<code>__init__(**data)</code>","text":"Source code in <code>luthien_control/db/sqlmodel_models.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    \"\"\"Override init to ensure datetime is converted to NaiveDatetime.\"\"\"\n    if \"datetime\" in data:\n        dt_value = data[\"datetime\"]\n        if isinstance(dt_value, datetime) and not isinstance(dt_value, NaiveDatetime):\n            data[\"datetime\"] = NaiveDatetime(dt_value)\n    super().__init__(**data)\n</code></pre> <p>Override init to ensure datetime is converted to NaiveDatetime.</p>"},{"location":"#luthien_control.exceptions","title":"<code>exceptions</code>","text":""},{"location":"#luthien_control.exceptions.LuthienDBConfigurationError","title":"<code>LuthienDBConfigurationError</code>","text":"<p>           Bases: <code>LuthienDBException</code></p> Source code in <code>luthien_control/exceptions.py</code> <pre><code>class LuthienDBConfigurationError(LuthienDBException):\n    \"\"\"Exception raised when a database configuration is invalid or missing required variables.\"\"\"\n\n    pass\n</code></pre> <p>Exception raised when a database configuration is invalid or missing required variables.</p>"},{"location":"#luthien_control.exceptions.LuthienDBConnectionError","title":"<code>LuthienDBConnectionError</code>","text":"<p>           Bases: <code>LuthienDBException</code></p> Source code in <code>luthien_control/exceptions.py</code> <pre><code>class LuthienDBConnectionError(LuthienDBException):\n    \"\"\"Exception raised when a connection to the database fails.\"\"\"\n\n    pass\n</code></pre> <p>Exception raised when a connection to the database fails.</p>"},{"location":"#luthien_control.exceptions.LuthienDBException","title":"<code>LuthienDBException</code>","text":"<p>           Bases: <code>LuthienException</code></p> Source code in <code>luthien_control/exceptions.py</code> <pre><code>class LuthienDBException(LuthienException):\n    \"\"\"Base exception for all Luthien DB related errors.\"\"\"\n\n    pass\n</code></pre> <p>Base exception for all Luthien DB related errors.</p>"},{"location":"#luthien_control.exceptions.LuthienException","title":"<code>LuthienException</code>","text":"<p>           Bases: <code>Exception</code></p> Source code in <code>luthien_control/exceptions.py</code> <pre><code>class LuthienException(Exception):\n    \"\"\"Base exception for all Luthien errors.\"\"\"\n\n    pass\n</code></pre> <p>Base exception for all Luthien errors.</p>"},{"location":"#luthien_control.logs","title":"<code>logs</code>","text":""},{"location":"#luthien_control.logs.router","title":"<code>router</code>","text":""},{"location":"#luthien_control.logs.router.get_datatypes","title":"<code>get_datatypes(session=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/logs/router.py</code> <pre><code>@router.get(\"/admin/logs-api/metadata/datatypes\")\nasync def get_datatypes(\n    session: AsyncSession = Depends(get_db_session),\n) -&gt; List[str]:\n    \"\"\"Get list of unique datatypes from logs.\"\"\"\n    try:\n        return await get_unique_datatypes(session=session)\n    except (LuthienDBQueryError, LuthienDBOperationError) as db_err:\n        logger.error(f\"Database error getting datatypes: {db_err}\")\n        raise HTTPException(status_code=500, detail=\"Failed to retrieve datatypes from database\")\n    except Exception as e:\n        logger.error(f\"Unexpected error getting datatypes: {e}\")\n        raise HTTPException(status_code=500, detail=\"An unexpected error occurred\")\n</code></pre> <p>Get list of unique datatypes from logs.</p>"},{"location":"#luthien_control.logs.router.get_log","title":"<code>get_log(log_id, session=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/logs/router.py</code> <pre><code>@router.get(\"/admin/logs-api/logs/{log_id}\")\nasync def get_log(\n    log_id: int,\n    session: AsyncSession = Depends(get_db_session),\n) -&gt; Dict[str, Any]:\n    \"\"\"Get a specific log by ID.\"\"\"\n    try:\n        log = await get_log_by_id(session=session, log_id=log_id)\n\n        return {\n            \"id\": log.id,\n            \"transaction_id\": log.transaction_id,\n            \"datetime\": log.datetime.isoformat() if log.datetime else None,\n            \"datatype\": log.datatype,\n            \"data\": log.data,\n            \"notes\": log.notes,\n        }\n\n    except LuthienDBQueryError:\n        raise HTTPException(status_code=404, detail=f\"Log with ID {log_id} not found\")\n    except LuthienDBOperationError as db_err:\n        logger.error(f\"Database error getting log {log_id}: {db_err}\")\n        raise HTTPException(status_code=500, detail=\"Failed to retrieve log from database\")\n    except Exception as e:\n        logger.error(f\"Unexpected error getting log {log_id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"An unexpected error occurred\")\n</code></pre> <p>Get a specific log by ID.</p>"},{"location":"#luthien_control.logs.router.get_logs","title":"<code>get_logs(session=Depends(get_db_session), transaction_id=Query(None, description='Filter by transaction ID'), datatype=Query(None, description='Filter by datatype'), limit=Query(100, ge=1, le=1000, description='Maximum number of logs to return'), offset=Query(0, ge=0, description='Number of logs to skip'), start_datetime=Query(None, description='Start datetime (ISO format)'), end_datetime=Query(None, description='End datetime (ISO format)'))</code>  <code>async</code>","text":"Source code in <code>luthien_control/logs/router.py</code> <pre><code>@router.get(\"/admin/logs-api/logs\")\nasync def get_logs(\n    session: AsyncSession = Depends(get_db_session),\n    transaction_id: Optional[str] = Query(None, description=\"Filter by transaction ID\"),\n    datatype: Optional[str] = Query(None, description=\"Filter by datatype\"),\n    limit: int = Query(100, ge=1, le=1000, description=\"Maximum number of logs to return\"),\n    offset: int = Query(0, ge=0, description=\"Number of logs to skip\"),\n    start_datetime: Optional[str] = Query(None, description=\"Start datetime (ISO format)\"),\n    end_datetime: Optional[str] = Query(None, description=\"End datetime (ISO format)\"),\n) -&gt; Dict[str, Any]:\n    \"\"\"Get logs with optional filtering and pagination.\n\n    Returns:\n        Dictionary containing logs, pagination info, and metadata\n    \"\"\"\n    try:\n        # Parse datetime strings if provided\n        start_dt = None\n        end_dt = None\n        if start_datetime:\n            try:\n                start_dt = datetime.fromisoformat(start_datetime.replace(\"Z\", \"+00:00\"))\n            except ValueError as e:\n                raise HTTPException(status_code=400, detail=f\"Invalid start_datetime format: {e}\")\n\n        if end_datetime:\n            try:\n                end_dt = datetime.fromisoformat(end_datetime.replace(\"Z\", \"+00:00\"))\n            except ValueError as e:\n                raise HTTPException(status_code=400, detail=f\"Invalid end_datetime format: {e}\")\n\n        # Get logs and total count\n        logs = await list_logs(\n            session=session,\n            transaction_id=transaction_id,\n            datatype=datatype,\n            limit=limit,\n            offset=offset,\n            start_datetime=start_dt,\n            end_datetime=end_dt,\n        )\n\n        total_count = await count_logs(\n            session=session,\n            transaction_id=transaction_id,\n            datatype=datatype,\n            start_datetime=start_dt,\n            end_datetime=end_dt,\n        )\n\n        # Convert logs to dict format for JSON response\n        logs_data = []\n        for log in logs:\n            log_dict = {\n                \"id\": log.id,\n                \"transaction_id\": log.transaction_id,\n                \"datetime\": log.datetime.isoformat() if log.datetime else None,\n                \"datatype\": log.datatype,\n                \"data\": log.data,\n                \"notes\": log.notes,\n            }\n            logs_data.append(log_dict)\n\n        return {\n            \"logs\": logs_data,\n            \"pagination\": {\n                \"limit\": limit,\n                \"offset\": offset,\n                \"total\": total_count,\n                \"has_next\": offset + limit &lt; total_count,\n                \"has_prev\": offset &gt; 0,\n            },\n            \"filters\": {\n                \"transaction_id\": transaction_id,\n                \"datatype\": datatype,\n                \"start_datetime\": start_datetime,\n                \"end_datetime\": end_datetime,\n            },\n        }\n\n    except HTTPException:\n        # Re-raise HTTPExceptions (like 400 Bad Request) without modification\n        raise\n    except (LuthienDBQueryError, LuthienDBOperationError) as db_err:\n        logger.error(f\"Database error getting logs: {db_err}\")\n        raise HTTPException(status_code=500, detail=\"Failed to retrieve logs from database\")\n    except Exception as e:\n        logger.error(f\"Unexpected error getting logs: {e}\")\n        raise HTTPException(status_code=500, detail=\"An unexpected error occurred\")\n</code></pre> <p>Get logs with optional filtering and pagination.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing logs, pagination info, and metadata</p>"},{"location":"#luthien_control.logs.router.get_transaction_ids","title":"<code>get_transaction_ids(limit=Query(100, ge=1, le=500, description='Maximum number of transaction IDs to return'), session=Depends(get_db_session))</code>  <code>async</code>","text":"Source code in <code>luthien_control/logs/router.py</code> <pre><code>@router.get(\"/admin/logs-api/metadata/transaction-ids\")\nasync def get_transaction_ids(\n    limit: int = Query(100, ge=1, le=500, description=\"Maximum number of transaction IDs to return\"),\n    session: AsyncSession = Depends(get_db_session),\n) -&gt; List[str]:\n    \"\"\"Get list of unique transaction IDs from recent logs.\"\"\"\n    try:\n        return await get_unique_transaction_ids(session=session, limit=limit)\n    except (LuthienDBQueryError, LuthienDBOperationError) as db_err:\n        logger.error(f\"Database error getting transaction IDs: {db_err}\")\n        raise HTTPException(status_code=500, detail=\"Failed to retrieve transaction IDs from database\")\n    except Exception as e:\n        logger.error(f\"Unexpected error getting transaction IDs: {e}\")\n        raise HTTPException(status_code=500, detail=\"An unexpected error occurred\")\n</code></pre> <p>Get list of unique transaction IDs from recent logs.</p>"},{"location":"#luthien_control.logs.router.logs_ui","title":"<code>logs_ui(request)</code>  <code>async</code>","text":"Source code in <code>luthien_control/logs/router.py</code> <pre><code>@router.get(\"/admin/logs\", response_class=HTMLResponse)\nasync def logs_ui(request: Request):\n    \"\"\"Serve the logs exploration UI.\"\"\"\n    return templates.TemplateResponse(request, \"logs.html\", {})\n</code></pre> <p>Serve the logs exploration UI.</p>"},{"location":"#luthien_control.main","title":"<code>main</code>","text":""},{"location":"#luthien_control.main.health_check","title":"<code>health_check()</code>  <code>async</code>","text":"Source code in <code>luthien_control/main.py</code> <pre><code>@app.get(\"/health\", tags=[\"General\"], status_code=200)\nasync def health_check():\n    \"\"\"Perform a basic health check.\n\n    This endpoint can be used to verify that the application is running\n    and responsive.\n\n    Returns:\n        A dictionary indicating the application status.\n    \"\"\"\n    return {\"status\": \"ok\"}\n</code></pre> <p>Perform a basic health check.</p> <p>This endpoint can be used to verify that the application is running and responsive.</p> <p>Returns:</p> Type Description <p>A dictionary indicating the application status.</p>"},{"location":"#luthien_control.main.lifespan","title":"<code>lifespan(app)</code>  <code>async</code>","text":"Source code in <code>luthien_control/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage the lifespan of the application resources.\n\n    This asynchronous context manager handles the startup and shutdown events\n    of the FastAPI application. It initializes dependencies on startup\n    and ensures they are properly cleaned up on shutdown.\n\n    Args:\n        app: The FastAPI application instance.\n\n    Yields:\n        None: After startup procedures are complete, allowing the application to run.\n\n    Raises:\n        RuntimeError: If critical application dependencies fail to initialize during startup.\n    \"\"\"\n    logger.info(\"Application startup sequence initiated.\")\n\n    # Startup: Load Settings\n    app_settings = Settings()\n    logger.info(\"Settings loaded.\")\n\n    # Startup: Initialize Application Dependencies via helper\n    # This variable will hold the container if successfully created.\n    initialized_dependencies: DependencyContainer | None = None\n    try:\n        initialized_dependencies = await initialize_app_dependencies(app_settings)\n        app.state.dependencies = initialized_dependencies\n        logger.info(\"Core application dependencies initialized and stored in app state.\")\n\n        # Ensure default admin user exists\n        async for db in get_db_session(initialized_dependencies):\n            await admin_auth_service.ensure_default_admin(db)\n            break\n\n    except Exception as init_exc:\n        # _initialize_app_dependencies is responsible for cleaning up resources it\n        # attempted to create (like its own http_client) if it fails internally.\n        # The main concern here is logging and ensuring the app doesn't start.\n        logger.critical(f\"Fatal error during application dependency initialization: {init_exc}\", exc_info=True)\n        # If _initialize_app_dependencies failed before creating db_engine, close_db_engine is safe.\n        # If it failed *after* db_engine creation but before container, db_engine might be open.\n        # The helper itself doesn't call close_db_engine(); it expects lifespan to do so.\n        # Global close_db_engine handles if engine was never set or already closed.\n        await close_db_engine()\n        logger.info(\"DB Engine closed due to dependency initialization failure during startup.\")\n        # Re-raise to prevent application from starting up in a bad state.\n        raise RuntimeError(\n            f\"Application startup failed due to dependency initialization error: {init_exc}\"\n        ) from init_exc\n\n    yield  # Application runs here\n\n    # Shutdown: Clean up resources\n    logger.info(\"Application shutdown sequence initiated.\")\n\n    # Close main DB engine (handles its own check if already closed or never initialized)\n    await close_db_engine()\n    logger.info(\"Main DB Engine closed.\")\n\n    # Shutdown: Close the HTTP client via the container if available\n    await initialized_dependencies.http_client.aclose()\n    logger.info(\"HTTP Client from DependencyContainer closed.\")\n\n    logger.info(\"Application shutdown complete.\")\n</code></pre> <p>Manage the lifespan of the application resources.</p> <p>This asynchronous context manager handles the startup and shutdown events of the FastAPI application. It initializes dependencies on startup and ensures they are properly cleaned up on shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI application instance.</p> required <p>Yields:</p> Name Type Description <code>None</code> <p>After startup procedures are complete, allowing the application to run.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If critical application dependencies fail to initialize during startup.</p>"},{"location":"#luthien_control.main.read_root","title":"<code>read_root()</code>  <code>async</code>","text":"Source code in <code>luthien_control/main.py</code> <pre><code>@app.get(\"/\")\nasync def read_root():\n    \"\"\"Provide a simple root endpoint.\n\n    Returns:\n        A welcome message indicating the proxy is running.\n    \"\"\"\n    return {\"message\": \"Luthien Control Proxy is running.\"}\n</code></pre> <p>Provide a simple root endpoint.</p> <p>Returns:</p> Type Description <p>A welcome message indicating the proxy is running.</p>"},{"location":"#luthien_control.proxy","title":"<code>proxy</code>","text":""},{"location":"#luthien_control.proxy.debugging","title":"<code>debugging</code>","text":"<p>Enhanced debugging utilities for the proxy pipeline.</p>"},{"location":"#luthien_control.proxy.debugging.DebugLoggingMiddleware","title":"<code>DebugLoggingMiddleware</code>","text":"<p>           Bases: <code>BaseHTTPMiddleware</code></p> Source code in <code>luthien_control/proxy/debugging.py</code> <pre><code>class DebugLoggingMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware to add detailed request/response logging for debugging.\"\"\"\n\n    async def dispatch(self, request: Request, call_next) -&gt; Response:\n        start_time = time.time()\n        request_id = request.headers.get(\"x-request-id\", \"no-id\")\n\n        # Log request details\n        request_body = None\n        if request.method in [\"POST\", \"PUT\", \"PATCH\"]:\n            try:\n                request_body = await request.body()\n\n                # Reconstruct request for downstream processing\n                async def receive():\n                    return {\"type\": \"http.request\", \"body\": request_body}\n\n                request._receive = receive\n\n                # Try to parse JSON for logging\n                try:\n                    parsed_body = json.loads(request_body) if request_body else None\n                    logger.debug(\n                        f\"[{request_id}] Incoming {request.method} request\",\n                        extra={\n                            \"path\": request.url.path,\n                            \"headers\": dict(request.headers),\n                            \"body\": parsed_body,\n                            \"query_params\": dict(request.query_params),\n                        },\n                    )\n                except json.JSONDecodeError:\n                    logger.debug(\n                        f\"[{request_id}] Incoming {request.method} request (non-JSON body)\",\n                        extra={\n                            \"path\": request.url.path,\n                            \"headers\": dict(request.headers),\n                            \"body_length\": len(request_body) if request_body else 0,\n                            \"query_params\": dict(request.query_params),\n                        },\n                    )\n            except Exception as e:\n                logger.error(f\"[{request_id}] Error reading request body: {e}\")\n        else:\n            logger.debug(\n                f\"[{request_id}] Incoming {request.method} request\",\n                extra={\n                    \"path\": request.url.path,\n                    \"headers\": dict(request.headers),\n                    \"query_params\": dict(request.query_params),\n                },\n            )\n\n        # Process request\n        response = await call_next(request)\n\n        # Calculate duration\n        duration = time.time() - start_time\n\n        # Log response details\n        logger.info(\n            f\"[{request_id}] Request completed\",\n            extra={\n                \"method\": request.method,\n                \"path\": request.url.path,\n                \"status_code\": response.status_code,\n                \"duration_seconds\": duration,\n            },\n        )\n\n        # Add debug headers\n        response.headers[\"X-Request-ID\"] = request_id\n        response.headers[\"X-Processing-Time\"] = f\"{duration:.3f}s\"\n\n        return response\n</code></pre> <p>Middleware to add detailed request/response logging for debugging.</p>"},{"location":"#luthien_control.proxy.debugging.create_debug_response","title":"<code>create_debug_response(status_code, message, transaction_id, details=None, include_debug_info=True)</code>","text":"Source code in <code>luthien_control/proxy/debugging.py</code> <pre><code>def create_debug_response(\n    status_code: int,\n    message: str,\n    transaction_id: str,\n    details: Optional[Dict[str, Any]] = None,\n    include_debug_info: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a detailed error response for debugging.\"\"\"\n    response = {\n        \"detail\": message,\n        \"transaction_id\": transaction_id,\n    }\n\n    if include_debug_info and details:\n        response[\"debug\"] = str({\"timestamp\": datetime.now(UTC).isoformat(), **details})\n\n    return response\n</code></pre> <p>Create a detailed error response for debugging.</p>"},{"location":"#luthien_control.proxy.debugging.log_policy_execution","title":"<code>log_policy_execution(transaction_id, policy_name, status, duration=None, error=None, details=None)</code>","text":"Source code in <code>luthien_control/proxy/debugging.py</code> <pre><code>def log_policy_execution(\n    transaction_id: str,\n    policy_name: str,\n    status: str,\n    duration: Optional[float] = None,\n    error: Optional[str] = None,\n    details: Optional[Dict[str, Any]] = None,\n) -&gt; None:\n    \"\"\"Log policy execution details.\"\"\"\n    log_data = {\n        \"transaction_id\": transaction_id,\n        \"policy_name\": policy_name,\n        \"status\": status,\n    }\n\n    if duration is not None:\n        log_data[\"duration_seconds\"] = str(duration)\n\n    if error:\n        log_data[\"error\"] = error\n\n    if details:\n        log_data.update(details)\n\n    if status == \"error\":\n        logger.error(f\"[{transaction_id}] Policy {policy_name} failed\", extra=log_data)\n    else:\n        logger.info(f\"[{transaction_id}] Policy {policy_name} {status}\", extra=log_data)\n</code></pre> <p>Log policy execution details.</p>"},{"location":"#luthien_control.proxy.debugging.log_transaction_state","title":"<code>log_transaction_state(transaction_id, stage, details)</code>","text":"Source code in <code>luthien_control/proxy/debugging.py</code> <pre><code>def log_transaction_state(transaction_id: str, stage: str, details: Dict[str, Any]) -&gt; None:\n    \"\"\"Log transaction state at various stages of processing.\"\"\"\n    logger.debug(\n        f\"[{transaction_id}] Transaction state at {stage}\",\n        extra={\"stage\": stage, \"timestamp\": datetime.now(UTC).isoformat(), **details},\n    )\n</code></pre> <p>Log transaction state at various stages of processing.</p>"},{"location":"#luthien_control.proxy.orchestration","title":"<code>orchestration</code>","text":""},{"location":"#luthien_control.proxy.orchestration.run_policy_flow","title":"<code>run_policy_flow(request, main_policy, dependencies, session)</code>  <code>async</code>","text":"Source code in <code>luthien_control/proxy/orchestration.py</code> <pre><code>async def run_policy_flow(\n    request: fastapi.Request,\n    main_policy: ControlPolicy,\n    dependencies: DependencyContainer,\n    session: AsyncSession,\n) -&gt; fastapi.Response:\n    \"\"\"\n    Orchestrates the execution of the main ControlPolicy using injected dependencies.\n    Exceptions raised by policies are expected to be caught by FastAPI exception handlers.\n\n    Args:\n        request: The incoming FastAPI request.\n        main_policy: The main policy instance to execute.\n        dependencies: The application's dependency container.\n        session: The database session for this request.\n\n    Returns:\n        The final FastAPI response.\n    \"\"\"\n    # 1. Initialize Context\n    body = await request.body()\n    url = request.path_params[\"full_path\"]\n    api_key = request.headers.get(\"authorization\", \"\").replace(\"Bearer \", \"\")\n    transaction = _initialize_transaction(body, url, api_key)\n\n    # Log initial transaction state\n    log_transaction_state(\n        str(transaction.transaction_id),\n        \"initialization\",\n        {\n            \"url\": url,\n            \"method\": request.method,\n            \"has_api_key\": bool(api_key),\n            \"body_length\": len(body) if body else 0,\n            \"headers_count\": len(request.headers),\n        },\n    )\n\n    # 2. Apply the main policy\n    policy_start_time = None\n    try:\n        logger.info(\n            \"Applying control policy\",\n            extra={\n                \"transaction_id\": str(transaction.transaction_id),\n                \"policy_name\": main_policy.name,\n                \"url\": url,\n                \"method\": request.method,\n            },\n        )\n        policy_start_time = time.time()\n        transaction = await main_policy.apply(transaction=transaction, container=dependencies, session=session)\n\n        # Log successful policy execution\n        log_policy_execution(\n            str(transaction.transaction_id),\n            main_policy.name or \"unknown\",\n            \"completed\",\n            duration=time.time() - policy_start_time if policy_start_time else None,\n            details={\"has_response\": transaction.response.payload is not None},\n        )\n\n        logger.info(\n            \"Policy execution complete\",\n            extra={\n                \"transaction_id\": str(transaction.transaction_id),\n                \"policy_name\": main_policy.name,\n                \"duration_seconds\": time.time() - policy_start_time if policy_start_time else None,\n            },\n        )\n        if transaction.response.payload is not None:\n            final_response = openai_chat_completions_response_to_fastapi_response(transaction.response.payload)\n        else:\n            final_response = JSONResponse(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                content={\n                    \"detail\": \"Internal Server Error: No response payload\",\n                    \"transaction_id\": str(transaction.transaction_id),\n                    \"policy_name\": main_policy.name,\n                },\n            )\n\n    except ControlPolicyError as e:\n        # Log policy error\n        policy_duration = time.time() - policy_start_time if policy_start_time else None\n        log_policy_execution(\n            str(transaction.transaction_id),\n            main_policy.name or \"unknown\",\n            \"error\",\n            duration=policy_duration,\n            error=str(e),\n            details={\n                \"error_type\": e.__class__.__name__,\n                \"policy_name\": getattr(e, \"policy_name\", \"unknown\"),\n            },\n        )\n\n        logger.warning(\n            f\"Control policy error - transaction {transaction.transaction_id}\",\n            extra={\n                \"transaction_id\": str(transaction.transaction_id),\n                \"error\": str(e),\n                \"error_type\": e.__class__.__name__,\n                \"policy_name\": getattr(e, \"policy_name\", \"unknown\"),\n            },\n        )\n        # Directly build a JSONResponse for policy errors\n        policy_name_for_error = getattr(e, \"policy_name\", \"unknown\")\n        status_code = getattr(e, \"status_code\", None) or status.HTTP_400_BAD_REQUEST  # Use 400 if None or not specified\n        error_detail = getattr(e, \"detail\", str(e))  # Use str(e) if no detail attribute\n\n        # Check if we're in dev mode and if the exception has debug info\n        settings = Settings()\n        debug_details = None\n\n        if settings.dev_mode():\n            # Check if the ControlPolicyError itself has debug info\n            if hasattr(e, \"debug_info\"):\n                debug_details = e.debug_info  # type: ignore\n            # Check if the underlying exception (__cause__) has debug info\n            elif hasattr(e, \"__cause__\") and hasattr(e.__cause__, \"debug_info\"):\n                debug_details = e.__cause__.debug_info  # type: ignore\n\n        # Use create_debug_response to generate the response\n        response_content = create_debug_response(\n            status_code=status_code,\n            message=f\"Policy error in '{policy_name_for_error}': {error_detail}\",\n            transaction_id=str(transaction.transaction_id),\n            details=debug_details,\n            include_debug_info=settings.dev_mode(),\n        )\n\n        final_response = JSONResponse(\n            status_code=status_code,\n            content=response_content,\n        )\n\n    except Exception as e:\n        # Log unexpected error\n        policy_duration = time.time() - policy_start_time if policy_start_time else None\n        log_policy_execution(\n            str(transaction.transaction_id),\n            main_policy.name or \"unknown\",\n            \"error\",\n            duration=policy_duration,\n            error=str(e),\n            details={\n                \"error_type\": e.__class__.__name__,\n                \"unexpected\": True,\n            },\n        )\n\n        # Handle unexpected errors during initialization or policy execution\n        logger.exception(\n            f\"Unhandled exception during policy flow - transaction {transaction.transaction_id}\",\n            extra={\n                \"transaction_id\": str(transaction.transaction_id),\n                \"error\": str(e),\n                \"error_type\": e.__class__.__name__,\n            },\n        )\n        # Try to build an error response using the builder\n        policy_name_for_error = getattr(main_policy, \"name\", main_policy.__class__.__name__)\n\n        # Check if we're in dev mode and if the exception has debug info\n        settings = Settings()\n        debug_details = None\n\n        if settings.dev_mode() and hasattr(e, \"debug_info\"):\n            debug_details = e.debug_info  # type: ignore\n\n        # Use create_debug_response to generate the response\n        response_content = create_debug_response(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            message=\"Internal Server Error\",\n            transaction_id=str(transaction.transaction_id),\n            details=debug_details,\n            include_debug_info=settings.dev_mode(),\n        )\n\n        # Add policy name to the response\n        response_content[\"policy_name\"] = policy_name_for_error\n\n        final_response = JSONResponse(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            content=response_content,\n        )\n\n    return final_response\n</code></pre> <p>Orchestrates the execution of the main ControlPolicy using injected dependencies. Exceptions raised by policies are expected to be caught by FastAPI exception handlers.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming FastAPI request.</p> required <code>main_policy</code> <code>ControlPolicy</code> <p>The main policy instance to execute.</p> required <code>dependencies</code> <code>DependencyContainer</code> <p>The application's dependency container.</p> required <code>session</code> <code>AsyncSession</code> <p>The database session for this request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>The final FastAPI response.</p>"},{"location":"#luthien_control.proxy.server","title":"<code>server</code>","text":""},{"location":"#luthien_control.proxy.server.api_proxy_endpoint","title":"<code>api_proxy_endpoint(request, full_path=default_path, dependencies=Depends(get_dependencies), main_policy=Depends(get_main_control_policy), session=Depends(get_db_session), payload=default_payload, token=Security(http_bearer_auth))</code>  <code>async</code>","text":"Source code in <code>luthien_control/proxy/server.py</code> <pre><code>@router.post(\n    \"/api/{full_path:path}\",\n)\nasync def api_proxy_endpoint(\n    request: Request,\n    full_path: str = default_path,\n    # --- Core Dependencies ---\n    dependencies: DependencyContainer = Depends(get_dependencies),\n    main_policy: ControlPolicy = Depends(get_main_control_policy),\n    session: AsyncSession = Depends(get_db_session),\n    # --- Swagger UI Enhancements ---\n    # The 'payload' and 'token' parameters enhance the Swagger UI:\n    # - 'payload' (dict[str, Any], optional): Provides a schema for the request body.\n    #   Actual body content is read directly from the 'request' object.\n    # - 'token' (Optional[str]): Enables the 'Authorize' button (Bearer token).\n    #   Actual token validation is handled by the policy flow.\n    payload: dict[str, Any] = default_payload,\n    token: Optional[str] = Security(http_bearer_auth),\n):\n    \"\"\"\n    Main API proxy endpoint using the policy orchestration flow.\n    Handles requests starting with /api/.\n    Uses Dependency Injection Container and provides a DB session.\n\n    **Authentication Note:** This endpoint uses Bearer Token authentication\n    (Authorization: Bearer &lt;token&gt;). However, the requirement for a valid token\n    depends on whether the currently configured control policy includes client\n    authentication (e.g., ClientApiKeyAuthPolicy). If the policy does not require\n    authentication, the token field can be left blank.\n    \"\"\"\n    return await _handle_api_request(request, main_policy, dependencies, session)\n</code></pre> <p>Main API proxy endpoint using the policy orchestration flow. Handles requests starting with /api/. Uses Dependency Injection Container and provides a DB session.</p> <p>Authentication Note: This endpoint uses Bearer Token authentication (Authorization: Bearer ). However, the requirement for a valid token depends on whether the currently configured control policy includes client authentication (e.g., ClientApiKeyAuthPolicy). If the policy does not require authentication, the token field can be left blank."},{"location":"#luthien_control.proxy.server.api_proxy_get_endpoint","title":"<code>api_proxy_get_endpoint(request, full_path=default_path, dependencies=Depends(get_dependencies), main_policy=Depends(get_main_control_policy), session=Depends(get_db_session), token=Security(http_bearer_auth))</code>  <code>async</code>","text":"Source code in <code>luthien_control/proxy/server.py</code> <pre><code>@router.get(\n    \"/api/{full_path:path}\",\n)\nasync def api_proxy_get_endpoint(\n    request: Request,\n    full_path: str = default_path,\n    # --- Core Dependencies ---\n    dependencies: DependencyContainer = Depends(get_dependencies),\n    main_policy: ControlPolicy = Depends(get_main_control_policy),\n    session: AsyncSession = Depends(get_db_session),\n    # --- Swagger UI Enhancements ---\n    # - 'token' (Optional[str]): Enables the 'Authorize' button (Bearer token).\n    #   Actual token validation is handled by the policy flow.\n    token: Optional[str] = Security(http_bearer_auth),\n):\n    \"\"\"\n    Main API proxy endpoint for GET requests using the policy orchestration flow.\n    Handles GET requests starting with /api/.\n    Uses Dependency Injection Container and provides a DB session.\n\n    **Authentication Note:** This endpoint uses Bearer Token authentication\n    (Authorization: Bearer &lt;token&gt;). However, the requirement for a valid token\n    depends on whether the currently configured control policy includes client\n    authentication (e.g., ClientApiKeyAuthPolicy). If the policy does not require\n    authentication, the token field can be left blank.\n    \"\"\"\n    return await _handle_api_request(request, main_policy, dependencies, session)\n</code></pre> <p>Main API proxy endpoint for GET requests using the policy orchestration flow. Handles GET requests starting with /api/. Uses Dependency Injection Container and provides a DB session.</p> <p>Authentication Note: This endpoint uses Bearer Token authentication (Authorization: Bearer ). However, the requirement for a valid token depends on whether the currently configured control policy includes client authentication (e.g., ClientApiKeyAuthPolicy). If the policy does not require authentication, the token field can be left blank."},{"location":"#luthien_control.proxy.server.api_proxy_options_handler","title":"<code>api_proxy_options_handler(full_path=default_path)</code>  <code>async</code>","text":"Source code in <code>luthien_control/proxy/server.py</code> <pre><code>@router.options(\"/api/{full_path:path}\")\nasync def api_proxy_options_handler(\n    full_path: str = default_path,  # Keep for path consistency, though not used in this simple handler\n):\n    \"\"\"\n    Handles OPTIONS requests for the API proxy endpoint, indicating allowed methods.\n    \"\"\"\n    logger.info(f\"Explicit OPTIONS request received for /api/{full_path}\")\n    headers = {\n        \"Allow\": \"GET, POST, OPTIONS\",\n        \"Access-Control-Allow-Origin\": \"*\",  # Allow any origin\n        \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",  # Allowed methods\n        \"Access-Control-Allow-Headers\": \"Authorization, Content-Type\",  # Allowed headers\n    }\n    return Response(status_code=200, headers=headers)\n</code></pre> <p>Handles OPTIONS requests for the API proxy endpoint, indicating allowed methods.</p>"},{"location":"#luthien_control.settings","title":"<code>settings</code>","text":""},{"location":"#luthien_control.settings.Settings","title":"<code>Settings</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>class Settings:\n    \"\"\"Application configuration settings loaded from environment variables.\"\"\"\n\n    # --- Core Settings ---\n    BACKEND_URL: Optional[str] = None\n    # Comma-separated list of control policies for the beta framework\n\n    # --- Database Settings ---\n    DB_SERVER: str = \"localhost\"\n    DB_USER: Optional[str] = None\n    DB_PASSWORD: Optional[str] = None\n    DB_NAME: Optional[str] = None\n    DB_HOST: Optional[str] = None\n    DB_PORT: Optional[int] = 5432\n\n    # --- OpenAI Settings ---\n    OPENAI_API_KEY: Optional[str] = None\n\n    # --- Helper Methods using os.getenv ---\n    def get_backend_url(self) -&gt; Optional[str]:\n        \"\"\"Returns the backend URL as a string, if set.\"\"\"\n        url = os.getenv(\"BACKEND_URL\")\n        if url:\n            # Basic validation (can be enhanced)\n            parsed = urlparse(url)\n            if not all([parsed.scheme, parsed.netloc]):\n                raise ValueError(f\"Invalid BACKEND_URL format: {url}\")\n        return url\n\n    def get_database_url(self) -&gt; Optional[str]:\n        \"\"\"Returns the primary DATABASE_URL, if set.\"\"\"\n        return os.getenv(\"DATABASE_URL\")\n\n    def get_openai_api_key(self) -&gt; str | None:\n        \"\"\"Returns the OpenAI API key, if set.\"\"\"\n        return os.getenv(\"OPENAI_API_KEY\")\n\n    def get_top_level_policy_name(self) -&gt; str:\n        \"\"\"Returns the name of the top-level policy instance to load.\"\"\"\n        return os.getenv(\"TOP_LEVEL_POLICY_NAME\", \"root\")\n\n    def get_policy_filepath(self) -&gt; str | None:\n        \"\"\"Returns the path to the policy file, if set.\"\"\"\n        return os.getenv(\"POLICY_FILEPATH\")\n\n    # --- Database settings Getters using os.getenv ---\n    def get_postgres_user(self) -&gt; str | None:\n        return os.getenv(\"DB_USER\")\n\n    def get_postgres_password(self) -&gt; str | None:\n        return os.getenv(\"DB_PASSWORD\")\n\n    def get_postgres_db(self) -&gt; str | None:\n        return os.getenv(\"DB_NAME\")\n\n    def get_postgres_host(self) -&gt; str | None:\n        return os.getenv(\"DB_HOST\")\n\n    def get_postgres_port(self) -&gt; int | None:\n        \"\"\"Returns the PostgreSQL port as an integer, or None if not set.\"\"\"\n        port_str = os.getenv(\"DB_PORT\")\n        if port_str is None:\n            return None\n        try:\n            return int(port_str)\n        except ValueError:\n            raise ValueError(\"DB_PORT environment variable must be an integer.\")\n\n    # --- DB Pool Size Getters ---\n    def get_main_db_pool_min_size(self) -&gt; int:\n        \"\"\"Returns the minimum pool size for the main DB.\"\"\"\n        try:\n            return int(os.getenv(\"MAIN_DB_POOL_MIN_SIZE\", \"1\"))\n        except ValueError:\n            raise ValueError(\"MAIN_DB_POOL_MIN_SIZE environment variable must be an integer.\")\n\n    def get_main_db_pool_max_size(self) -&gt; int:\n        \"\"\"Returns the maximum pool size for the main DB.\"\"\"\n        try:\n            return int(os.getenv(\"MAIN_DB_POOL_MAX_SIZE\", \"10\"))\n        except ValueError:\n            raise ValueError(\"MAIN_DB_POOL_MAX_SIZE environment variable must be an integer.\")\n\n    # --- Logging Settings --- #\n    def get_log_level(self, default: str = \"INFO\") -&gt; str:\n        \"\"\"Gets the configured log level, defaulting if not set.\"\"\"\n        return os.getenv(\"LOG_LEVEL\", default).upper()\n\n    # uvicorn\n    def get_app_host(self, default: str = \"0.0.0.0\") -&gt; str:\n        \"\"\"Gets the configured app host, defaulting if not set.\"\"\"\n        return os.getenv(\"LUTHIEN_CONTROL_HOST\", default)\n\n    def get_app_port(self, default: int = 8000) -&gt; int:\n        \"\"\"Gets the configured app port, defaulting if not set.\"\"\"\n        return int(os.getenv(\"LUTHIEN_CONTROL_PORT\", default))\n\n    def get_app_reload(self, default: bool = False) -&gt; bool:\n        \"\"\"Gets the configured app reload, defaulting if not set.\"\"\"\n        reload = os.getenv(\"LUTHIEN_CONTROL_RELOAD\")\n        if reload is None:\n            return default\n        elif reload.lower() == \"true\":\n            return True\n        elif reload.lower() == \"false\":\n            return False\n        else:\n            raise ValueError(f\"LUTHIEN_CONTROL_RELOAD environment variable must be 'true' or 'false' (got {reload}).\")\n\n    # get_log_level is reused\n\n    # --- Database DSN Helper Properties using Getters ---\n    @property\n    def admin_dsn(self) -&gt; str:\n        \"\"\"DSN for connecting to the default 'postgres' db for admin tasks.\n        Raises ValueError if required DB settings are missing.\n        \"\"\"\n        user = self.get_postgres_user()\n        password = self.get_postgres_password()\n        host = self.get_postgres_host()\n        port = self.get_postgres_port()\n\n        if not all([user, password, host, port]):\n            missing = [\n                name\n                for name, val in [(\"USER\", user), (\"PASSWORD\", password), (\"HOST\", host), (\"PORT\", port)]\n                if not val\n            ]\n            raise ValueError(f\"Missing required database settings ({', '.join(missing)}) for admin_dsn\")\n\n        return f\"postgresql://{user}:{password}@{host}:{port}/postgres\"\n\n    @property\n    def base_dsn(self) -&gt; str:\n        \"\"\"Base DSN without a specific database name.\n        Raises ValueError if required DB settings are missing.\n        \"\"\"\n        user = self.get_postgres_user()\n        password = self.get_postgres_password()\n        host = self.get_postgres_host()\n        port = self.get_postgres_port()\n\n        if not all([user, password, host, port]):\n            missing = [\n                name\n                for name, val in [(\"USER\", user), (\"PASSWORD\", password), (\"HOST\", host), (\"PORT\", port)]\n                if not val\n            ]\n            raise ValueError(f\"Missing required database settings ({', '.join(missing)}) for base_dsn\")\n\n        return f\"postgresql://{user}:{password}@{host}:{port}\"\n\n    def get_db_dsn(self, db_name: str | None = None) -&gt; str:\n        \"\"\"Returns the DSN for a specific database name, or the default DB_NAME.\n        Raises ValueError if required DB settings or the target db_name are missing.\n        \"\"\"\n        target_db = db_name or self.get_postgres_db()\n        if not target_db:\n            raise ValueError(\"Missing target database name (either provide db_name or set DB_NAME env var)\")\n        base = self.base_dsn  # Use property\n        return f\"{base}/{target_db}\"\n\n    def get_run_mode(self) -&gt; str:\n        \"\"\"Returns the run mode, defaulting to 'prod' if not set.\"\"\"\n        return os.getenv(\"RUN_MODE\", \"prod\")\n\n    def dev_mode(self) -&gt; bool:\n        \"\"\"Returns True if the run mode is 'dev', False otherwise.\"\"\"\n        return self.get_run_mode() == \"dev\"\n</code></pre> <p>Application configuration settings loaded from environment variables.</p>"},{"location":"#luthien_control.settings.Settings.admin_dsn","title":"<code>property</code>","text":"<p>DSN for connecting to the default 'postgres' db for admin tasks. Raises ValueError if required DB settings are missing.</p>"},{"location":"#luthien_control.settings.Settings.admin_dsn","title":"<code>admin_dsn</code>  <code>property</code>","text":"<p>DSN for connecting to the default 'postgres' db for admin tasks. Raises ValueError if required DB settings are missing.</p>"},{"location":"#luthien_control.settings.Settings.base_dsn","title":"<code>property</code>","text":"<p>Base DSN without a specific database name. Raises ValueError if required DB settings are missing.</p>"},{"location":"#luthien_control.settings.Settings.base_dsn","title":"<code>base_dsn</code>  <code>property</code>","text":"<p>Base DSN without a specific database name. Raises ValueError if required DB settings are missing.</p>"},{"location":"#luthien_control.settings.Settings.dev_mode","title":"<code>dev_mode()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def dev_mode(self) -&gt; bool:\n    \"\"\"Returns True if the run mode is 'dev', False otherwise.\"\"\"\n    return self.get_run_mode() == \"dev\"\n</code></pre> <p>Returns True if the run mode is 'dev', False otherwise.</p>"},{"location":"#luthien_control.settings.Settings.get_app_host","title":"<code>get_app_host(default='0.0.0.0')</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_app_host(self, default: str = \"0.0.0.0\") -&gt; str:\n    \"\"\"Gets the configured app host, defaulting if not set.\"\"\"\n    return os.getenv(\"LUTHIEN_CONTROL_HOST\", default)\n</code></pre> <p>Gets the configured app host, defaulting if not set.</p>"},{"location":"#luthien_control.settings.Settings.get_app_port","title":"<code>get_app_port(default=8000)</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_app_port(self, default: int = 8000) -&gt; int:\n    \"\"\"Gets the configured app port, defaulting if not set.\"\"\"\n    return int(os.getenv(\"LUTHIEN_CONTROL_PORT\", default))\n</code></pre> <p>Gets the configured app port, defaulting if not set.</p>"},{"location":"#luthien_control.settings.Settings.get_app_reload","title":"<code>get_app_reload(default=False)</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_app_reload(self, default: bool = False) -&gt; bool:\n    \"\"\"Gets the configured app reload, defaulting if not set.\"\"\"\n    reload = os.getenv(\"LUTHIEN_CONTROL_RELOAD\")\n    if reload is None:\n        return default\n    elif reload.lower() == \"true\":\n        return True\n    elif reload.lower() == \"false\":\n        return False\n    else:\n        raise ValueError(f\"LUTHIEN_CONTROL_RELOAD environment variable must be 'true' or 'false' (got {reload}).\")\n</code></pre> <p>Gets the configured app reload, defaulting if not set.</p>"},{"location":"#luthien_control.settings.Settings.get_backend_url","title":"<code>get_backend_url()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_backend_url(self) -&gt; Optional[str]:\n    \"\"\"Returns the backend URL as a string, if set.\"\"\"\n    url = os.getenv(\"BACKEND_URL\")\n    if url:\n        # Basic validation (can be enhanced)\n        parsed = urlparse(url)\n        if not all([parsed.scheme, parsed.netloc]):\n            raise ValueError(f\"Invalid BACKEND_URL format: {url}\")\n    return url\n</code></pre> <p>Returns the backend URL as a string, if set.</p>"},{"location":"#luthien_control.settings.Settings.get_database_url","title":"<code>get_database_url()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_database_url(self) -&gt; Optional[str]:\n    \"\"\"Returns the primary DATABASE_URL, if set.\"\"\"\n    return os.getenv(\"DATABASE_URL\")\n</code></pre> <p>Returns the primary DATABASE_URL, if set.</p>"},{"location":"#luthien_control.settings.Settings.get_db_dsn","title":"<code>get_db_dsn(db_name=None)</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_db_dsn(self, db_name: str | None = None) -&gt; str:\n    \"\"\"Returns the DSN for a specific database name, or the default DB_NAME.\n    Raises ValueError if required DB settings or the target db_name are missing.\n    \"\"\"\n    target_db = db_name or self.get_postgres_db()\n    if not target_db:\n        raise ValueError(\"Missing target database name (either provide db_name or set DB_NAME env var)\")\n    base = self.base_dsn  # Use property\n    return f\"{base}/{target_db}\"\n</code></pre> <p>Returns the DSN for a specific database name, or the default DB_NAME. Raises ValueError if required DB settings or the target db_name are missing.</p>"},{"location":"#luthien_control.settings.Settings.get_log_level","title":"<code>get_log_level(default='INFO')</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_log_level(self, default: str = \"INFO\") -&gt; str:\n    \"\"\"Gets the configured log level, defaulting if not set.\"\"\"\n    return os.getenv(\"LOG_LEVEL\", default).upper()\n</code></pre> <p>Gets the configured log level, defaulting if not set.</p>"},{"location":"#luthien_control.settings.Settings.get_main_db_pool_max_size","title":"<code>get_main_db_pool_max_size()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_main_db_pool_max_size(self) -&gt; int:\n    \"\"\"Returns the maximum pool size for the main DB.\"\"\"\n    try:\n        return int(os.getenv(\"MAIN_DB_POOL_MAX_SIZE\", \"10\"))\n    except ValueError:\n        raise ValueError(\"MAIN_DB_POOL_MAX_SIZE environment variable must be an integer.\")\n</code></pre> <p>Returns the maximum pool size for the main DB.</p>"},{"location":"#luthien_control.settings.Settings.get_main_db_pool_min_size","title":"<code>get_main_db_pool_min_size()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_main_db_pool_min_size(self) -&gt; int:\n    \"\"\"Returns the minimum pool size for the main DB.\"\"\"\n    try:\n        return int(os.getenv(\"MAIN_DB_POOL_MIN_SIZE\", \"1\"))\n    except ValueError:\n        raise ValueError(\"MAIN_DB_POOL_MIN_SIZE environment variable must be an integer.\")\n</code></pre> <p>Returns the minimum pool size for the main DB.</p>"},{"location":"#luthien_control.settings.Settings.get_openai_api_key","title":"<code>get_openai_api_key()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_openai_api_key(self) -&gt; str | None:\n    \"\"\"Returns the OpenAI API key, if set.\"\"\"\n    return os.getenv(\"OPENAI_API_KEY\")\n</code></pre> <p>Returns the OpenAI API key, if set.</p>"},{"location":"#luthien_control.settings.Settings.get_policy_filepath","title":"<code>get_policy_filepath()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_policy_filepath(self) -&gt; str | None:\n    \"\"\"Returns the path to the policy file, if set.\"\"\"\n    return os.getenv(\"POLICY_FILEPATH\")\n</code></pre> <p>Returns the path to the policy file, if set.</p>"},{"location":"#luthien_control.settings.Settings.get_postgres_port","title":"<code>get_postgres_port()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_postgres_port(self) -&gt; int | None:\n    \"\"\"Returns the PostgreSQL port as an integer, or None if not set.\"\"\"\n    port_str = os.getenv(\"DB_PORT\")\n    if port_str is None:\n        return None\n    try:\n        return int(port_str)\n    except ValueError:\n        raise ValueError(\"DB_PORT environment variable must be an integer.\")\n</code></pre> <p>Returns the PostgreSQL port as an integer, or None if not set.</p>"},{"location":"#luthien_control.settings.Settings.get_run_mode","title":"<code>get_run_mode()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_run_mode(self) -&gt; str:\n    \"\"\"Returns the run mode, defaulting to 'prod' if not set.\"\"\"\n    return os.getenv(\"RUN_MODE\", \"prod\")\n</code></pre> <p>Returns the run mode, defaulting to 'prod' if not set.</p>"},{"location":"#luthien_control.settings.Settings.get_top_level_policy_name","title":"<code>get_top_level_policy_name()</code>","text":"Source code in <code>luthien_control/settings.py</code> <pre><code>def get_top_level_policy_name(self) -&gt; str:\n    \"\"\"Returns the name of the top-level policy instance to load.\"\"\"\n    return os.getenv(\"TOP_LEVEL_POLICY_NAME\", \"root\")\n</code></pre> <p>Returns the name of the top-level policy instance to load.</p>"},{"location":"#luthien_control.utils","title":"<code>utils</code>","text":""},{"location":"#luthien_control.utils.DeepEventedModel","title":"<code>DeepEventedModel</code>","text":"<p>           Bases: <code>EventedModel</code></p> Source code in <code>luthien_control/utils/deep_evented_model.py</code> <pre><code>class DeepEventedModel(EventedModel):\n    \"\"\"A Pydantic EventedModel that emits a single `changed` signal on any change.\n\n    This includes changes to top-level fields as well as changes within\n    nested evented containers (like EventedList, EventedDict) or other\n    DeepEventedModel instances.\n\n    Attributes:\n        changed: A signal that is emitted with no arguments when any value\n                 in the model or its nested evented children changes.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    changed: ClassVar[Signal] = Signal()\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        # Connect our master `changed` signal to the base model's event group.\n        # This handles all top-level field assignments.\n        self.events.connect(self.changed)\n        # Connect to the event groups of any initial child objects.\n        self._connect_children()\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        # Before the attribute is set, we must disconnect from the old child object.\n        if name in self.__class__.model_fields:\n            old_value = getattr(self, name, None)\n            self._disconnect_child(old_value)\n\n        super().__setattr__(name, value)\n\n        # After the attribute is set, we connect to the new child object.\n        if name in self.__class__.model_fields:\n            new_value = getattr(self, name)\n            self._connect_child(new_value)\n            # The base EventedModel handles emitting the field-specific signal,\n            # which is already piped to our `changed` signal.\n\n    def _connect_child(self, child: Any) -&gt; None:\n        \"\"\"If `child` is an evented object, connect its events to our signal.\"\"\"\n        if isinstance(child, DeepEventedModel):\n            child.changed.connect(self.changed)\n        elif isinstance(child, EventedList):\n            child.events.connect(self.changed)\n            child.events.inserted.connect(self._on_item_inserted)\n            child.events.removed.connect(self._on_item_removed)\n            for item in child:\n                self._connect_child(item)\n        elif isinstance(child, EventedDict):\n            child.events.connect(self.changed)\n            child.events.added.connect(self._on_item_added)\n            for item in child.values():\n                self._connect_child(item)\n        elif self._is_evented(child):\n            child.events.connect(self.changed)\n\n    def _disconnect_child(self, child: Any) -&gt; None:\n        \"\"\"If `child` is an evented object, disconnect its events.\"\"\"\n        if isinstance(child, DeepEventedModel):\n            child.changed.disconnect(self.changed)\n        elif isinstance(child, EventedList):\n            child.events.disconnect(self.changed)\n            child.events.inserted.disconnect(self._on_item_inserted)\n            child.events.removed.disconnect(self._on_item_removed)\n            for item in child:\n                self._disconnect_child(item)\n        elif isinstance(child, EventedDict):\n            child.events.disconnect(self.changed)\n            child.events.added.disconnect(self._on_item_added)\n            for item in child.values():\n                self._disconnect_child(item)\n        elif self._is_evented(child):\n            child.events.disconnect(self.changed)\n\n    def _on_item_inserted(self, index: int, value: Any):\n        self._connect_child(value)\n\n    def _on_item_removed(self, index: int, value: Any):\n        self._disconnect_child(value)\n\n    def _on_item_added(self, key: str, value: Any):\n        self._connect_child(value)\n\n    def _connect_children(self) -&gt; None:\n        \"\"\"Connect to the events of all evented children in the model.\"\"\"\n        for name in self.__class__.model_fields:\n            child = getattr(self, name)\n            self._connect_child(child)\n\n    def _is_evented(self, obj: Any) -&gt; bool:\n        \"\"\"Check if an object has a connectable `events` signal group.\"\"\"\n        events = getattr(obj, \"events\", None)\n        return events is not None and callable(getattr(events, \"connect\", None))\n\n    @model_serializer(mode=\"wrap\")\n    def _serialize_model(self, serializer, info):\n        \"\"\"Custom model serializer that converts EventedList and EventedDict to regular containers.\"\"\"\n        # First, check if this model actually has any EventedList or EventedDict fields\n        has_evented_containers = False\n        for field_name, field_info in self.__class__.model_fields.items():\n            value = getattr(self, field_name)\n            if isinstance(value, (EventedList, EventedDict)):\n                has_evented_containers = True\n                break\n\n        # If no evented containers, use default serialization\n        if not has_evented_containers:\n            return serializer(self)\n\n        # Otherwise, handle evented containers specially\n        data = {}\n        for field_name, field_info in self.__class__.model_fields.items():\n            value = getattr(self, field_name)\n            if isinstance(value, EventedList):\n                data[field_name] = list(value)\n            elif isinstance(value, EventedDict):\n                data[field_name] = dict(value)\n            else:\n                # For other types, use the default field serialization\n                data[field_name] = value\n        return data\n</code></pre> <p>A Pydantic EventedModel that emits a single <code>changed</code> signal on any change.</p> <p>This includes changes to top-level fields as well as changes within nested evented containers (like EventedList, EventedDict) or other DeepEventedModel instances.</p> <p>Attributes:</p> Name Type Description <code>changed</code> <code>Signal</code> <p>A signal that is emitted with no arguments when any value      in the model or its nested evented children changes.</p>"},{"location":"#luthien_control.utils.backend_call_spec","title":"<code>backend_call_spec</code>","text":""},{"location":"#luthien_control.utils.backend_call_spec.BackendCallSpec","title":"<code>BackendCallSpec</code>","text":"<p>           Bases: <code>BaseModel</code></p> Source code in <code>luthien_control/utils/backend_call_spec.py</code> <pre><code>class BackendCallSpec(BaseModel):\n    \"\"\"\n    A specification for a backend LLM call.\n    \"\"\"\n\n    model: str = Field(default=\"gpt-4o-mini\")\n    api_endpoint: str = Field(default=\"https://api.openai.com/v1\")\n    api_key_env_var: str = Field(default=\"OPENAI_API_KEY\")\n    request_args: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Arguments to be passed to OpenAIChatCompletionsRequest.\",\n    )\n</code></pre> <p>A specification for a backend LLM call.</p>"},{"location":"#luthien_control.utils.deep_evented_model","title":"<code>deep_evented_model</code>","text":""},{"location":"#luthien_control.utils.deep_evented_model.DeepEventedModel","title":"<code>DeepEventedModel</code>","text":"<p>           Bases: <code>EventedModel</code></p> Source code in <code>luthien_control/utils/deep_evented_model.py</code> <pre><code>class DeepEventedModel(EventedModel):\n    \"\"\"A Pydantic EventedModel that emits a single `changed` signal on any change.\n\n    This includes changes to top-level fields as well as changes within\n    nested evented containers (like EventedList, EventedDict) or other\n    DeepEventedModel instances.\n\n    Attributes:\n        changed: A signal that is emitted with no arguments when any value\n                 in the model or its nested evented children changes.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    changed: ClassVar[Signal] = Signal()\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        super().__init__(**kwargs)\n        # Connect our master `changed` signal to the base model's event group.\n        # This handles all top-level field assignments.\n        self.events.connect(self.changed)\n        # Connect to the event groups of any initial child objects.\n        self._connect_children()\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        # Before the attribute is set, we must disconnect from the old child object.\n        if name in self.__class__.model_fields:\n            old_value = getattr(self, name, None)\n            self._disconnect_child(old_value)\n\n        super().__setattr__(name, value)\n\n        # After the attribute is set, we connect to the new child object.\n        if name in self.__class__.model_fields:\n            new_value = getattr(self, name)\n            self._connect_child(new_value)\n            # The base EventedModel handles emitting the field-specific signal,\n            # which is already piped to our `changed` signal.\n\n    def _connect_child(self, child: Any) -&gt; None:\n        \"\"\"If `child` is an evented object, connect its events to our signal.\"\"\"\n        if isinstance(child, DeepEventedModel):\n            child.changed.connect(self.changed)\n        elif isinstance(child, EventedList):\n            child.events.connect(self.changed)\n            child.events.inserted.connect(self._on_item_inserted)\n            child.events.removed.connect(self._on_item_removed)\n            for item in child:\n                self._connect_child(item)\n        elif isinstance(child, EventedDict):\n            child.events.connect(self.changed)\n            child.events.added.connect(self._on_item_added)\n            for item in child.values():\n                self._connect_child(item)\n        elif self._is_evented(child):\n            child.events.connect(self.changed)\n\n    def _disconnect_child(self, child: Any) -&gt; None:\n        \"\"\"If `child` is an evented object, disconnect its events.\"\"\"\n        if isinstance(child, DeepEventedModel):\n            child.changed.disconnect(self.changed)\n        elif isinstance(child, EventedList):\n            child.events.disconnect(self.changed)\n            child.events.inserted.disconnect(self._on_item_inserted)\n            child.events.removed.disconnect(self._on_item_removed)\n            for item in child:\n                self._disconnect_child(item)\n        elif isinstance(child, EventedDict):\n            child.events.disconnect(self.changed)\n            child.events.added.disconnect(self._on_item_added)\n            for item in child.values():\n                self._disconnect_child(item)\n        elif self._is_evented(child):\n            child.events.disconnect(self.changed)\n\n    def _on_item_inserted(self, index: int, value: Any):\n        self._connect_child(value)\n\n    def _on_item_removed(self, index: int, value: Any):\n        self._disconnect_child(value)\n\n    def _on_item_added(self, key: str, value: Any):\n        self._connect_child(value)\n\n    def _connect_children(self) -&gt; None:\n        \"\"\"Connect to the events of all evented children in the model.\"\"\"\n        for name in self.__class__.model_fields:\n            child = getattr(self, name)\n            self._connect_child(child)\n\n    def _is_evented(self, obj: Any) -&gt; bool:\n        \"\"\"Check if an object has a connectable `events` signal group.\"\"\"\n        events = getattr(obj, \"events\", None)\n        return events is not None and callable(getattr(events, \"connect\", None))\n\n    @model_serializer(mode=\"wrap\")\n    def _serialize_model(self, serializer, info):\n        \"\"\"Custom model serializer that converts EventedList and EventedDict to regular containers.\"\"\"\n        # First, check if this model actually has any EventedList or EventedDict fields\n        has_evented_containers = False\n        for field_name, field_info in self.__class__.model_fields.items():\n            value = getattr(self, field_name)\n            if isinstance(value, (EventedList, EventedDict)):\n                has_evented_containers = True\n                break\n\n        # If no evented containers, use default serialization\n        if not has_evented_containers:\n            return serializer(self)\n\n        # Otherwise, handle evented containers specially\n        data = {}\n        for field_name, field_info in self.__class__.model_fields.items():\n            value = getattr(self, field_name)\n            if isinstance(value, EventedList):\n                data[field_name] = list(value)\n            elif isinstance(value, EventedDict):\n                data[field_name] = dict(value)\n            else:\n                # For other types, use the default field serialization\n                data[field_name] = value\n        return data\n</code></pre> <p>A Pydantic EventedModel that emits a single <code>changed</code> signal on any change.</p> <p>This includes changes to top-level fields as well as changes within nested evented containers (like EventedList, EventedDict) or other DeepEventedModel instances.</p> <p>Attributes:</p> Name Type Description <code>changed</code> <code>Signal</code> <p>A signal that is emitted with no arguments when any value      in the model or its nested evented children changes.</p>"},{"location":"examples/model_name_replacement_policy/","title":"Model Name Replacement Policy","text":"<p>The <code>ModelNameReplacementPolicy</code> allows you to replace model names in requests based on a configured mapping. This is particularly useful when working with clients like Cursor that assume model strings matching known models must route through specific endpoints.</p>"},{"location":"examples/model_name_replacement_policy/#use-case","title":"Use Case","text":"<p>You want to use OpenAI API endpoints to access models from other providers like Gemini or Claude, but the client application (e.g., Cursor) assumes that certain model names must route through specific endpoints.</p> <p>With this policy, clients can send requests with special model names that will be replaced with the actual model names before the request reaches the backend.</p>"},{"location":"examples/model_name_replacement_policy/#configuration-example","title":"Configuration Example","text":"<pre><code>{\n  \"type\": \"ModelNameReplacement\",\n  \"model_mapping\": {\n    \"fakename\": \"realname\",\n    \"gemini-2.5-pro-preview-05-06\": \"gpt-4o\",\n    \"claude-3-opus-20240229\": \"gpt-4-turbo\"\n  }\n}\n</code></pre>"},{"location":"examples/model_name_replacement_policy/#usage-in-a-serial-policy","title":"Usage in a Serial Policy","text":"<pre><code>{\n  \"type\": \"SerialPolicy\",\n  \"name\": \"my-policy\",\n  \"components\": [\n    {\n      \"type\": \"ClientApiKeyAuth\"\n    },\n    {\n      \"type\": \"ModelNameReplacement\",\n      \"model_mapping\": {\n        \"gemini-2.5-pro-preview-05-06\": \"gpt-4o\"\n      }\n    },\n    {\n      \"type\": \"AddApiKeyHeaderFromEnv\",\n      \"api_key_env_var\": \"OPENAI_API_KEY\"\n    },\n    {\n      \"type\": \"SendBackendRequest\"\n    }\n  ]\n}\n</code></pre>"}]}