import logging
import uuid

import fastapi
import httpx
from fastapi import status  # Added for status codes
from fastapi.responses import JSONResponse  # Added for generic 500 error

from luthien_control.config.settings import Settings
from luthien_control.control_policy.control_policy import ControlPolicy
from luthien_control.control_policy.exceptions import ControlPolicyError
from luthien_control.core.response_builder.interface import ResponseBuilder
from luthien_control.core.transaction_context import TransactionContext

# Get a logger for this module
logger = logging.getLogger(__name__)

def _initialize_context(fastapi_request: fastapi.Request, body: bytes) -> TransactionContext:
    transaction_id = uuid.uuid4()
    context = TransactionContext(transaction_id=transaction_id)
    method = fastapi_request.method
    url = fastapi_request.path_params["full_path"]
    headers = fastapi_request.headers.raw
    params = fastapi_request.query_params
    context.request = httpx.Request(
        method=method,
        url=url,
        headers=headers,
        params=params,
        content=body,
    )
    return context

async def run_policy_flow(
    request: fastapi.Request,
    main_policy: ControlPolicy,
    builder: ResponseBuilder,
    settings: Settings,
    http_client: httpx.AsyncClient,
) -> fastapi.Response:
    """
    Orchestrates the execution of the main ControlPolicy.
    Exceptions raised by policies are expected to be caught by FastAPI exception handlers.

    Args:
        request: The incoming FastAPI request.
        main_policy: The main policy instance to execute after initialization.
        builder: The response builder to generate the final response.
        settings: The application settings.
        http_client: The HTTP client for making backend requests.

    Returns:
        The final FastAPI response generated by the builder if no exceptions occur.
    """
    # 1. Initialize Context
    body = await request.body()
    context = _initialize_context(request, body)

    # 2. Apply the sequence of policies
    try:
        # Apply the single main policy
        policy_name = getattr(main_policy, "name", main_policy.__class__.__name__)
        logger.info(f"[{context.transaction_id}] Applying main policy: {policy_name}")
        context = await main_policy.apply(context)

        # No need to check for context.response here, as the policy itself handles its flow.
        # If it sets a response, it will be handled in the next step.

        # 3. Build Response (if no policy set one)
        if context.response:
            logger.info(f"[{context.transaction_id}] The main policy set the response directly. Skipping builder.")
            final_response = context.response
        else:
            logger.info(f"[{context.transaction_id}] Policy execution complete. Building final response.")
            final_response = builder.build_response(context)

    except ControlPolicyError as e:
        logger.warning(f"[{context.transaction_id}] Control policy error halted execution: {e}")
        # Attempt to build error response using the current context state
        final_response = builder.build_response(context)

    except Exception as e:
        # Handle unexpected errors during initialization or policy execution
        logger.exception(f"[{context.transaction_id}] Unhandled exception during policy flow: {e}")
        # Update context with the generic exception
        context.exception = e  # Store the original exception
        # Try to build an error response using the builder
        policy_name_for_error = getattr(main_policy, "name", main_policy.__class__.__name__)
        try:
            # Pass the caught exception to the builder if it accepts it (new builder signature)
            # Assuming the builder might now take an 'exception' argument even for generic errors
            # If the builder build_response signature wasn't changed to accept 'exception' in all cases,
            # we might need to adapt this call. For DefaultResponseBuilder, it now ignores the exception
            # argument unless it's the *only* thing passed.
            final_response = builder.build_response(
                context, exception=context.exception if isinstance(context.exception, ControlPolicyError) else None
            )
        except Exception as build_e:
            # Log the exception that occurred *during response building*
            logger.exception(
                f"[{context.transaction_id}] Exception occurred *during* error response building: "
                f"{build_e}. Original error was: {e}"
            )
            # Fallback to a basic JSONResponse, mentioning both errors if possible
            error_detail = f"Internal Server Error while processing policy '{policy_name_for_error}'."
            # Include more detail if available
            error_detail += f" Initial error: {e}. Error during response building: {build_e}"
            final_response = JSONResponse(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                content={
                    "detail": error_detail,
                    "transaction_id": str(context.transaction_id),
                },
            )

    return final_response

    # Note: Errors during the *initial* policy or *response building itself* might still propagate
    # depending on the builder implementation and FastAPI's overarching handlers.
