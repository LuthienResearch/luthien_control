---
description: 
globs: 
alwaysApply: true
---
**ðŸš¨ðŸš¨ðŸš¨ MANDATORY TDD ADHERENCE ðŸš¨ðŸš¨ðŸš¨**
**THE TEST-DRIVEN DEVELOPMENT STEPS OUTLINED IN THE "CORE DEVELOPMENT CYCLE" SECTION BELOW ARE ***NOT OPTIONAL***. FAILURE TO FOLLOW STEPS 4-9 IN THE SPECIFIED ORDER IS A VIOLATION OF PROJECT STANDARDS. DO NOT SKIP THESE STEPS.**

# Development Workflow and Practices

**Important Note:** Rule files (in `.cursor/rules/`) are the primary mechanism for defining persistent guidelines, plans, strategies, and context for our work. Verbal agreements or instructions **not codified in these rules may not persist across sessions.** Refer to these rules frequently. Modifying these rules is the **required method** for implementing lasting behavioral changes, following the process in `rule_management.mdc`.

This outlines the standard workflow for implementing features or fixing bugs.

## Starting a New Task (Pre-Cycle Steps)

Before beginning the core development cycle for any new feature, bug fix, or unit of work:

1.  **Validate Clean State:** Ensure the working directory is clean (`git status | cat`) and there are no uncommitted changes from previous work.
2.  **Review Previous Context:** Check the content of `dev/current_context.md` to confirm the last task was completed or that starting a new task is appropriate.
3.  **Set New Context:** **Replace** the entire content of `dev/current_context.md` with the details of the *new* task (goals, scope, initial plan). This MUST be done before any implementation. Refer to `dev_tracking.mdc` (fetch if needed) for specific format details.

Only after these steps are completed should you proceed to the Core Development Cycle.

## Core Development Cycle

Follow these steps sequentially for each discrete task:

1.  **Identify Task:** Define a clear, bounded task. Update `dev/current_context.md` to reflect the new task's goals and scope (as done in Pre-Cycle Step 3 if starting fresh, or update if refining an ongoing task).
2.  **Outline Solution:** Plan the approach, identifying which functions/classes/files will be created or modified.
3.  **TDD Step 1: Implement Skeleton:** Create the necessary files, classes, function/method signatures, and other skeleton code without full implementation (e.g., using `pass` or `NotImplementedError`).
4.  **TDD Step 2: Write Unit Tests:** Implement complete unit tests for the planned functionality *before* writing the implementation code. Ensure tests cover expected behavior and edge cases. Refer to `tdd.mdc` (fetch if needed) for detailed guidance.
5.  **TDD Step 3: Run Unit Tests (Expect Failures):** Run the tests (`poetry run pytest | cat`). They *must* fail for the unimplemented code. This verifies the tests are correctly targeting the new code and setup. If output is missing, run again. See `pytest_interpretation.mdc` (fetch if needed).
6.  **TDD Step 4: Implement Solution:** Write the actual code to implement the feature or fix (replacing the skeleton code).
7.  **TDD Step 5: Run Unit Tests (Verify Pass):** Run the unit tests again (`poetry run pytest | cat`). Iterate on the implementation until all unit tests pass.
8.  **Integration Testing:**
    *   Run existing integration tests (`poetry run pytest | cat`) to ensure no regressions were introduced elsewhere.
    *   If the change introduces significant new interactions or functionality, write new integration tests following TDD principles (Write test -> See fail -> Implement -> See pass).
9.  **Mandatory Tracking Update:** Once all tests pass and the unit of work is complete, **perform the full tracking update procedure**:
    1. Run log rotation: `bash scripts/rotate_dev_log.sh`
    2. Append detailed entry to `dev/development_log.md`.
    3. Replace entire content of `dev/current_context.md`.
    * Refer to `dev_tracking.mdc` (fetch if needed) for detailed format instructions. THIS IS DONE BY THE AI, NOT THE USER.
10. **Git commit:** Follow the `git_commit_strategy` (fetch if needed) to stage the changes (including the updated tracking files) and propose the commit command. Keep commit msg title 1 line, <80 chars.
11. **Push:** After commit is accepted, push the changes (user action).

## Handling Out-of-Scope Issues (`dev/ToDo.md`)

- If issues or potential improvements are identified during a task that fall *outside* the scope of the current task:
    - **Do not** address them immediately (unless critical and discussed with the user).
    - **Add** a clear entry to the `dev/ToDo.md` file describing the issue or idea.
    - Stay focused on completing the current task.

## Test Coverage

- Strive for **near 100% unit test coverage** for all code in the `luthien_control` package. Use tools like `pytest-cov` to monitor coverage. High coverage is crucial for maintainability and refactoring confidence.
