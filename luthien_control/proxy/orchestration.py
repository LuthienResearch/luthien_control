import logging
import uuid
from typing import Sequence

import fastapi
import httpx
from fastapi.responses import JSONResponse  # Added for generic 500 error
from fastapi import status  # Added for status codes

from luthien_control.config.settings import Settings
from luthien_control.control_policy.exceptions import ControlPolicyError
from luthien_control.control_policy.initialize_context import InitializeContextPolicy
from luthien_control.control_policy.interface import ControlPolicy
from luthien_control.core.context import TransactionContext
from luthien_control.core.response_builder.interface import ResponseBuilder

# Get a logger for this module
logger = logging.getLogger(__name__)


async def run_policy_flow(
    request: fastapi.Request,
    policies: Sequence[ControlPolicy],
    builder: ResponseBuilder,
    settings: Settings,
    http_client: httpx.AsyncClient,
    initial_context_policy: InitializeContextPolicy,
) -> fastapi.Response:
    """
    Orchestrates the execution of a sequence of ControlPolicies.
    Exceptions raised by policies are expected to be caught by FastAPI exception handlers.

    Args:
        request: The incoming FastAPI request.
        policies: The sequence of policies to execute after initialization.
        builder: The response builder to generate the final response.
        settings: The application settings.
        http_client: The HTTP client for making backend requests.
        initial_context_policy: The policy used to initialize the context.

    Returns:
        The final FastAPI response generated by the builder if no exceptions occur.
    """
    transaction_id = uuid.uuid4()
    context = TransactionContext(transaction_id=transaction_id)
    # Add essential components to context early for policies to use
    context.settings = settings
    context.http_client = http_client
    context.fastapi_request = request  # Store the original request
    context.exception = None  # Initialize exception attribute

    final_response: fastapi.Response

    # 1. Initialize Context
    context = await initial_context_policy.apply(context, fastapi_request=request)

    # 2. Apply the sequence of policies
    try:
        # Reinstated loop
        for policy in policies:
            policy_name = getattr(policy, "name", policy.__class__.__name__)
            logger.info(f"[{context.transaction_id}] Applying policy: {policy_name}")
            context = await policy.apply(context)
            # Stop if a policy sets a response (e.g., auth failure)
            if context.response is not None:
                logger.info(f"[{context.transaction_id}] Policy {policy_name} set a response. Halting policy flow.")
                break

        # 3. Build Response (if no policy set one)
        if context.response:
            logger.info(f"[{context.transaction_id}] A policy set the response directly. Skipping builder.")
            final_response = context.response
        else:
            logger.info(f"[{context.transaction_id}] Policy execution complete. Building final response.")
            final_response = builder.build_response(context)

    except ControlPolicyError as e:
        logger.warning(f"[{context.transaction_id}] Control policy error halted execution: {e}")
        # Attempt to build error response using the current context state
        final_response = builder.build_response(context)

    except Exception as e:
        # Handle unexpected errors during initialization or policy execution
        logger.exception(f"[{context.transaction_id}] Unhandled exception during policy flow: {e}")
        # Update context with the generic exception
        context.exception = e  # Store the original exception
        # Try to build an error response using the builder
        try:
            # Pass the caught exception to the builder if it accepts it (new builder signature)
            # Assuming the builder might now take an 'exception' argument even for generic errors
            # If the builder build_response signature wasn't changed to accept 'exception' in all cases,
            # we might need to adapt this call. For DefaultResponseBuilder, it now ignores the exception
            # argument unless it's the *only* thing passed.
            final_response = builder.build_response(
                context, exception=context.exception if isinstance(context.exception, ControlPolicyError) else None
            )
        except Exception as build_e:
            # Log the exception that occurred *during response building*
            logger.exception(
                f"[{context.transaction_id}] Exception occurred *during* error response building: {build_e}. Original error was: {e}"
            )
            # Fallback to a basic JSONResponse, mentioning both errors if possible
            final_response = JSONResponse(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                content={
                    "detail": f"Internal Server Error. Initial error: {e}. Error during response building: {build_e}",
                    "transaction_id": str(context.transaction_id),
                },
            )

    return final_response

    # Note: Errors during the *initial* policy or *response building itself* might still propagate
    # depending on the builder implementation and FastAPI's overarching handlers.
