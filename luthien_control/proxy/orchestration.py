import logging
import uuid
from typing import Sequence

import fastapi
import httpx
from fastapi.responses import JSONResponse  # Added for generic 500 error
from fastapi import status  # Added for status codes

from luthien_control.config.settings import Settings
from luthien_control.control_policy.exceptions import ControlPolicyError
from luthien_control.control_policy.initialize_context import InitializeContextPolicy
from luthien_control.control_policy.interface import ControlPolicy
from luthien_control.core.context import TransactionContext
from luthien_control.core.response_builder.interface import ResponseBuilder

# Get a logger for this module
logger = logging.getLogger(__name__)


async def run_policy_flow(
    request: fastapi.Request,
    policies: Sequence[ControlPolicy],
    builder: ResponseBuilder,
    settings: Settings,
    http_client: httpx.AsyncClient,
    initial_context_policy: InitializeContextPolicy,
) -> fastapi.Response:
    """
    Orchestrates the execution of a sequence of ControlPolicies.
    Exceptions raised by policies are expected to be caught by FastAPI exception handlers.

    Args:
        request: The incoming FastAPI request.
        policies: The sequence of policies to execute after initialization.
        builder: The response builder to generate the final response.
        settings: The application settings.
        http_client: The HTTP client for making backend requests.
        initial_context_policy: The policy used to initialize the context.

    Returns:
        The final FastAPI response generated by the builder if no exceptions occur.
    """
    transaction_id = uuid.uuid4()
    context = TransactionContext(transaction_id=transaction_id)
    # Add essential components to context early for policies to use
    context.settings = settings
    context.http_client = http_client
    context.fastapi_request = request  # Store the original request
    context.exception = None  # Initialize exception attribute

    final_response: fastapi.Response

    context = await initial_context_policy.apply(context, fastapi_request=request)
    try:
        for policy in policies:
            context = await policy.apply(context)
        final_response = builder.build_response(context)

    except ControlPolicyError as e:
        logger.warning(f"[{context.transaction_id}] Control policy error halted execution: {e}")
        final_response = builder.build_response(context)

    except Exception as e:
        # Handle unexpected errors during policy execution
        logger.exception(f"[{context.transaction_id}] Unhandled exception during policy flow: {e}")
        # Return a generic 500 error response
        final_response = JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={"detail": "Internal Server Error", "transaction_id": str(context.transaction_id)},
        )

    return final_response

    # Note: Errors during the *initial* policy or *response building itself* might still propagate
    # depending on the builder implementation and FastAPI's overarching handlers.
