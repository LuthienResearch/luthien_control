# Luthien Control: Request/Response Pipeline Architecture

**Status:** Proposed

**Goal:** Refactor the monolithic request/response handling in `luthien_control.proxy.server.proxy_endpoint` into a modular, composable pipeline of processing steps. This will improve maintainability, testability, and flexibility.

## Core Concepts

### 1. Pipeline Context Objects

Instead of passing raw `Request` and `Response` objects along with other disparate variables, we will use dedicated context objects to encapsulate all necessary state for a processing stage.

*   **`RequestContext`**: Holds data relevant *before* the request is sent to the backend.
    *   `request_id: str`
    *   `client_request: fastapi.Request`
    *   `raw_request_body: bytes`
    *   `policy: Policy` (or policy decisions)
    *   `settings: Settings`
    *   `derived_backend_url: httpx.URL` (optional, might be set by a step)
    *   `modified_request_headers: Dict[str, str]` (or List[Tuple[str, str]])
    *   `modified_request_content: bytes`
    *   `final_response: Optional[fastapi.Response]` (If set, pipeline short-circuits)
    *   ... (other metadata added by steps)

*   **`ResponseContext`**: Holds data relevant *after* the response is received from the backend, potentially inheriting or referencing the `RequestContext`.
    *   `request_context: RequestContext` (or relevant fields copied)
    *   `backend_response: httpx.Response`
    *   `raw_response_body: bytes`
    *   `modified_response_headers: Dict[str, str]`
    *   `modified_response_content: bytes`
    *   `modified_status_code: int`
    *   `final_response: Optional[fastapi.Response]` (If set, pipeline short-circuits, potentially overriding backend response processing)
    *   ... (other metadata added by steps)

*Initial thought: Start with separate classes for clarity. Revisit generics (`ControlData[T]`) later if significant overlap justifies it.*

### 2. Pipeline Step Interface

A common interface for all processing steps.

```python
from typing import Protocol, Union

class PipelineStep(Protocol):
    async def execute(self, context: Union[RequestContext, ResponseContext]) -> Union[RequestContext, ResponseContext]:
        """
        Process the context.

        Args:
            context: The current request or response context.

        Returns:
            The potentially modified context.

        Raises:
            Specific exceptions for handling errors within the pipeline.

        Side Effects:
            May modify mutable objects within the context (e.g., headers dict).
            May set context.final_response to short-circuit the pipeline.
        """
        ...
```

### 3. Concrete Pipeline Steps

Individual classes implementing `PipelineStep`, each responsible for a specific piece of logic extracted from `proxy_endpoint`. Examples:

*   `ApplyRequestPolicyStep`: Runs `policy.apply_request_policy`, updates context with headers/content or sets `final_response`.
*   `BuildBackendRequestStep`: Constructs the `httpx.Request` based on context.
*   `SendBackendRequestStep`: Sends the request, receives the response, populates `ResponseContext`.
*   `ApplyResponsePolicyStep`: Runs `policy.apply_response_policy`, updates context.
*   `PrepareFinalResponseStep`: Constructs the `fastapi.Response` from the `ResponseContext`.
*   `LogRequestResponseStep`: Handles logging (potentially split into pre/post steps).
*   `DecompressionStep` / `CompressionStep`: Handle content encoding.
*   `HeaderManipulationStep`: Consolidate various header adjustments.

### 4. Composite Pipeline Steps

Steps that orchestrate other steps.

*   **`SequentialPipeline`**:
    *   Takes a list of `PipelineStep` instances.
    *   Executes them in order, passing the context between them.
    *   Checks for `context.final_response` after each step to allow short-circuiting.

*   **`ConditionalPipeline`** (Future):
    *   Takes a condition (e.g., a callable checking the context) and two or more sub-pipelines (which could be `SequentialPipeline` or other `PipelineStep` instances).
    *   Executes the appropriate sub-pipeline based on the condition.

### 5. Pipeline Orchestration

The `proxy_endpoint` function will be significantly simplified:

1.  Initialize `RequestContext`.
2.  Instantiate the main request pipeline (likely a `SequentialPipeline` containing steps like `ApplyRequestPolicyStep`, `BuildBackendRequestStep`, `SendBackendRequestStep`).
3.  Execute the request pipeline.
4.  Check if `final_response` was set during the request phase. If so, return it.
5.  Initialize `ResponseContext` based on the outcome of `SendBackendRequestStep`.
6.  Instantiate the main response pipeline (e.g., `ApplyResponsePolicyStep`, `PrepareFinalResponseStep`).
7.  Execute the response pipeline.
8.  Return the `final_response` generated by the response pipeline.
9.  Include robust error handling around pipeline execution.

## Incremental Refactoring Plan

1.  Implement basic `RequestContext`, `ResponseContext`, `PipelineStep` interface, and `SequentialPipeline` in `luthien_control.proxy.pipeline`.
2.  Extract `ApplyRequestPolicyStep` logic from `proxy_endpoint`.
3.  Modify `proxy_endpoint` to use a minimal pipeline containing only `ApplyRequestPolicyStep`. Keep remaining logic inline for now, reading from/writing to the context object.
4.  Test thoroughly.
5.  Repeat steps 2-4 for other logical blocks (`SendBackendRequestStep`, `ApplyResponsePolicyStep`, etc.), gradually building the full pipelines and shrinking `proxy_endpoint`. 