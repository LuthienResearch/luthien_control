# Luthien Control: Request/Response Processing Architecture

**Status:** Proposed

**Goal:** Refactor the monolithic request/response handling in `luthien_control.proxy.server.proxy_endpoint` into a modular, composable architecture. This will improve maintainability, testability, and flexibility.

## Core Concepts

### 1. Transaction Context

A central object holding the state for a single request/response transaction throughout its processing lifecycle.

*   **`TransactionContext`**:
    *   `transaction_id: str`: A unique identifier for logging and tracing.
    *   `request: httpx.Request`: The incoming client request, potentially modified during processing.
    *   `response: Optional[httpx.Response]`: The backend response, populated after the backend call.
    *   `final_response: Optional[fastapi.Response]`: If set by any processor, the processing short-circuits, and this response is sent directly to the client.
    *   `data: Dict[Any, Any]`: A flexible dictionary for processors to store and retrieve arbitrary data (e.g., policy decisions, intermediate results, settings).

```python
# Example Minimal Structure (Implementation details may vary)
from typing import Dict, Any, Optional
import httpx
import fastapi

class TransactionContext:
    transaction_id: str
    request: httpx.Request
    response: Optional[httpx.Response] = None
    final_response: Optional[fastapi.Response] = None
    data: Dict[Any, Any] = {}
```

### 2. Control Processor Interface

Defines the standard interface for components that process the `TransactionContext`. Processors are designed to be composable, allowing complex workflows to be built from smaller, focused units.

*   **`ControlProcessor` Interface**:
    *   Requires an `async process(self, context: TransactionContext) -> TransactionContext` method.
    *   Takes the current context as input.
    *   Performs its specific logic (e.g., applying policies, modifying headers, calling the backend).
    *   Returns the (potentially modified) context.
    *   May set `context.final_response` to short-circuit further processing.

### 3. Concrete Control Processors

Examples of specific processor implementations:

*   `ApplyPolicyProcessor`: Executes policy rules against the request or response in the context.
*   `BackendRequestProcessor`: Constructs and sends the request to the backend service, storing the response in the context.
*   `LoggingProcessor`: Records relevant information from the context at different stages.
*   `HeaderManipulationProcessor`: Modifies request or response headers based on rules or context data.
*   `ContentEncodingProcessor`: Handles request/response body compression or decompression.

### 4. Response Builder

A component responsible for constructing the final `fastapi.Response` to be sent back to the client, based on the state of the `TransactionContext` after processing.

*   **`ResponseBuilder` Interface (Conceptual)**:
    *   Takes a final `TransactionContext` as input.
    *   Generates a `fastapi.Response` object.

```python
# Example Minimal Signature
import fastapi
# from .context import TransactionContext # Assuming context is defined elsewhere

class ResponseBuilder:
    def build_response(self, context: TransactionContext) -> fastapi.Response:
        ...
```

### 5. Orchestration

The main proxy endpoint coordinates the flow:

1.  Receive the incoming client `fastapi.Request`.
2.  Generate a unique `transaction_id`.
3.  Build the initial `TransactionContext` (containing the `transaction_id` and the initial `httpx.Request` derived from the client request).
4.  Pass the `TransactionContext` to the main, pre-configured `ControlProcessor` (which might internally compose several other processors).
5.  The processor executes its logic, potentially calling the backend and modifying the context.
6.  Pass the resulting `TransactionContext` to a `ResponseBuilder`.
7.  Send the `fastapi.Response` generated by the builder back to the client.
8.  Ensure robust error handling throughout the process. 